<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0049)http://www.w3.org/TR/scxml/#DataModelIntroduction -->
<html xmlns="http://www.w3.org/1999/xhtml" lang="EN" xml:lang="EN"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="HTML Tidy, see www.w3.org">
<title>State Chart XML (SCXML): State Machine Notation for Control
Abstraction</title>
<style type="text/css">
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }


div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

table {
        width:80%;
        border:1px solid #000;
        border-collapse:collapse;
        font-size:90%;
    }

td,th{
        border:1px solid #000;
        border-collapse:collapse;
        padding:5px;
    }   


caption{
        background:#ccc;
        font-size:140%;
        border:1px solid #000;
        border-bottom:none;
        padding:5px;
        text-align:center;
    }

img.center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
p.caption {
  text-align: center
}

.RFC2119 {
  text-transform: lowercase;
  font-style: italic;
}
</style>

<link type="text/css" rel="stylesheet" href="./State Chart XML (SCXML)_ State Machine Notation for Control Abstraction_files/W3C-PR.css">
<style type="text/css"></style></head>
<body>
<div class="head">
<p><a href="http://www.w3.org/"><img width="72" height="48" alt="W3C" src="./State Chart XML (SCXML)_ State Machine Notation for Control Abstraction_files/w3c_home"></a></p>

<h1><a id="title" name="title">State Chart XML (SCXML): State
Machine Notation for Control Abstraction</a></h1><a id="title" name="title">

</a><h2><a id="title" name="title"></a><a id="w3c-doctype" name="w3c-doctype">W3C Proposed
Recommendation 30 April 2015</a></h2><a id="w3c-doctype" name="w3c-doctype">

</a><dl><a id="w3c-doctype" name="w3c-doctype">
<dt>This version:</dt>
</a><dd><a id="w3c-doctype" name="w3c-doctype"></a><a href="http://www.w3.org/TR/2015/PR-scxml-20150430/">http://www.w3.org/TR/2015/PR-scxml-20150430/</a></dd>

<dt>Latest version:</dt>

<dd><a href="http://www.w3.org/TR/scxml/">http://www.w3.org/TR/scxml/</a></dd>

<dt>Previous version:</dt>
<dd><a href="http://www.w3.org/TR/2014/WD-scxml-20140529/">http://www.w3.org/TR/2014/WD-scxml-20140529/</a></dd>

<dt>Editors:</dt>

<dd>Jim Barnett, Genesys (Editor-in-Chief)</dd>

<dd>Rahul Akolkar, IBM</dd>

<dd>RJ Auburn, Voxeo</dd>

<dd>Michael Bodell, (until 2012, when at Microsoft)</dd>

<dd>Daniel C. Burnett, Voxeo</dd>

<dd>Jerry Carter, (until 2008, when at Nuance)</dd>

<dd>Scott McGlashan, (until 2011, when at HP)</dd>

<dd>Torbjörn Lager, Invited Expert</dd>

<dd>Mark Helbing, (until 2006, when at Nuance)</dd>

<dd>Rafah Hosn, (until 2008, when at IBM)</dd>

<dd>T.V. Raman, (until 2005, when at IBM)</dd>

<dd>Klaus Reifenrath, (until 2006, when at Nuance)</dd>

<dd>No'am Rosenthal, (until 2009, when at Nokia)</dd>

<dd>Johan Roxendal, Invited Expert</dd>
</dl>

<p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>
© 2015 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">
ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">
liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">
trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document
use</a> rules apply.</p>
</div>

<hr>
<div>
<h2><a id="abstract" name="abstract">Abstract</a></h2><a id="abstract" name="abstract">

<p>This document describes SCXML, or the "State Chart extensible
Markup Language". SCXML provides a generic state-machine based
execution environment based on CCXML and Harel State Tables.</p>
</a></div><a id="abstract" name="abstract">

</a><div><a id="abstract" name="abstract">
</a><h2><a id="abstract" name="abstract"></a><a id="status" name="status">Status of this Document</a></h2><a id="status" name="status">

</a><p><a id="status" name="status"><em>This section describes the status of this document at the
time of its publication. Other documents may supersede this
document. A list of current W3C publications and the latest
revision of this technical report can be found in the </em></a><em><a href="http://www.w3.org/TR/">W3C technical reports index</a> at
http://www.w3.org/TR/.</em></p>

<p>This is the 30 April 2015 W3C Proposed Recommendation of SCXML Version
1.0. W3C publishes a technical report as a Proposed Recommendation
to indicate that the document is a mature technical report that has
received wide review for technical soundness and implementability
and to request final endorsement from the W3C Advisory Committee.
Proposed Recommendation status is described in section 7.1.1 of the
<a href="http://www.w3.org/2004/02/Process-20040205/tr.html#maturity-levels">
Process Document</a>.</p>

<p>The W3C Membership and other interested parties are invited to
review the document and send comments to the Working Group's public
mailing list <a href="mailto:www-voice@w3.org">www-voice@w3c.org</a>(<a href="http://lists.w3.org/Archives/Public/www-voice/">archive</a>)
until <strong>30 May 2015, 23:59 EDT</strong>.
See <a href="http://www.w3.org/Mail/">W3C Mailing List
and Archive Usage Guidelines</a>. Advisory Committee
Representatives should consult <a href="http://www.w3.org/2002/09/wbs/myQuestionnaires">their WBS
questionnaires</a>.</p>

<p>This document is based upon the <a href="http://www.w3.org/TR/2014/CR-scxml-20140313/">State Chart XML
(SCXML) Candidate Recommendation</a> of 13 March 2014, the
subsequent third <a href="http://www.w3.org/TR/2014/WD-scxml-20140529/">Last Call
Working Draft</a> version of 29 May 2014, and feedback received
during the review period (see the <a href="http://www.w3.org/TR/scxml/scxml_DoC.html">Disposition of
Comments</a> document). The substantive changes from
29 May 2014 Last Call Working Draft consist in the removal of the
XPath Datamodel and the DOM Event I/O Processor, both of which were
listed as features at risk in the 13 March 2014 Candidate
Recommendation.</p>

<p>The <a href="http://www.w3.org/Voice/">Voice Browser Working
Group</a> (<a href="http://www.w3.org/Help/Account/">W3C Members
only)</a> believes that this specification addresses its requirements
and all Last Call and Candidate Recommendation issues.  Known
implementations are documented in
the <a href="http://www.w3.org/Voice/2013/scxml-irp/">SCXML 1.0
Implementation Report</a>, along with the associated test suite.</p>

<p>This document has been produced as part of the <a href="http://www.w3.org/Voice/">Voice Browser Activity</a> <a href="http://www.w3.org/Voice/Activity">(activity statement)</a>,
following the procedures set out for the <a href="http://www.w3.org/Consortium/Process/">W3C Process</a>. The
authors of this document are members of the <a href="http://www.w3.org/Voice/">Voice Browser Working
Group</a>.</p>

<p>This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5
February 2004 W3C Patent Policy</a>.
W3C maintains a <a href="http://www.w3.org/2004/01/pp-impl/34665/status" rel="disclosure">public list of any patent disclosures</a> made in
connection with the deliverables of the group; that page also
includes instructions for disclosing a patent. An individual who
has actual knowledge of a patent which the individual believes
contains <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">
Essential Claim(s)</a> must disclose the information in accordance
with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">
section 6 of the W3C Patent Policy</a>.</p>

<p>Publication as a Proposed Recommendation does not imply
endorsement by the W3C Membership. This is a draft document and may
be updated, replaced or obsoleted by other documents at any time.
It is inappropriate to cite this document as other than work in
progress.</p>

<p>This document is governed by the <a id="w3c_process_revision" href="http://www.w3.org/2005/10/Process-20051014/">14 October 2005 W3C
Process Document</a>. </p>

<p>The sections of this document are normative unless otherwise
specified.</p>
</div>

<div class="toc">
<h2><a id="contents" name="contents">Table of Contents</a></h2><a id="contents" name="contents">

</a><p class="toc"><a id="contents" name="contents">1 </a><a href="http://www.w3.org/TR/scxml/#terminology">Terminology</a><br>
2 <a href="http://www.w3.org/TR/scxml/#overview">Overview</a><br>
3 <a href="http://www.w3.org/TR/scxml/#Basic">Core Constructs</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.1 <a href="http://www.w3.org/TR/scxml/#CoreIntroduction">Introduction</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.2 <a href="http://www.w3.org/TR/scxml/#scxml">&lt;scxml&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.3 <a href="http://www.w3.org/TR/scxml/#state">&lt;state&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.4 <a href="http://www.w3.org/TR/scxml/#parallel">&lt;parallel&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.5 <a href="http://www.w3.org/TR/scxml/#transition">&lt;transition&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.6 <a href="http://www.w3.org/TR/scxml/#initial">&lt;initial&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.7 <a href="http://www.w3.org/TR/scxml/#final">&lt;final&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.8 <a href="http://www.w3.org/TR/scxml/#onentry">&lt;onentry&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.9 <a href="http://www.w3.org/TR/scxml/#onexit">&lt;onexit&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.10 <a href="http://www.w3.org/TR/scxml/#history">&lt;history&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.11 <a href="http://www.w3.org/TR/scxml/#LegalStateConfigurations">Legal State Configurations and
Specifications</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.12 <a href="http://www.w3.org/TR/scxml/#events">SCXML
Events</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.13 <a href="http://www.w3.org/TR/scxml/#SelectingTransitions">Selecting and Executing
Transitions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.14 <a href="http://www.w3.org/TR/scxml/#IDs">IDs</a><br>
4 <a href="http://www.w3.org/TR/scxml/#executable">Executable Content</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.1 <a href="http://www.w3.org/TR/scxml/#ExecutableIntroduction">Introduction</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.2 <a href="http://www.w3.org/TR/scxml/#raise">&lt;raise&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.3 <a href="http://www.w3.org/TR/scxml/#if">&lt;if&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.4 <a href="http://www.w3.org/TR/scxml/#elseif">&lt;elseif&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.5 <a href="http://www.w3.org/TR/scxml/#else">&lt;else&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.6 <a href="http://www.w3.org/TR/scxml/#foreach">&lt;foreach&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.7 <a href="http://www.w3.org/TR/scxml/#log">&lt;log&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.8 <a href="http://www.w3.org/TR/scxml/#profile-dependentexecutablecontent">Other Executable
Content</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.9 <a href="http://www.w3.org/TR/scxml/#EvaluationofExecutableContent">Evaluation of Executable
Content</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.10 <a href="http://www.w3.org/TR/scxml/#extensibility">Extensibility
of Executable Content</a><br>
5 <a href="http://www.w3.org/TR/scxml/#data-module">Data Model and Data Manipulation</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;5.1 <a href="./State Chart XML (SCXML)_ State Machine Notation for Control Abstraction_files/State Chart XML (SCXML)_ State Machine Notation for Control Abstraction.html">Introduction</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;5.2 <a href="http://www.w3.org/TR/scxml/#datamodel">&lt;datamodel&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;5.3 <a href="http://www.w3.org/TR/scxml/#data">&lt;data&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;5.4 <a href="http://www.w3.org/TR/scxml/#assign">&lt;assign&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;5.5 <a href="http://www.w3.org/TR/scxml/#donedata">&lt;donedata&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;5.6 <a href="http://www.w3.org/TR/scxml/#content">&lt;content&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;5.7 <a href="http://www.w3.org/TR/scxml/#param">&lt;param&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;5.8 <a href="http://www.w3.org/TR/scxml/#script">&lt;script&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;5.9 <a href="http://www.w3.org/TR/scxml/#Expressions">Expressions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;5.10 <a href="http://www.w3.org/TR/scxml/#SystemVariables">System
Variables</a><br>
6 <a href="http://www.w3.org/TR/scxml/#external-module">External Communications</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;6.1 <a href="http://www.w3.org/TR/scxml/#ExternalIntroduction">Introduction</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;6.2 <a href="http://www.w3.org/TR/scxml/#send">&lt;send&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;6.3 <a href="http://www.w3.org/TR/scxml/#cancel">&lt;cancel&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;6.4 <a href="http://www.w3.org/TR/scxml/#invoke">&lt;invoke&gt;</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;6.5 <a href="http://www.w3.org/TR/scxml/#finalize">&lt;finalize&gt;</a><br>
</p>

<h3><a id="appendices" name="appendices">Appendices</a></h3><a id="appendices" name="appendices">

</a><p class="toc"><a id="appendices" name="appendices">A </a><a href="http://www.w3.org/TR/scxml/#conformance">Conformance</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;A.1 <a href="http://www.w3.org/TR/scxml/#ConformingDocuments">Conforming Documents</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;A.2 <a href="http://www.w3.org/TR/scxml/#ConformingProcessors">Conforming Processors</a><br>
B <a href="http://www.w3.org/TR/scxml/#profiles">Data Models</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;B.1 <a href="http://www.w3.org/TR/scxml/#minimal-profile">The Null
Data Model</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;B.2 <a href="http://www.w3.org/TR/scxml/#ecma-profile">The ECMAScript
Data Model</a><br>
C <a href="http://www.w3.org/TR/scxml/#eventioprocessors">Event I/O Processors</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;C.1 <a href="http://www.w3.org/TR/scxml/#SCXMLEventProcessor">SCXML
Event I/O Processor</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;C.2 <a href="http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor">Basic HTTP Event I/O
Processor</a><br>
D <a href="http://www.w3.org/TR/scxml/#AlgorithmforSCXMLInterpretation">Algorithm for SCXML
Interpretation</a><br>
E <a href="http://www.w3.org/TR/scxml/#schemas">Schema</a><br>
F <a href="http://www.w3.org/TR/scxml/#relatedWork">Related Work</a><br>
G <a href="http://www.w3.org/TR/scxml/#Examples">Examples</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;G.1 <a href="http://www.w3.org/TR/scxml/#N11608">Language
Overview</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;G.2 <a href="http://www.w3.org/TR/scxml/#N11619">Microwave
Example</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;G.3 <a href="http://www.w3.org/TR/scxml/#MicrowaveParallel">Microwave
Example (Using parallel)</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;G.4 <a href="http://www.w3.org/TR/scxml/#N11630">Calculator
Example</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;G.5 <a href="http://www.w3.org/TR/scxml/#invokeex">Examples of Invoke
and finalize</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;G.6 <a href="http://www.w3.org/TR/scxml/#content_and_namespaces">Inline Content and
Namespaces</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;G.7 <a href="http://www.w3.org/TR/scxml/#custom_action">Custom Action
Elements</a><br>
H <a href="http://www.w3.org/TR/scxml/#mimetype">MIME Type</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;H.1 <a href="http://www.w3.org/TR/scxml/#media-type-registration">Registration of MIME media type
application/scxml+xml</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;H.2 <a href="http://www.w3.org/TR/scxml/#media-type-fragid">Fragment
Identifiers</a><br>
I <a href="http://www.w3.org/TR/scxml/#references">References</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;I.1 <a href="http://www.w3.org/TR/scxml/#N1173E">Normative
References</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;I.2 <a href="http://www.w3.org/TR/scxml/#N117DA">Informative
References</a><br>
</p>
</div>

<hr>
<div class="body">
<div class="div1">
<h2><a id="terminology" name="terminology">1 Terminology</a></h2><a id="terminology" name="terminology">

</a><p><a id="terminology" name="terminology">The key words <em title="MUST in RFC2119 context" class="RFC2119">MUST</em>, <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em>, <em title="REQUIRED in RFC2119 context" class="RFC2119">REQUIRED</em>,
<em title="SHALL in RFC2119 context" class="RFC2119">SHALL</em>,
<em title="SHALL NOT in RFC2119 context" class="RFC2119">SHALL
NOT</em>, <em title="SHOULD in RFC2119 context" class="RFC2119">SHOULD</em>, <em title="SHOULD NOT in RFC2119 context" class="RFC2119">SHOULD
NOT</em>, <em title="RECOMMENDED in RFC2119 context" class="RFC2119">RECOMMENDED</em>, <em title="MAY in RFC2119 context" class="RFC2119">MAY</em>, and <em title="OPTIONAL in RFC2119 context" class="RFC2119">OPTIONAL</em>
in this specification are to be interpreted as described in </a><a href="http://www.w3.org/TR/scxml/#RFC2119">[RFC 2119]</a>.</p>

<p>The terms base URI and relative URI are used in this
specification as they are defined in <a href="http://www.w3.org/TR/scxml/#RFC2396">[RFC
2396]</a>.</p>

<p>All sections not marked as "informative" are normative.</p>
</div>

<div class="div1">
<h2><a id="overview" name="overview">2 Overview</a></h2><a id="overview" name="overview">

<p>[This section is informative.]</p>

</a><p><a id="overview" name="overview">This document outlines State Chart XML (SCXML), which is a
general-purpose event-based state machine language that combines
concepts from CCXML and Harel State Tables. CCXML </a><a href="http://www.w3.org/TR/scxml/#CCXML">[CCXML 1.0]</a> is an event-based state machine
language designed to support call control features in Voice
Applications (specifically including VoiceXML but not limited to
it). The CCXML 1.0 specification defines both a state machine and
event handing syntax and a standardized set of call control
elements. Harel State Tables are a state machine notation that was
developed by the mathematician David Harel <a href="http://www.w3.org/TR/scxml/#Harel_Politi">[Harel and Politi]</a> and is included in UML
<a href="http://www.w3.org/TR/scxml/#UML">[UML 2.3]</a>. They offer a clean and well-thought
out semantics for sophisticated constructs such as parallel states.
They have been defined as a graphical specification language,
however, and hence do not have an XML representation. The goal of
this document is to combine Harel semantics with an XML syntax that
is a logical extension of CCXML's state and event notation.</p>

<p><a href="http://www.w3.org/TR/scxml/#Basic"><em>3 Core Constructs</em></a> presents the
core state machine concepts, while <a href="http://www.w3.org/TR/scxml/#executable"><em>4
Executable Content</em></a> contains an extensible set of actions
that the state machine can take in response to events. <a href="http://www.w3.org/TR/scxml/#data-module"><em>5 Data Model and Data Manipulation</em></a>
defines constructs for storing and modifying data, while <a href="http://www.w3.org/TR/scxml/#external-module"><em>6 External Communications</em></a>
provides the capability of communicating with external
entities.</p>
</div>

<div class="div1">
<h2><a id="Basic" name="Basic">3 Core Constructs</a></h2><a id="Basic" name="Basic">

</a><div class="div2"><a id="Basic" name="Basic">
</a><h3><a id="Basic" name="Basic"></a><a id="CoreIntroduction" name="CoreIntroduction">3.1
Introduction</a></h3><a id="CoreIntroduction" name="CoreIntroduction">

<p>[This section is informative.]</p>

</a><div class="div3"><a id="CoreIntroduction" name="CoreIntroduction">
</a><h4><a id="CoreIntroduction" name="CoreIntroduction"></a><a id="BasicState" name="BasicState">3.1.1 Basic State
Machine Notation</a></h4><a id="BasicState" name="BasicState">

</a><p><a id="BasicState" name="BasicState">The most basic state machine concepts are </a><a href="http://www.w3.org/TR/scxml/#state"><em>3.3 &lt;state&gt;</em></a>, <a href="http://www.w3.org/TR/scxml/#transition"><em>3.5 &lt;transition&gt;</em></a> and event
(<a href="http://www.w3.org/TR/scxml/#events"><em>3.12 SCXML Events</em></a>). Each state
contains a set of transitions that define how it reacts to events.
Events can be generated by the state machine itself or by external
entities. In a traditional state machine, the machine is always in
a single state. This state is called the active state. When an
event occurs, the state machine checks the transitions that are
defined in the active state. If it finds one that matches the
event, it moves from the active state to the state specified by the
transition (called the "target" of the transition.) Thus the target
state becomes the new active state.</p>

<p>The Harel state notation defines several extensions to these
basic notions. First of all, the state machine may take actions (as
defined in <a href="http://www.w3.org/TR/scxml/#executable"><em>4 Executable Content</em></a>)
while taking transitions. Specifically, each state may contain <a href="http://www.w3.org/TR/scxml/#onentry"><em>3.8 &lt;onentry&gt;</em></a> and <a href="http://www.w3.org/TR/scxml/#onexit"><em>3.9 &lt;onexit&gt;</em></a> actions. Transitions
may also contain actions. If a state machine takes transition T
from state S1 to state S2, it first performs the onexit actions in
S1, then the actions in T, then the onentry actions in S2.
Secondly, in addition to the 'event' attribute that specifies the
event(s) that can trigger it, transitions also have a 'cond'
attribute. If a transition has both 'event' and 'cond' attributes,
it will be selected only if an event is raised whose name matches
the 'event' attribute (see <a href="http://www.w3.org/TR/scxml/#EventDescriptors"><em>3.12.1
Event Descriptors</em></a> for details) and the 'cond' condition
evaluates to true. If the 'event' attribute is missing, the
transition is taken whenever the 'cond' evaluates to true. If more
than one transition matches, the first one in document order will
be taken. Thus, in the following example, the system will
transition to s1 when event e (or e.foo, etc.) occurs if x is equal
to 1, but will transition to s2 if event e (or e.foo, etc.) occurs
and x is not equal to 1, and will go to s3 if any other event
occurs.</p>

<div class="exampleInner">
<pre>&lt;state id=s"&gt;
   &lt;transition event="e" cond="x==1" target="s1"/&gt;
   &lt;transition event="e" target="s2"/&gt;
   &lt;transition event="*" target="s3"/&gt;
&lt;/state&gt;
</pre>
</div>
</div>

<div class="div3">
<h4><a id="N10192" name="N10192">3.1.2 Compound States</a></h4><a id="N10192" name="N10192">

<p>One of the most powerful concepts in Harel notation is the idea
that states may have internal structure. In particular, a
&lt;state&gt; element may contain nested &lt;state&gt; elements.
Such a state is called a compound state and we speak of it as the
parent state, while the nested elements are child states. The child
states may themselves have nested children and the nesting may
proceed to any depth. Ultimately we will reach a state that does
not contain any child states. Such a state is called an atomic
state. When a compound state is active, one and only one of its
child states is active. Conversely, when an child state is active,
its parent state must be active too. Thus at any point we have a
set of active states, containing an atomic state and all of its
ancestors. (We will see in the next section that multiple atomic
states can be active at the same time.)</p>

<p>Compound states also affect how transitions are selected. When
looking for transitions, the state machine first looks in the most
deeply nested active state(s), i.e., in the atomic state(s) that
have no substates. If no transitions match in the atomic state, the
state machine will look in its parent state, then in the parent's
parent, etc. Thus transitions in ancestor states serve as defaults
that will be taken if no transition matches in a descendant state.
If no transition matches in any state, the event is discarded.</p>
</a></div><a id="N10192" name="N10192">

</a><div class="div3"><a id="N10192" name="N10192">
</a><h4><a id="N10192" name="N10192"></a><a id="N10199" name="N10199">3.1.3 Parallel States</a></h4><a id="N10199" name="N10199">

<p>The &lt;parallel&gt; element represents a state whose children
execute in parallel. Like &lt;state&gt;, the &lt;parallel&gt;
element contains &lt;onentry&gt;, &lt;onexit&gt;,
&lt;transition&gt;, and &lt;state&gt; or &lt;parallel&gt; children.
However, the semantics of &lt;parallel&gt; are different. When a
&lt;state&gt; is active, exactly one of its children is active.
When a &lt;parallel&gt; element is active, <em>all</em> of its
children are active. Specifically, when the state machine enters
the parent &lt;parallel&gt; state, it also enters each child state.
The child states execute in parallel in the sense that any event
that is processed is processed in each child state independently,
and each child state may take a different transition in response to
the event. (Similarly, one child state may take a transition in
response to an event, while another child ignores it.) When all of
the children reach final states, the &lt;parallel&gt; element
itself is considered to be in a final state, and a completion event
done.state.<em>id</em> is generated, where <em>id</em> is the id of
the &lt;parallel&gt; element.</p>

<p>Transitions <em>within</em> the individual child elements
operate normally. However whenever a transition is taken with a
target <em>outside</em> the &lt;parallel&gt; element, the
&lt;parallel&gt; element and all of its child elements are exited
and the corresponding &lt;onexit&gt; handlers are executed. The
handlers for the child elements execute first, in document order,
followed by those of the parent &lt;parallel&gt; element, followed
by an action expression in the &lt;transition&gt; element, and then
the &lt;onentry&gt; handlers in the "target" state.</p>

<p>In the following example, parallel state 'p' has two children S1
and S2. Suppose a transition takes S1's child S12 as a target.
(Note that this is permitted even though S12 is not the default
initial state for S1 and that S11 is not, in fact, visited in the
course of this example). Upon this transition, the state machine,
in addition to entering S1 and S12, will also enter S1's parallel
sibling S2 and its initial state S21. Once the transition has been
taken, p, S1, S2, S12, and S21 will all be active. If event 'e1'
occurs, it will cause S12 to transition to S1Final, and S21 to
transition to S22. Entering S1Final will cause the event
done.state.S1 to be generated. At this point, S1 is in a final
state, but S2 is still active. Now suppose event 'e2' occurs. This
will cause S22 to transition to S2Final, and the event
done.state.S2 will be generated. Furthermore, since all of p's
children are now in final states, the event 'done.state.p' will be
generated, which will cause the transition contained in p to be
triggered, exiting the entire region.</p>

<div class="exampleInner">
<pre>&lt;parallel id="p"&gt;

    &lt;transition event="done.state.p" target="someOtherState"/&gt;

    &lt;state id="S1" initial="S11"&gt;
        &lt;state id="S11"&gt;
            &lt;transition event="e4" target="S12"/&gt;
        &lt;/state&gt;
        &lt;state id="S12"&gt;
            &lt;transition event="e1" target="S1Final"/&gt;
        &lt;/state&gt;
        &lt;final id="S1Final"/&gt;
    &lt;/state&gt; 

    &lt;state id="S2" initial="S21"&gt;
        &lt;state id=S21"&gt;
            &lt;transition event="e1" target="S22"/&gt;
        &lt;/state&gt;
        &lt;state id="S22"&gt;
            &lt;transition event="e2" target="S2Final/&gt;
        &lt;/state&gt;
        &lt;final id="S2Final"/&gt;
    &lt;/state&gt; 

&lt;/parallel&gt;
</pre>
</div>

</a><p><a id="N10199" name="N10199">Note that the semantics of the &lt;parallel&gt; element does not
call for multiple threads or truly concurrent processing. The
children of &lt;parallel&gt; execute in parallel in the sense that
they are all simultaneously active and each one independently
selects transitions for any event that is received. However, the
parallel children process the event in a defined, serial order, so
no conflicts or race conditions can occur. See </a><a href="http://www.w3.org/TR/scxml/#AlgorithmforSCXMLInterpretation"><em>D Algorithm for SCXML
Interpretation</em></a> for a detailed description of the semantics
of &lt;parallel&gt; and the rest of SCXML.</p>
</div>

<div class="div3">
<h4><a id="N101B9" name="N101B9">3.1.4 Initial, Final, and
History States</a></h4><a id="N101B9" name="N101B9">

</a><p><a id="N101B9" name="N101B9">In the presence of compound states, transitions no longer simply
move from the current active state to a new active state, but from
one set of active states to another. (See </a><a href="http://www.w3.org/TR/scxml/#LegalStateConfigurations"><em>3.11 Legal State
Configurations and Specifications</em></a> for details.) If the
target of a transition is an atomic state, the state machine will
enter not only the atomic state, but also any of its ancestor
states that are not already active. Conversely, a transition may
take a compound state as its target. In this case, one of the
compound state's children must also become active, but the
transition does not specify which one. In this case we look at the
target state's <a href="http://www.w3.org/TR/scxml/#initial"><em>3.6 &lt;initial&gt;</em></a>
child which specifies the state's default initial state, that is,
the child state to enter if the transition does not specify one.
(If the default initial state is itself compound, the state machine
will also enter its default initial state, and so on recursively
until it reaches an atomic state.) The presence of default initial
states provides a form of encapsulation, since a transition may
select a compound state as its target without understanding its
internal substate structure.</p>

<p>The default initial state of a compound state may also be
specified via the 'initial' attribute. The only difference between
the &lt;initial&gt; element and the 'initial' attribute is that the
&lt;initial&gt; element contains a &lt;transition&gt; element which
may in turn contain executable content which will be executed
before the default state is entered. If the 'initial' attribute is
specified instead, the specified state will be entered, but no
executable content will be executed. (If neither the
&lt;initial&gt; child or the 'initial' element is specified, the
default initial state is the first child state in document order.)
As an example, suppose that parent state S contains child states S1
and S2 in that order. If S specifies S1 as its default initial
state via the 'initial' attribute (or fails to specify any initial
state), then any transition that specifies S as its target will
result in the state machine entering S1 as well as S. In this case,
the result is exactly the same as if the transition had taken S1 as
its target. If, on the other hand, S specifies S1 as its default
initial state via an &lt;initial&gt; element containing a
&lt;transition&gt; with S1 as its target, the &lt;transition&gt;
can contain executable content which will execute before the
default entry into S1. In this case, there is a difference between
a transition that takes S as its target and one that takes S1 as
its target. In the former case, but not in the latter, the
executable content inside the &lt;initial&gt; transition will be
executed.</p>

<p>A compound state may also have final and history states as
children. <a href="http://www.w3.org/TR/scxml/#final"><em>3.7 &lt;final&gt;</em></a> is used
to signify that the parent state is in some sense "done" with its
processing. When a state machine enters a &lt;final&gt; substate of
a compound state, the parent state remains active, but the event
"done.state.<em>id</em>" is generated, where <em>id</em> is the
state id of the parent state. This event can trigger a transition
in any ancestor state (including the parent). If the transition
takes a target outside the parent state, the
"done.state.<em>id</em>" event in effect serves as a signal that it
is time to leave the parent state. <a href="http://www.w3.org/TR/scxml/#history"><em>3.10
&lt;history&gt;</em></a> allows for pause and resume semantics in
compound states. Before the state machine exits a compound state,
it records the state's active descendants. If the 'type' attribute
of the &lt;history&gt; state is set to "deep", the state machine
saves the state's full active descendant configuration, down to the
atomic descendant(s). If 'type' is set to "shallow", the state
machine remembers only which immediate child was active. After
that, if a transition takes a &lt;history&gt; child of the state as
its target, the state machine re-enters not only the parent
compound state but also the state(s) in the saved configuration.
Thus a transition with a deep history state as its target returns
to exactly where the state was when it was last exited, while a
transition with a shallow history state as a target re-enters the
previously active child state, but will enter the child's default
initial state (if the child is itself compound.)</p>
</div>

<div class="div3">
<h4><a id="N101D7" name="N101D7">3.1.5 'Type' and
Transitions</a></h4><a id="N101D7" name="N101D7">

</a><p><a id="N101D7" name="N101D7">In the case of a transition located in a compound state, the
'type' attribute is significant. The behavior of a transition with
'type' of "external" (the default) is defined in terms of the
transition's source state (which is the state that contains the
transition), the transition's target state(or states), and the </a><a href="http://www.w3.org/TR/scxml/#LCCA">Least Common Compound Ancestor (LCCA)</a> of the
source and target states (which is the closest compound state that
is an ancestor of all the source and target states). When a
transition is taken, the state machine will exit all active states
that are proper descendants of the LCCA, starting with the
innermost one(s) and working up to the immediate descendant(s) of
the LCCA. (A 'proper descendant' of a state is a child, or a child
of a child, or a child of a child of a child, etc.) Then the state
machine enters the target state(s), plus any states that are
between it and the LCCA, starting with the outermost one (i.e., the
immediate descendant of the LCCA) and working down to the target
state(s). As states are exited, their &lt;onexit&gt; handlers are
executed. Then the executable content in the transition is
executed, followed by the &lt;onentry&gt; handlers of the states
that are entered. If the target state(s) of the transition is not
atomic, the state machine will enter their default initial states
recursively until it reaches an atomic state(s).</p>

<p>In the example below, assume that state s11 is active when event
'e' occurs. The source of the transition is state s1, its target is
state s21, and the LCCA is state S. When the transition is taken,
first state S11 is exited, then state s1, then state s2 is entered,
then state s21. Note that the LCCA S is neither entered nor exited.
For more details see <a href="http://www.w3.org/TR/scxml/#SelectingTransitions"><em>3.13
Selecting and Executing Transitions</em></a> and <a href="http://www.w3.org/TR/scxml/#AlgorithmforSCXMLInterpretation"><em>D Algorithm for SCXML
Interpretation</em></a>.</p>

<div class="exampleInner">
<pre>&lt;state id="S" initial="s1"&gt;
   &lt;state id="s1" initial="s11"&gt;
      &lt;onexit&gt;
         &lt;log expr="'leaving s1'"/&gt;
     &lt;/onexit&gt;
     
     &lt;state id="s11"&gt;
        &lt;onexit&gt;
           &lt;log expr="'leaving s11'"/&gt;
        &lt;/onexit&gt;
     &lt;/state&gt;
     
     &lt;transition event="e" target="s21"&gt;
        &lt;log expr="'executing transition'"/&gt;
     &lt;/transition&gt;

   &lt;/state&gt;
  
   &lt;state id="s2" initial="s21"&gt;
      &lt;state id="s21"&gt;
         &lt;onentry&gt;
            &lt;log expr="'entering s21'"/&gt;
         &lt;/onentry&gt;
      &lt;/state&gt;
      &lt;onentry&gt;
         &lt;log expr="'entering s2'"/&gt;
      &lt;/onentry&gt;
   &lt;/state&gt;

   &lt;onentry&gt;
     &lt;log expr="'entering S'"/&gt;
   &lt;onentry&gt;   
   &lt;onexit&gt;
     &lt;log expr="'leaving S'"/&gt;
   &lt;onexit&gt;
&lt;/state&gt;

==== log output will be ======&gt;

leaving s11
leaving s1
executing transition
entering s2
entering s21
</pre>
</div>

<p>The behavior of transitions with 'type' of "internal" is
identical, except in the case of a transition whose source state is
a compound state and whose target(s) is a descendant of the source.
In such a case, an internal transition will not exit and re-enter
its source state, while an external one will, as shown in the
example below.</p>

<div class="exampleInner">
<pre>&lt;state id="S" initial="s1"&gt;
   &lt;state id="s1" initial="s11"&gt;
      &lt;onentry&gt;
        &lt;log expr="entering S1"/&gt;
        &lt;/onentry&gt;
      &lt;onexit&gt;
         &lt;log expr="'leaving s1'"/&gt;
     &lt;/onexit&gt;
     
     &lt;state id="s11"&gt;
       &lt;onentry&gt;
        &lt;log expr="entering s11"/&gt;
       &lt;/onentry&gt;
        &lt;onexit&gt;
           &lt;log expr="'leaving s11'"/&gt;
        &lt;/onexit&gt;
     &lt;/state&gt;
     
     &lt;transition event="e" target="s11" type="internal"&gt;
        &lt;log expr="'executing transition'"/&gt;
     &lt;/transition&gt;

   &lt;/state&gt;
  


==== log output will be ======&gt;

leaving s11
executing transition
entering s11

=== if transition were external, log output would be ====&gt;

leaving s11
leaving s1
executing transition
entering s1
entering s11

</pre>
</div>

<p>If the 'target' on a &lt;transition&gt; is omitted, then the
value of 'type' does not have any effect and taking the transition
does not change the state configuration but does invoke the
executable content that is included in the transition. Note that
this is different from a &lt;transition&gt; whose 'target' is its
source state. In the latter case, the state is exited and
reentered, triggering execution of its &lt;onentry&gt; and
&lt;onexit&gt; executable content.</p>
</div>
</div>

<div class="div2">
<h3><a id="scxml" name="scxml">3.2 &lt;scxml&gt;</a></h3><a id="scxml" name="scxml">

<p>[This section is normative.]</p>

</a><p><a id="scxml" name="scxml">The top-level wrapper element, which carries version
information. The actual state machine consists of its children.
Note that only one of the children is active at any one time. See
</a><a href="http://www.w3.org/TR/scxml/#LegalStateConfigurations"><em>3.11 Legal State
Configurations and Specifications</em></a> for details.</p>

<div class="div3">
<h4><a id="scxml-attr" name="scxml-attr">3.2.1 Attribute
Details</a></h4><a id="scxml-attr" name="scxml-attr">

<table border="1" summary="attibute table">
<tbody>
<tr>
<th>Name</th>
<th>Required</th>
<th>Attribute Constraints</th>
<th>Type</th>
<th>Default Value</th>
<th>Valid Values</th>
<th>Description</th>
</tr>

<tr>
<td>initial</td>
<td>false</td>
<td>none</td>
<td>IDREFS</td>
<td>none</td>
<td>A legal state specification. See <a href="http://www.w3.org/TR/scxml/#LegalStateConfigurations"><em>3.11 Legal State
Configurations and Specifications</em></a> for details.</td>
<td>The id of the initial state(s) for the document. If not
specified, the default initial state is the first child state in
document order.</td>
</tr>

<tr>
<td>name</td>
<td>false</td>
<td>none</td>
<td>NMTOKEN</td>
<td>none</td>
<td>Any valid NMTOKEN</td>
<td>The name of this state machine. It is for purely informational
purposes.</td>
</tr>

<tr>
<td>xmlns</td>
<td>true</td>
<td>none</td>
<td>URI</td>
<td>none</td>
<td>The value <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> be
"http://www.w3.org/2005/07/scxml".</td>
<td></td>
</tr>

<tr>
<td>version</td>
<td>true</td>
<td>none</td>
<td>decimal</td>
<td>none</td>
<td>The value <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> be "1.0"</td>
<td></td>
</tr>

<tr>
<td>datamodel</td>
<td>false</td>
<td>none</td>
<td>NMTOKEN</td>
<td>platform-specific</td>
<td>"null", "ecmascript", "xpath" or other platform-defined
values.</td>
<td>The datamodel that this document requires. "null" denotes the
Null datamodel, "ecmascript" the ECMAScript datamodel, and "xpath"
the XPath datamodel, as defined in <a href="http://www.w3.org/TR/scxml/#profiles"><em>B Data
Models</em></a>.</td>
</tr>

<tr>
<td>binding</td>
<td>false</td>
<td>none</td>
<td>enum</td>
<td>"early"</td>
<td>"early", "late"</td>
<td>The data binding to use. See <a href="http://www.w3.org/TR/scxml/#DataBinding"><em>5.3.3
Data Binding</em></a> for details.</td>
</tr>
</tbody>
</table>
</a></div><a id="scxml-attr" name="scxml-attr">

</a><div class="div3"><a id="scxml-attr" name="scxml-attr">
</a><h4><a id="scxml-attr" name="scxml-attr"></a><a id="N1027F" name="N1027F">3.2.2 Children</a></h4><a id="N1027F" name="N1027F">

</a><ul><a id="N1027F" name="N1027F">
</a><li><a id="N1027F" name="N1027F">&lt;state&gt; A compound or atomic state. Occurs zero or more
times. See </a><a href="http://www.w3.org/TR/scxml/#state"><em>3.3 &lt;state&gt;</em></a> for
details.</li>

<li>&lt;parallel&gt; A parallel state. Occurs zero or more times.
See <a href="http://www.w3.org/TR/scxml/#parallel"><em>3.4 &lt;parallel&gt;</em></a> for
details.</li>

<li>&lt;final&gt; A top-level final state in the state machine.
Occurs zero or more times. The SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> terminate
processing when the state machine reaches this state. See <a href="http://www.w3.org/TR/scxml/#final"><em>3.7 &lt;final&gt;</em></a> for details.</li>

<li>&lt;datamodel&gt; Defines part or all of the data model. Occurs
0 or 1 times. See <a href="http://www.w3.org/TR/scxml/#datamodel"><em>5.2
&lt;datamodel&gt;</em></a></li>

<li>&lt;script&gt; Provides scripting capability. Occurs 0 or 1
times. <a href="http://www.w3.org/TR/scxml/#script"><em>5.8 &lt;script&gt;</em></a></li>
</ul>
</div>

<p>A conformant SCXML document <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> have at least one &lt;state&gt;,
&lt;parallel&gt; or &lt;final&gt; child. At system initialization
time, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> enter the states specified by the
'initial' attribute, if it is present. If it is not present, the
Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> enter the first state in document order.
Platforms <em title="SHOULD in RFC2119 context" class="RFC2119">SHOULD</em> document their default data model.</p>
</div>

<div class="div2">
<h3><a id="state" name="state">3.3 &lt;state&gt;</a></h3><a id="state" name="state">

<p>[This section is normative.]</p>

<p>Holds the representation of a state.</p>

</a><div class="div3"><a id="state" name="state">
</a><h4><a id="state" name="state"></a><a id="N102B8" name="N102B8">3.3.1 Attribute Details</a></h4><a id="N102B8" name="N102B8">

<table border="1" summary="attibute table">
<tbody>
<tr>
<th>Name</th>
<th>Required</th>
<th>Attribute Constraints</th>
<th>Type</th>
<th>Default Value</th>
<th>Valid Values</th>
<th>Description</th>
</tr>

<tr>
<td>id</td>
<td>false</td>
<td>none</td>
<td>ID</td>
<td>none</td>
<td>A valid id as defined in <a href="http://www.w3.org/TR/scxml/#Schema">[XML
Schema]</a></td>
<td>The identifier for this state. See <a href="http://www.w3.org/TR/scxml/#IDs"><em>3.14
IDs</em></a> for details.</td>
</tr>

<tr>
<td>initial</td>
<td>false</td>
<td>MUST NOT be specified in conjunction with the &lt;initial&gt;
element. MUST NOT occur in atomic states.</td>
<td>IDREFS</td>
<td>none</td>
<td>A legal state specification. See <a href="http://www.w3.org/TR/scxml/#LegalStateConfigurations"><em>3.11 Legal State
Configurations and Specifications</em></a> for details.</td>
<td>The id of the default initial state (or states) for this
state.</td>
</tr>
</tbody>
</table>
</a></div><a id="N102B8" name="N102B8">

</a><div class="div3"><a id="N102B8" name="N102B8">
</a><h4><a id="N102B8" name="N102B8"></a><a id="N102F5" name="N102F5">3.3.2 Children</a></h4><a id="N102F5" name="N102F5">

</a><ul><a id="N102F5" name="N102F5">
</a><li><a id="N102F5" name="N102F5">&lt;onentry&gt; Optional element holding executable content to
be run upon entering this &lt;state&gt;. Occurs 0 or more times.
See </a><a href="http://www.w3.org/TR/scxml/#onentry"><em>3.8 &lt;onentry&gt;</em></a></li>

<li>&lt;onexit&gt; Optional element holding executable content to
be run when exiting this &lt;state&gt;. Occurs 0 or more times. See
<a href="http://www.w3.org/TR/scxml/#onexit"><em>3.9 &lt;onexit&gt;</em></a></li>

<li>&lt;transition&gt; Defines an outgoing transition from this
state. Occurs 0 or more times. See <a href="http://www.w3.org/TR/scxml/#transition"><em>3.5
&lt;transition&gt;</em></a></li>

<li>&lt;initial&gt; In states that have substates, an optional
child which identifies the default initial state. Any transition
which takes the parent state as its target will result in the state
machine also taking the transition contained inside the
&lt;initial&gt; element. See <a href="http://www.w3.org/TR/scxml/#initial"><em>3.6
&lt;initial&gt;</em></a></li>

<li>&lt;state&gt; Defines a sequential substate of the parent
state. Occurs 0 or more times.</li>

<li>&lt;parallel&gt; Defines a parallel substate. Occurs 0 or more
times. See <a href="http://www.w3.org/TR/scxml/#parallel"><em>3.4
&lt;parallel&gt;</em></a></li>

<li>&lt;final&gt;. Defines a final substate. Occurs 0 or more
times. See <a href="http://www.w3.org/TR/scxml/#final"><em>3.7 &lt;final&gt;</em></a>.</li>

<li>&lt;history&gt; A child pseudo-state which records the
descendant state(s) that the parent state was in the last time the
system transitioned <em>from</em> the parent. May occur 0 or more
times. See <a href="http://www.w3.org/TR/scxml/#history"><em>3.10
&lt;history&gt;</em></a>.</li>

<li>&lt;datamodel&gt; Defines part or all of the data model. Occurs
0 or 1 times. See <a href="http://www.w3.org/TR/scxml/#datamodel"><em>5.2
&lt;datamodel&gt;</em></a></li>

<li>&lt;invoke&gt; Invokes an external service. Occurs 0 or more
times. See <a href="http://www.w3.org/TR/scxml/#invoke"><em>6.4 &lt;invoke&gt;</em></a> for
details.</li>
</ul>
</div>

<p>[<a title="" id="atomic-state" name="atomic-state">Definition</a>: An <em>atomic state</em> is a
&lt;state&gt; that has no &lt;state&gt;, &lt;parallel&gt; or
&lt;final&gt; children.]</p>

<p>[<a title="" id="compound-state" name="compound-state">Definition</a>: A <em>compound state</em> is
a &lt;state&gt; that has &lt;state&gt;, &lt;parallel&gt;, or
&lt;final&gt; children (or a combination of these).]</p>

<p>[<a title="" id="default-initial-state" name="default-initial-state">Definition</a>: The <em>default
initial state(s)</em> of a compound state are those specified by
the 'initial' attribute or &lt;initial&gt; element, if either is
present. Otherwise it is the state's first child state in document
order. ]</p>

<p>In a conformant SCXML document, a compound state <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> specify
either an "initial" attribute or an &lt;initial&gt; element, but
not both. See <a href="http://www.w3.org/TR/scxml/#initial"><em>3.6 &lt;initial&gt;</em></a>
for a discussion of the difference between the two notations.</p>
</div>

<div class="div2">
<h3><a id="parallel" name="parallel">3.4 &lt;parallel&gt;</a></h3><a id="parallel" name="parallel">

<p>[This section is normative.]</p>

<p>The &lt;parallel&gt; element encapsulates a set of child states
which are simultaneously active when the parent element is
active.</p>

</a><div class="div3"><a id="parallel" name="parallel">
</a><h4><a id="parallel" name="parallel"></a><a id="N1035A" name="N1035A">3.4.1 Attribute Details</a></h4><a id="N1035A" name="N1035A">

<table border="1" summary="attibute table">
<tbody>
<tr>
<th>Name</th>
<th>Required</th>
<th>Attribute Constraints</th>
<th>Type</th>
<th>Default Value</th>
<th>Valid Values</th>
<th>Description</th>
</tr>

<tr>
<td>id</td>
<td>false</td>
<td>
</td><td>ID</td>
<td>none</td>
<td>A valid id as defined in <a href="http://www.w3.org/TR/scxml/#Schema">[XML Schema]</a>
</td>
<td>The identifier for this state. See <a href="http://www.w3.org/TR/scxml/#IDs"><em>3.14
IDs</em></a> for details.</td>
</tr>
</tbody>
</table>
</a></div><a id="N1035A" name="N1035A">

</a><div class="div3"><a id="N1035A" name="N1035A">
</a><h4><a id="N1035A" name="N1035A"></a><a id="N10386" name="N10386">3.4.2 Children</a></h4><a id="N10386" name="N10386">

</a><ul><a id="N10386" name="N10386">
</a><li><a id="N10386" name="N10386">&lt;onentry&gt; Holds executable content to be run upon
entering the &lt;parallel&gt; element. Occurs 0 or more times. See
</a><a href="http://www.w3.org/TR/scxml/#onentry"><em>3.8 &lt;onentry&gt;</em></a></li>

<li>&lt;onexit&gt; Holds executable content to be run when exiting
this element. Occurs 0 or more times. See <a href="http://www.w3.org/TR/scxml/#onexit"><em>3.9
&lt;onexit&gt;</em></a></li>

<li>&lt;transition&gt; Defines an outgoing transition from this
state. Occurs 0 or more times. See <a href="http://www.w3.org/TR/scxml/#transition"><em>3.5
&lt;transition&gt;</em></a></li>

<li>&lt;state&gt; Defines a parallel substate region. Occurs 0 or
more times. See <a href="http://www.w3.org/TR/scxml/#state"><em>3.3
&lt;state&gt;</em></a>.</li>

<li>&lt;parallel&gt; Defines a nested set of parallel regions.
Occurs 0 or more times.</li>

<li>&lt;history&gt; A child which represents the state
configuration that this state was in the last time the system
transitioned <em>from</em> it. A transition with this history
pseudo-state as its target is in fact a transition to the set of
descendant states that were active the last time this state was
exited. Occurs 0 or more times. See <a href="http://www.w3.org/TR/scxml/#history"><em>3.10
&lt;history&gt;</em></a>.</li>

<li>&lt;datamodel&gt; Defines part or all of the data model. Occurs
0 or 1 times. See <a href="http://www.w3.org/TR/scxml/#datamodel"><em>5.2
&lt;datamodel&gt;</em></a></li>

<li>&lt;invoke&gt; Invokes an external service. Occurs 0 or more
times. See <a href="http://www.w3.org/TR/scxml/#invoke"><em>6.4 &lt;invoke&gt;</em></a> for
details.</li>
</ul>
</div>
</div>

<div class="div2">
<h3><a id="transition" name="transition">3.5
&lt;transition&gt;</a></h3><a id="transition" name="transition">

<p>[This section is normative.]</p>

<p>Transitions between states are triggered by events and
conditionalized via guard conditions. They may contain executable
content, which is executed when the transition is taken.</p>

</a><div class="div3"><a id="transition" name="transition">
</a><h4><a id="transition" name="transition"></a><a id="N103BF" name="N103BF">3.5.1 Attribute Details</a></h4><a id="N103BF" name="N103BF">

<table border="1" summary="attibute table">
<tbody>
<tr>
<th>Name</th>
<th>Required</th>
<th>Attribute Constraints</th>
<th>Type</th>
<th>Default Value</th>
<th>Valid Values</th>
<th>Description</th>
</tr>

<tr>
<td>event</td>
<td>false</td>
<td></td>
<td>EventsTypes.datatype.</td>
<td>none</td>
<td>A space-separated list of event descriptors. See <a href="http://www.w3.org/TR/scxml/#EventDescriptors"><em>3.12.1 Event Descriptors</em></a> for
details.</td>
<td>A list of designators of events that trigger this transition.
See <a href="http://www.w3.org/TR/scxml/#SelectingTransitions"><em>3.13 Selecting and
Executing Transitions</em></a> for details on how transitions are
selected and executed. See <a href="http://www.w3.org/TR/scxml/#schemas"><em>E Schema</em></a>
for the definition of the datatype.</td>
</tr>

<tr>
<td>cond</td>
<td>false</td>
<td>
</td><td>Boolean expression</td>
<td>'true'</td>
<td>Any boolean expression. See <a href="http://www.w3.org/TR/scxml/#ConditionalExpressions"><em>5.9.1 Conditional
Expressions</em></a> for details.</td>
<td>The guard condition for this transition. See <a href="http://www.w3.org/TR/scxml/#SelectingTransitions"><em>3.13 Selecting and Executing
Transitions</em></a> for details.</td>
</tr>

<tr>
<td>target</td>
<td>false</td>
<td>.</td>
<td>IDREFS</td>
<td>none</td>
<td>A legal state specification. See <a href="http://www.w3.org/TR/scxml/#LegalStateConfigurations"><em>3.11 Legal State
Configurations and Specifications</em></a> for details.</td>
<td>The identifier(s) of the state or parallel region to transition
to. See <a href="http://www.w3.org/TR/scxml/#SelectingTransitions"><em>3.13 Selecting and
Executing Transitions</em></a> for details.</td>
</tr>

<tr>
<td>type</td>
<td>false</td>
<td>
</td><td>enum</td>
<td>"external"</td>
<td>"internal" "external"</td>
<td>Determines whether the source state is exited in transitions
whose target state is a descendant of the source state. See <a href="http://www.w3.org/TR/scxml/#SelectingTransitions"><em>3.13 Selecting and Executing
Transitions</em></a> for details.</td>
</tr>
</tbody>
</table>
</a></div><a id="N103BF" name="N103BF">

</a><div class="div3"><a id="N103BF" name="N103BF">
</a><h4><a id="N103BF" name="N103BF"></a><a id="N10428" name="N10428">3.5.2 Children</a></h4><a id="N10428" name="N10428">

</a><ul><a id="N10428" name="N10428">
</a><li><a id="N10428" name="N10428">The children of &lt;transition&gt; are executable content that
is run after all the &lt;onexit&gt; handlers and before the all
&lt;onentry&gt; handlers that are triggered by this transition. See
</a><a href="http://www.w3.org/TR/scxml/#executable"><em>4 Executable Content</em></a></li>
</ul>
</div>

<p>A conformant SCXML document <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> specify at least one of 'event', 'cond'
or 'target'. <a href="http://www.w3.org/TR/scxml/#SelectingTransitions"><em>3.13 Selecting and
Executing Transitions</em></a> contains more detail on the
semantics of transitions.</p>
</div>

<div class="div2">
<h3><a id="initial" name="initial">3.6 &lt;initial&gt;</a></h3><a id="initial" name="initial">

<p>[This section is normative.]</p>

<p>This element represents the default initial state for a complex
&lt;state&gt; element (i.e. one containing child &lt;state&gt; or
&lt;parallel&gt; elements.</p>

</a><div class="div3"><a id="initial" name="initial">
</a><h4><a id="initial" name="initial"></a><a id="N10442" name="N10442">3.6.1 Attribute Details</a></h4><a id="N10442" name="N10442">

<p>None</p>
</a></div><a id="N10442" name="N10442">

</a><div class="div3"><a id="N10442" name="N10442">
</a><h4><a id="N10442" name="N10442"></a><a id="N10447" name="N10447">3.6.2 Children</a></h4><a id="N10447" name="N10447">

</a><ul><a id="N10447" name="N10447">
</a><li><a id="N10447" name="N10447">&lt;transition&gt; A transition whose 'target' specifies the
default initial state(s). Occurs once. In a conformant SCXML
document, this transition <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em> contain 'cond' or 'event' attributes,
and <em title="MUST in RFC2119 context" class="RFC2119">MUST</em>
specify a non-null 'target' whose value is a valid state
specification consisting solely of descendants of the containing
state (see </a><a href="http://www.w3.org/TR/scxml/#LegalStateConfigurations"><em>3.11 Legal State
Configurations and Specifications</em></a> for details). This
transition <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> contain executable content.</li>
</ul>
</div>
</div>

<div class="div2">
<h3><a id="final" name="final">3.7 &lt;final&gt;</a></h3><a id="final" name="final">

<p>[This section is normative.]</p>

<p>&lt;final&gt; represents a final state of an &lt;scxml&gt; or
compound &lt;state&gt; element.</p>

</a><div class="div3"><a id="final" name="final">
</a><h4><a id="final" name="final"></a><a id="N10462" name="N10462">3.7.1 Attribute Details</a></h4><a id="N10462" name="N10462">

<table border="1" summary="attibute table">
<tbody>
<tr>
<th>Name</th>
<th>Required</th>
<th>Attribute Constraints</th>
<th>Type</th>
<th>Default Value</th>
<th>Valid Values</th>
<th>Description</th>
</tr>

<tr>
<td>id</td>
<td>false</td>
<td>
</td><td>ID</td>
<td>none</td>
<td>A valid id as defined in <a href="http://www.w3.org/TR/scxml/#Schema">[XML
Schema]</a></td>
<td>The identifier for this state. See <a href="http://www.w3.org/TR/scxml/#IDs"><em>3.14
IDs</em></a> for details.</td>
</tr>
</tbody>
</table>
</a></div><a id="N10462" name="N10462">

</a><div class="div3"><a id="N10462" name="N10462">
</a><h4><a id="N10462" name="N10462"></a><a id="N1048D" name="N1048D">3.7.2 Children</a></h4><a id="N1048D" name="N1048D">

</a><ul><a id="N1048D" name="N1048D">
</a><li><a id="N1048D" name="N1048D">&lt;onentry&gt; Optional element holding executable content to
be run upon entering this state. Occurs 0 or more times. See </a><a href="http://www.w3.org/TR/scxml/#onentry"><em>3.8 &lt;onentry&gt;</em></a> for details.</li>

<li>&lt;onexit&gt; Optional element holding executable content to
be run when exiting this state. Occurs 0 or more times. See <a href="http://www.w3.org/TR/scxml/#onexit"><em>3.9 &lt;onexit&gt;</em></a> for details.</li>

<li>&lt;donedata&gt; Optional element specifying data to be
included in the done.state.<em>id</em> or done.invoke.<em>id</em>
event. See <a href="http://www.w3.org/TR/scxml/#donedata"><em>5.5 &lt;donedata&gt;</em></a>
for details.</li>
</ul>
</div>

<p>When the state machine enters the &lt;final&gt; child of a
&lt;state&gt; element, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> generate
the event done.state.<em>id</em> after completion of the
&lt;onentry&gt; elements, where <em>id</em> is the id of the parent
state. Immediately thereafter, if the parent &lt;state&gt; is a
child of a &lt;parallel&gt; element, and all of the
&lt;parallel&gt;'s other children are also in final states, the
Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> generate the event done.state.<em>id</em>
where <em>id</em> is the id of the &lt;parallel&gt; element.</p>

<p>When the state machine reaches the &lt;final&gt; child of an
&lt;scxml&gt; element, it <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> terminate. See <a href="http://www.w3.org/TR/scxml/#AlgorithmforSCXMLInterpretation"><em>D Algorithm for SCXML
Interpretation</em></a> for details. If the SCXML session was
triggered as the result by an &lt;invoke&gt; element in another
session, the SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> generate the event
done.invoke.<em>id</em> after termination and return it to the
other session, where <em>id</em> is the unique identifier generated
when the &lt;invoke&gt; element was executed. See <a href="http://www.w3.org/TR/scxml/#invoke"><em>6.4 &lt;invoke&gt;</em></a> for details.</p>
</div>

<div class="div2">
<h3><a id="onentry" name="onentry">3.8 &lt;onentry&gt;</a></h3><a id="onentry" name="onentry">

<p>[This section is normative.]</p>

<p>A wrapper element containing executable content to be executed
when the state is entered.</p>

</a><div class="div3"><a id="onentry" name="onentry">
</a><h4><a id="onentry" name="onentry"></a><a id="N104D9" name="N104D9">3.8.1 Attribute Details</a></h4><a id="N104D9" name="N104D9">

<p>None.</p>
</a></div><a id="N104D9" name="N104D9">

</a><div class="div3"><a id="N104D9" name="N104D9">
</a><h4><a id="N104D9" name="N104D9"></a><a id="N104DE" name="N104DE">3.8.2 Children</a></h4><a id="N104DE" name="N104DE">

</a><p><a id="N104DE" name="N104DE">The children of the &lt;onentry&gt; handler consist of
executable content as defined in </a><a href="http://www.w3.org/TR/scxml/#executable"><em>4
Executable Content</em></a>.</p>
</div>

<p>The SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> execute the &lt;onentry&gt; handlers of a
state in document order when the state is entered. In doing so, it
<em title="MUST in RFC2119 context" class="RFC2119">MUST</em> treat
each handler as a separate block of executable content.</p>
</div>

<div class="div2">
<h3><a id="onexit" name="onexit">3.9 &lt;onexit&gt;</a></h3><a id="onexit" name="onexit">

<p>[This section is normative.]</p>

<p>A wrapper element containing executable content to be executed
when the state is exited.</p>

</a><div class="div3"><a id="onexit" name="onexit">
</a><h4><a id="onexit" name="onexit"></a><a id="N104F6" name="N104F6">3.9.1 Attribute Details</a></h4><a id="N104F6" name="N104F6">

<p>None.</p>
</a></div><a id="N104F6" name="N104F6">

</a><div class="div3"><a id="N104F6" name="N104F6">
</a><h4><a id="N104F6" name="N104F6"></a><a id="N104FB" name="N104FB">3.9.2 Children</a></h4><a id="N104FB" name="N104FB">

</a><p><a id="N104FB" name="N104FB">The children of the &lt;onexit&gt; handler consist of executable
content as defined in </a><a href="http://www.w3.org/TR/scxml/#executable"><em>4 Executable
Content</em></a>.</p>
</div>

<p>The SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> execute the &lt;onexit&gt; handlers of a
state in document order when the state is exited. In doing so, it
<em title="MUST in RFC2119 context" class="RFC2119">MUST</em> treat
each handler as a separate block of executable content.</p>
</div>

<div class="div2">
<h3><a id="history" name="history">3.10 &lt;history&gt;</a></h3><a id="history" name="history">

<p>The &lt;history&gt; pseudo-state allows a state machine to
remember its state configuration. A &lt;transition&gt; taking the
&lt;history&gt; state as its target will return the state machine
to this recorded configuration.</p>

</a><div class="div3"><a id="history" name="history">
</a><h4><a id="history" name="history"></a><a id="N10511" name="N10511">3.10.1 Attribute Details</a></h4><a id="N10511" name="N10511">

<table border="1" summary="attibute table">
<tbody>
<tr>
<th>Name</th>
<th>Required</th>
<th>Attribute Constraints</th>
<th>Type</th>
<th>Default Value</th>
<th>Valid Values</th>
<th>Description</th>
</tr>

<tr>
<td>id</td>
<td>false</td>
<td>
</td><td>ID</td>
<td>none</td>
<td>A valid id as defined in <a href="http://www.w3.org/TR/scxml/#Schema">[XML
Schema]</a></td>
<td>Identifier for this pseudo-state. See <a href="http://www.w3.org/TR/scxml/#IDs"><em>3.14
IDs</em></a> for details.</td>
</tr>

<tr>
<td>type</td>
<td>false</td>
<td>
</td><td>enum</td>
<td>"shallow"</td>
<td>"deep" or "shallow"</td>
<td>Determines whether the active atomic substate(s) of the current
state or only its immediate active substate(s) are recorded.</td>
</tr>
</tbody>
</table>
</a></div><a id="N10511" name="N10511">

</a><div class="div3"><a id="N10511" name="N10511">
</a><h4><a id="N10511" name="N10511"></a><a id="N1054A" name="N1054A">3.10.2 Children</a></h4><a id="N1054A" name="N1054A">

</a><ul><a id="N1054A" name="N1054A">
</a><li><a id="N1054A" name="N1054A">&lt;transition&gt; A transition whose 'target' specifies the
default history configuration. Occurs once. In a conformant SCXML
document, this transition <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em> contain 'cond' or 'event' attributes,
and <em title="MUST in RFC2119 context" class="RFC2119">MUST</em>
specify a non-null 'target' whose value is a valid state
specification (see </a><a href="http://www.w3.org/TR/scxml/#LegalStateConfigurations"><em>3.11
Legal State Configurations and Specifications</em></a>). This
transition <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> contain executable content. If 'type' is
"shallow", then the 'target' of this &lt;transition&gt; <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> contain
only immediate children of the parent state. Otherwise it <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> contain
only descendants of the parent. Occurs once. (Note that under the
definition of a legal state specification, if the parent of the
history element is &lt;state&gt; and the default state
specification contains a multiple states, then, in a conformant
SCXML document, the 'type' of the history element <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> be "deep"
and the states <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> be atomic descendants of a
&lt;parallel&gt; element that is itself a descendant of the parent
&lt;state&gt; element.)</li>
</ul>
</div>

<p>If the 'type' of a &lt;history&gt; element is "shallow", the
SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> record the immediately active children of
its parent before taking any transition that exits the parent. If
the 'type' of a &lt;history&gt; element is "deep", the SCXML
processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> record the active atomic descendants of
the parent before taking any transition that exits the parent.
After the parent state has been visited for the first time, for
each &lt;history&gt; element, we define the set of states that the
processor has recorded to be the 'stored state configuration' for
that history state. We also define the states specified by the
'target' of the &lt;history&gt; element's &lt;transition&gt; child
to be the 'default stored state configuration' for that element. If
a transition is executed that takes the &lt;history&gt; state as
its target, the behavior depends on whether the parent state has
been visited before. If it has, the SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> behave as
if the transition had taken the stored state configuration for that
history state as its target. If it has not, the SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> behave as
if the transition had taken the default stored state configuration
for that history state as its target. The Process <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> execute
any executable content in the transition after the parent state's
onentry handlers, and, in the case where the history pseudo-state
is the target of an &lt;initial&gt; transition, the executable
content inside the &lt;initial&gt; transition. (Note that in a
conformant SCXML document, a &lt;state&gt; or &lt;parallel&gt;
element <em title="MAY
 in RFC2119 context" class="RFC2119">MAY</em> have both "deep" and
"shallow" &lt;history&gt; children.)</p>
</div>

<div class="div2">
<h3><a id="LegalStateConfigurations" name="LegalStateConfigurations">3.11 Legal State Configurations
and Specifications</a></h3><a id="LegalStateConfigurations" name="LegalStateConfigurations">

<p>[This section is normative.]</p>

</a><p><a id="LegalStateConfigurations" name="LegalStateConfigurations">[</a><a title="" id="state-active" name="state-active">Definition</a>: A &lt;state&gt; or
&lt;parallel&gt; element is <em>active</em> if it has been entered
by a transition and has not subsequently been exited.]</p>

<p>[<a title="" id="state-configuration" name="state-configuration">Definition</a>: The <em>state
configuration</em> of a state machine is the set of currently
active states. ]</p>

<p>An SCXML document places the state machine in an initial state
configuration at initialization time (via the 'initial' attribute
of the &lt;scxml&gt; element). Each transition that the state
machine takes thereafter places the state machine in another state
configuration (which need not be distinct from the former one.) A
conformant SCXML document <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place the state machine only in legal
state configurations, where a legal state configuration is one that
meets the following conditions:</p>

<ul>
<li>The configuration contains exactly one child of the
&lt;scxml&gt; element.</li>

<li>The configuration contains one or more atomic states.</li>

<li>When the configuration contains an atomic state, it contains
all of its &lt;state&gt; and &lt;parallel&gt; ancestors.</li>

<li>When the configuration contains a non-atomic &lt;state&gt;, it
contains one and only one of the state's children.</li>

<li>If the configuration contains a &lt;parallel&gt; state, it
contains all of its children.</li>
</ul>

<p>It follows from this definition that if a state machine is in
more than one atomic state, the atomic states can be traced back
through a chain of &lt;state&gt; or &lt;parallel&gt; ancestors to a
single &lt;parallel&gt; ancestor.</p>

<p>The 'target' attribute of a &lt;transition&gt; (or the 'initial'
attribute of a &lt;state&gt; or &lt;scxml&gt; element) do not in
the general case specify a full legal state configuration since 1)
they can contain &lt;parallel&gt; or non-atomic &lt;state&gt;
elements 2) they do not contain the ancestors of the states in the
list. We therefore define a legal state specification to be a set
of states such that 1) no state is an ancestor of any other state
on the list, and 2) a full legal state configuration results when
all ancestors and default initial descendants have been added.
(Note that the process of adding default initial descendants is
recursive, since the 'initial' value may itself be non-atomic.) In
a conformant SCXML document, the value of an 'initial' attribute or
the 'target' of a &lt;transition&gt; <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> either be
empty or contain a legal state specification.</p>

<p>In a conformant SCXML document, there is an additional
requirement on the value of the 'initial' attribute of a
&lt;state&gt; and on the 'target' of a &lt;transition&gt; inside an
&lt;initial&gt; or &lt;history&gt; element: all the states <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> be
descendants of the containing &lt;state&gt; or &lt;parallel&gt;
element.</p>
</div>

<div class="div2">
<h3><a id="events" name="events">3.12 SCXML Events</a></h3><a id="events" name="events">

<p>[This section is normative.]</p>

<p>Events are one of the basic concepts in SCXML since they drive
most transitions. The internal structure of events is
platform-specific as long as the following external interface is
observed:</p>

</a><ul><a id="events" name="events">
</a><li><a id="events" name="events">The SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> make the data contained in an event
accessible via the '_event' variable, as specified in </a><a href="http://www.w3.org/TR/scxml/#SystemVariables"><em>5.10 System Variables</em></a>.</li>

<li>The SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> make the event's name accessible via the
'_event' variable, as specified in <a href="http://www.w3.org/TR/scxml/#SystemVariables"><em>5.10 System Variables</em></a>. The
SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> use this same name value to match against
the 'event' attribute of transitions.</li>
</ul>

<p>For the most part, the set of events raised during the execution
of an SCXML document is application-specific and generated under
author control by use of the &lt;raise&gt; and &lt;send&gt;
elements. However, certain events are mandatory and generated
automatically by the interpreter. These are described in <a href="http://www.w3.org/TR/scxml/#errorsAndEvents"><em>3.12.3 List of Errors and
Events</em></a>. Platforms <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> extend the names of these automatically
generated events by adding a suffix. For example, a platform could
extend done.state.<em>id</em> with a timestamp suffix and generate
done.state.<em>id.timestamp</em> instead. Because any prefix of
done.state.<em>id</em> is also a prefix of
done.state.<em>id.timestamp</em>, any transition that matches the
former event will also match the latter.</p>

<div class="div3">
<h4><a id="EventDescriptors" name="EventDescriptors">3.12.1 Event
Descriptors</a></h4><a id="EventDescriptors" name="EventDescriptors">

<p>Like an event name, an event descriptor is a series of
alphanumeric characters segmented into tokens by the "." character.
The 'event' attribute of a transition consists of one or more such
event descriptors separated by spaces.</p>

</a><p><a id="EventDescriptors" name="EventDescriptors">[</a><a title="" id="transition-match" name="transition-match">Definition</a>: A transition
<em>matches</em> an event if at least one of its event descriptors
matches the event's name. ]</p>

<p>[<a title="" id="event-match" name="event-match">Definition</a>:
An event descriptor <em>matches</em> an event name if its string of
tokens is an exact match or a prefix of the set of tokens in the
event's name. In all cases, the token matching is case sensitive.
]</p>

<p>For example, a transition with an 'event' attribute of "error
foo" will match event names "error", "error.send",
"error.send.failed", etc. (or "foo", "foo.bar" etc.) but would not
match events named "errors.my.custom",
"errorhandler.mistake","error.send" or "foobar".</p>

<p>For compatibility with CCXML, and to make the prefix matching
possibly more clear to a reader of the SCXML document, an event
descriptor <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> also end with the wildcard '.*', which
matches zero or more tokens at the end of the processed event's
name. Note that a transition with 'event' of "error", one with
"error.", and one with "error.*" are functionally equivalent since
they are token prefixes of exactly the same set of event names.</p>

<p>An event designator consisting solely of "*" can be used as a
wildcard matching any sequence of tokens, and thus any event. Note
that this is different from a transition lacking the 'event'
attribute altogether. Such an eventless transition does not match
any event, but will be taken whenever its 'cond' attribute
evaluates to 'true'. As shown in <a href="http://www.w3.org/TR/scxml/#AlgorithmforSCXMLInterpretation"><em>D Algorithm for SCXML
Interpretation</em></a>, the SCXML interpreter will check for such
eventless transitions when it first enters a state, before it looks
for transitions driven by internal or external events.</p>
</div>

<div class="div3">
<h4><a id="ErrorEvents" name="ErrorEvents">3.12.2 Errors</a></h4><a id="ErrorEvents" name="ErrorEvents">

<p>Once the SCXML processor has begun executing a well-formed SCXML
document, it <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> signal any errors that occur by raising
SCXML events whose names begin with 'error.'. the processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place
these events in the internal event queue and <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> process
them like any other event. (Note in particular, they are not
processed immediately if there are other events in the queue and
they are ignored if no transition is found that matches them.) Two
error events are defined in this specification:
'error.communication' and 'error.execution'. The former cover
errors occurring while trying to communicate with external
entities, such as those arising from &lt;send&gt; and
&lt;invoke&gt;, while the latter category consists of errors
internal to the execution of the document, such as those arising
from expression evaluation.</p>

</a><p><a id="ErrorEvents" name="ErrorEvents">The set of error events may be extended in future versions of
this specification. However, the set of names beginning with
'error.platform' is reserved for platform- and application-specific
errors. Therefore applications and platforms <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> extend the
set of errors defined in this specification in two ways. First by
adding a suffix to an error name defined in this specification, and
second by using 'error.platform' with or without a suffix. In
addition, platforms <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> include additional information about the
nature of the error in the 'data' field of the event. See </a><a href="http://www.w3.org/TR/scxml/#SystemVariables"><em>5.10 System Variables</em></a> for
details.</p>

<p>Note however that authors can arrange for otherwise unhandled
errors to cause the interpreter to exit by creating a transition
with "event" attribute of 'error' and a target of any top-level
final state (i.e. one that is a child of &lt;scxml&gt;). If such a
transition T is placed in a state S, it will cause the state
machine to terminate on any error that is raised in S or one of its
substates and is not handled by another transition that is placed
in a substate of S or in S and preceding T in document order.</p>
</div>

<div class="div3">
<h4><a id="errorsAndEvents" name="errorsAndEvents">3.12.3 List of
Errors and Events</a></h4><a id="errorsAndEvents" name="errorsAndEvents">

<p>The following events are generated automatically by the SCXML
implementation under conditions defined elsewhere in this
document.</p>

<table border="1" cellpadding="2" cellspacing="2" summary="errors and events" width="100%">
<tbody>
<tr>
<th align="center">Name</th>
<th align="center">Description</th>
<th align="center">Defined in</th>
<th align="center">See also</th>
</tr>

<tr>
<td align="center">done.state.<em>id</em></td>
<td>Indicates that the state machine has entered a final substate
of state <em>id</em>.</td>
<td><a href="http://www.w3.org/TR/scxml/#final"><em>3.7 &lt;final&gt;</em></a></td>
<td><a href="http://www.w3.org/TR/scxml/#CoreIntroduction"><em>3.1 Introduction</em></a></td>
</tr>

<tr>
<td align="center">done.invoke.<em>id</em></td>
<td>Indicates that the invoked process with invokeid <em>id</em>
has completed processing.</td>
<td><a href="http://www.w3.org/TR/scxml/#invoke"><em>6.4 &lt;invoke&gt;</em></a></td>
<td><a href="http://www.w3.org/TR/scxml/#final"><em>3.7 &lt;final&gt;</em></a>,
exitInterpreter procedure in <a href="http://www.w3.org/TR/scxml/#AlgorithmforSCXMLInterpretation"><em>D Algorithm for SCXML
Interpretation</em></a> </td>
</tr>

<tr>
<td align="center">error.communication</td>
<td>Indicates that an error has occurred while trying to
communicate with an external entity.</td>
<td><a href="http://www.w3.org/TR/scxml/#ErrorEvents"><em>3.12.2 Errors</em></a></td>
<td><a href="http://www.w3.org/TR/scxml/#send"><em>6.2 &lt;send&gt;</em></a>, <a href="http://www.w3.org/TR/scxml/#SCXMLEventProcessor"><em>C.1 SCXML Event I/O
Processor</em></a>, <a href="http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor"><em>C.2
Basic HTTP Event I/O Processor</em></a></td>
</tr>

<tr>
<td align="center">error.execution</td>
<td>Indicates that an error internal to the execution of the
document has occurred, such as one arising from expression
evaluation.</td>
<td><a href="http://www.w3.org/TR/scxml/#ErrorEvents"><em>3.12.2 Errors</em></a></td>
<td><a href="http://www.w3.org/TR/scxml/#foreach"><em>4.6 &lt;foreach&gt;</em></a>, <a href="http://www.w3.org/TR/scxml/#assign"><em>5.4 &lt;assign&gt;</em></a>, <a href="http://www.w3.org/TR/scxml/#param"><em>5.7 &lt;param&gt;</em></a>, <a href="http://www.w3.org/TR/scxml/#ConditionalExpressions"><em>5.9.1 Conditional
Expressions</em></a>, <a href="http://www.w3.org/TR/scxml/#LocationExpressions"><em>5.9.2
Location Expressions</em></a>, <a href="http://www.w3.org/TR/scxml/#ValueExpressions"><em>5.9.3 Legal Data Values and Value
Expressions</em></a>, <a href="http://www.w3.org/TR/scxml/#ErrorsinExpressions"><em>5.9.4
Errors in Expressions</em></a>, <a href="http://www.w3.org/TR/scxml/#SystemVariables"><em>5.10
System Variables</em></a>, <a href="http://www.w3.org/TR/scxml/#send"><em>6.2
&lt;send&gt;</em></a>, <a href="http://www.w3.org/TR/scxml/#ecma_location_expressions"><em>B.2.4 Location
Expressions</em></a>, <a href="http://www.w3.org/TR/scxml/#ecma_assign"><em>B.2.7
&lt;assign&gt;</em></a></td>
</tr>

<tr>
<td align="center">error.platform</td>
<td>Indicates that a platform- or application-specific error has
occurred.</td>
<td><a href="http://www.w3.org/TR/scxml/#ErrorEvents"><em>3.12.2 Errors</em></a></td>
<td></td></tr>
</tbody>
</table>
</a></div><a id="errorsAndEvents" name="errorsAndEvents">
</a></div><a id="errorsAndEvents" name="errorsAndEvents">

</a><div class="div2"><a id="errorsAndEvents" name="errorsAndEvents">
</a><h3><a id="errorsAndEvents" name="errorsAndEvents"></a><a id="SelectingTransitions" name="SelectingTransitions">3.13
Selecting and Executing Transitions</a></h3><a id="SelectingTransitions" name="SelectingTransitions">

<p>[This section is normative.]</p>

<p>To simplify the following definitions, we introduce the event
NULL. NULL has no name and is used only in these definitions. It
never occurs in the event queues of an SCXML Processor. All other
events have names and are distinct from NULL. (In effect, NULL is a
pseudo-event that is used in these definitions as a trigger for
eventless transitions.)</p>

</a><p><a id="SelectingTransitions" name="SelectingTransitions">[</a><a title="" id="transition-enabled" name="transition-enabled">Definition</a>: A transition T is
<em>enabled</em> by named event E in atomic state S if a) T's
source state is S or an ancestor of S,and b) T matches E's name
(see <a href="http://www.w3.org/TR/scxml/#EventDescriptors"><em>3.12.1 Event
Descriptors</em></a>) and c) T lacks a 'cond' attribute or its
'cond' attribute evaluates to "true". A transition is
<em>enabled</em> by NULL in atomic state S if a) T lacks an 'event'
attribute, and b) T's source state is S or an ancestor of S and c)
T lacks an 'cond' attribute or its 'cond' attribute evaluates to
"true". (Note that such a transition can never be enabled by any
named event.)]</p>

<p>[<a title="" id="source-state" name="source-state">Definition</a>: The <em>source state</em> of a
transition is the &lt;state&gt; or &lt;parallel&gt; element that it
occurs in. The <em>effective target state(s)</em> of the transition
is the state or set of states specified by its 'target' attribute,
with any history states being replaced by the corresponding stored
state configuration or default stored state configuration. The
<em>complete target set</em> of a transition consists of all the
states that will be active after the transition is taken. It
contains the effective target states of the transition plus all
their ancestors, expanded by the recursive application of the
following two operations: 1) if any &lt;parallel&gt; element is a
member of the set, any of its children that are not members of the
set must be added 2) if any compound &lt;state&gt; is in the set
and none of its children is in the set, its default initial
state(s) are added to the set. Any state whose child(ren) are added
to the complete target set by clause 2 is called a <em>default
entry state</em>. ]</p>

<p>[<a title="" id="exit-set" name="exit-set">Definition</a>: The
<em>exit set</em> of a transition in configuration C is the set of
states that are exited when the transition is taken when the state
machine is in C. If the transition does not contain a 'target', its
exit set is empty. Otherwise (i.e., if the transition contains a
'target'), if its 'type' is "external", its exit set consists of
all active states in C that are proper descendants of the <a href="http://www.w3.org/TR/scxml/#LCCA">Least Common Compound Ancestor (LCCA)</a> of the
source and target states. Otherwise, if the transition has 'type'
"internal", its source state is a compound state, and all its
target states are proper descendants of its source state, the exit
set consists of all active states in C that are proper descendants
of its source state. (If a transition has 'type' of "internal", but
its source state is not compound or its target states are not all
proper descendants of its source state, its exit set is defined as
if it had 'type' of "external". The exit set of a set of
transitions is the union of the exit sets of the individual
transitions. ]</p>

<p>[<a title="" id="entry-set" name="entry-set">Definition</a>: The
<em>entry set</em> of a transition in configuration C is the set of
states that are entered when the transition is taken. If a
transition does not contain a 'target', its entry set is empty.
Otherwise, it consists of all members of the transition's complete
target set that that are not currently active or are in the exit
set. (Thus the entry set consists of all members of the
transition's complete target set that will not be active once the
states in the exit set have been exited.) The entry set of a set of
transitions is the union of the entry sets of the individual
transitions.]</p>

<p>[<a title="" id="optimally-enabled" name="optimally-enabled">Definition</a>: A transition T is
<em>optimally enabled</em> by event E in atomic state S if a) T is
enabled by E in S and b) no transition that precedes T in document
order in T's source state is enabled by E in S and c) no transition
is enabled by E in S in any descendant of T's source state.]</p>

<p>[<a title="" id="transition-conflict" name="transition-conflict">Definition</a>: Two transitions T1 and
T2 <em>conflict</em> in state configuration C if their exit sets in
C have a non-null intersection.]</p>

<p>N.B. If two transitions conflict, then taking them both may lead
to an illegal configuration. Hence, only one of the transitions may
safely be taken. In order to resolve conflicts between transitions,
we assign priorities to transitions as follows: let transitions T1
and T2 conflict, where T1 is optimally enabled in atomic state S1,
and T2 is optimally enabled in atomic state S2, where S1 and S2 are
both active. We say that T1 has a higher priority than T2 if a)
T1's source state is a descendant of T2's source state, or b) S1
precedes S2 in document order.</p>

<p>[<a title="" id="optimal-transition-set" name="optimal-transition-set">Definition</a>: The <em>optimal
transition set</em> enabled by event E in state configuration C is
the largest set of transitions such that a) each transition in the
set is optimally enabled by E in an atomic state in C b) no
transition conflicts with another transition in the set c) there is
no optimally enabled transition outside the set that has a higher
priority than some member of the set. ]</p>

<p>[<a title="" id="microstep" name="microstep">Definition</a>: A
<em>microstep</em> consists of the execution of the transitions in
an optimal enabled transition set.]</p>

<p>[<a title="" id="macrostep" name="macrostep">Definition</a>: A
<em>macrostep</em> is a series of one or more microsteps ending in
a configuration where the internal event queue is empty and no
transitions are enabled by NULL. ]</p>

<p>To execute a microstep, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> execute
the transitions in the corresponding optimal enabled transition
set. To execute a set of transitions, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> first
exit all the states in the transitions' exit set in <a href="http://www.w3.org/TR/scxml/#exitOrder">exit order</a>. It <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> then
execute the executable content contained in the transitions in
document order. It <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> then enter the states in the transitions'
entry set in <a href="http://www.w3.org/TR/scxml/#entryOrder">entry order</a>.</p>

<p>To exit a state, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> execute
the executable content in the state's &lt;onexit&gt; handler. Then
it <em title="MUST in RFC2119 context" class="RFC2119">MUST</em>
cancel any ongoing invocations that were triggered by that state.
Finally, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> remove the state from the active state's
list.</p>

<p>To enter a state, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> add the
state to the active state's list. Then it <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> execute
the executable content in the state's &lt;onentry&gt; handler. If
the state is a default entry state and has an &lt;initial&gt;
child, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> then execute the executable content in
the &lt;initial&gt; child's &lt;transition&gt;.</p>

<p>At startup, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place the
state machine in the configuration specified by the 'initial'
attribute of the &lt;scxml&gt; element.</p>

<p>After entering the initial configuration, and after executing
each microstep, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> check the
state configuration for &lt;final&gt; states that it has entered
during the microstep. If it has entered a &lt;final&gt; state that
is a child of &lt;scxml&gt;, it <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> halt processing. If it has entered a
&lt;final&gt; state that is a child of a compound state, it <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> generate
the event done.state.<em>id</em>, where <em>id</em> is the id of
the compound state. If the compound state is itself the child of a
&lt;parallel&gt; element, and all the &lt;parallel&gt; element's
other children are in final states, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> generate
the event done.state.<em>id</em>, where <em>id</em> is the id of
the &lt;parallel&gt; elements.</p>

<p>After checking the state configuration, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> select
the optimal transition set enabled by NULL in the current
configuration. If the set is not empty, it <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> execute
it as a microstep. If the set is empty, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> remove
events from the internal event queue until the queue is empty or it
finds an event that enables a non-empty optimal transition set in
the current configuration. If it finds such a set, the processor
<em title="MUST in RFC2119 context" class="RFC2119">MUST</em> then
execute it as a microstep. (Otherwise the internal event queue is
empty and the Processor has completed a macrostep.)</p>

<p>After completing a macrostep, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> execute
in document order the &lt;invoke&gt; handlers in all states that
have been entered since the completion of the last macrostep. Then
the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> remove events from the external event
queue, waiting till events appear if necessary, until it finds one
that enables a non-empty optimal transition set in the current
configuration. The Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> then execute that set as a microstep.</p>
</div>

<div class="div2">
<h3><a id="IDs" name="IDs">3.14 IDs</a></h3><a id="IDs" name="IDs">

<p>[This section is normative.]</p>

</a><p><a id="IDs" name="IDs">In a conformant SCXML document, the values of all attributes of
type "id" <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> be unique within the session. When such
an attribute is defined to be optional and the author omits it,
then, for elements other than &lt;send&gt; and &lt;invoke&gt;, the
SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> generate a unique id automatically at
document load time. (Note that Such system generated IDs cannot
normally be referenced elsewhere in the document because they are
not known to the author. In particular, a state with a system
generated ID cannot be the target of a transition.) The ids for
&lt;send&gt; and &lt;invoke&gt; are subtly different. In a
conformant SCXML document, they <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> be unique within the session, but in the
case where the author does not provide them, the processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> generate
a new unique ID not at load time but <em>each time the element is
executed</em>. Furthermore the attribute 'idlocation' can be used
to capture this automatically generated id. Finally note that the
automatically generated id for &lt;invoke&gt; has a special format.
See </a><a href="http://www.w3.org/TR/scxml/#invokeattrs"><em>6.4.1 Attribute Details</em></a> for
details. The SCXML processor <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> generate all other ids in any format, as
long as they are unique.</p>
</div>
</div>

<div class="div1">
<h2><a id="executable" name="executable">4 Executable
Content</a></h2><a id="executable" name="executable">

</a><div class="div2"><a id="executable" name="executable">
</a><h3><a id="executable" name="executable"></a><a id="ExecutableIntroduction" name="ExecutableIntroduction">4.1 Introduction</a></h3><a id="ExecutableIntroduction" name="ExecutableIntroduction">

<p>[This section is informative.]</p>

<p>Executable content allows the state machine to <em>do</em>
things. It provides the hooks that allow an SCXML session to modify
its data model and interact with external entities. Executable
content consists of actions that are performed as part of taking
transitions. In particular, executable content occurs inside
&lt;onentry&gt; and &lt;onexit&gt; elements as well as inside
transitions. When the state machine takes a transition, it executes
the &lt;onexit&gt; executable content in the states it is leaving,
followed by the content in the transition, followed by the
&lt;onentry&gt; content in the states it is entering.</p>

</a><p><a id="ExecutableIntroduction" name="ExecutableIntroduction">This standard defines elements of executable content which can
raise events</a><a href="http://www.w3.org/TR/scxml/#raise"><em>4.2 &lt;raise&gt;</em></a>,
communicate with external entities <a href="http://www.w3.org/TR/scxml/#send"><em>6.2
&lt;send&gt;</em></a>, log information <a href="http://www.w3.org/TR/scxml/#log"><em>4.7
&lt;log&gt;</em></a> execute scripts <a href="http://www.w3.org/TR/scxml/#script"><em>5.8
&lt;script&gt;</em></a> and modify the data model <a href="http://www.w3.org/TR/scxml/#assign"><em>5.4 &lt;assign&gt;</em></a>, as well as control
constructs to conditionalize execution <a href="http://www.w3.org/TR/scxml/#if"><em>4.3
&lt;if&gt;</em></a> and to iterate over the items in a collection
<a href="http://www.w3.org/TR/scxml/#foreach"><em>4.6 &lt;foreach&gt;</em></a>. In addition,
SCXML implementations are allowed to define their own,
platform-specific executable content (see <a href="http://www.w3.org/TR/scxml/#extensibility"><em>4.10 Extensibility of Executable
Content</em></a>).</p>
</div>

<div class="div2">
<h3><a id="raise" name="raise">4.2 &lt;raise&gt;</a></h3><a id="raise" name="raise">

<p>[This section is normative.]</p>

<p>The &lt;raise&gt; element raises an event in the current SCXML
session. Note that the event will not be processed until the
current block of executable content has completed and all events
that are already in the internal event queue have been processed.
For example, suppose the &lt;raise&gt; element occurs first in the
&lt;onentry&gt; handler of state S followed by executable content
elements ec1 and ec2. If event e1 is already in the internal event
queue when S is entered, the event generated by &lt;raise&gt; will
not be processed until ec1 and ec2 have finished execution and e1
has been processed.</p>

</a><div class="div3"><a id="raise" name="raise">
</a><h4><a id="raise" name="raise"></a><a id="N107C2" name="N107C2">4.2.1 Attribute Details</a></h4><a id="N107C2" name="N107C2">

<table border="1" summary="attibute table">
<tbody>
<tr>
<th>Name</th>
<th>Required</th>
<th>Attribute Constraints</th>
<th>Type</th>
<th>Default Value</th>
<th>Valid Values</th>
<th>Description</th>
</tr>

<tr>
<td>event</td>
<td>true</td>
<td>
</td><td>NMTOKEN</td>
<td>none</td>
<td></td>
<td>Specifies the name of the event. This will be matched against
the 'event' attribute of transitions.</td>
</tr>
</tbody>
</table>
</a></div><a id="N107C2" name="N107C2">

</a><div class="div3"><a id="N107C2" name="N107C2">
</a><h4><a id="N107C2" name="N107C2"></a><a id="N107E8" name="N107E8">4.2.2 Children</a></h4><a id="N107E8" name="N107E8">

None.</a></div><a id="N107E8" name="N107E8">

<p>The SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place the event that is generated at the
rear of the session's internal event queue.</p>
</a></div><a id="N107E8" name="N107E8">

</a><div class="div2"><a id="N107E8" name="N107E8">
</a><h3><a id="N107E8" name="N107E8"></a><a id="if" name="if">4.3 &lt;if&gt;</a></h3><a id="if" name="if">

<p>[This section is normative.]</p>

<p>&lt;if&gt; is a container for conditionally executed
elements.</p>

</a><div class="div3"><a id="if" name="if">
</a><h4><a id="if" name="if"></a><a id="N107F9" name="N107F9">4.3.1 Attribute Details</a></h4><a id="N107F9" name="N107F9">

<table border="1" summary="attibute table">
<tbody>
<tr>
<th>Name</th>
<th>Required</th>
<th>Attribute Constraints</th>
<th>Type</th>
<th>Default Value</th>
<th>Valid Values</th>
<th>Description</th>
</tr>

<tr>
<td>cond</td>
<td>true</td>
<td>
</td><td>Conditional expression</td>
<td>none</td>
<td>A valid conditional expression</td>
<td>A boolean expression. See <a href="http://www.w3.org/TR/scxml/#ConditionalExpressions"><em>5.9.1 Conditional
Expressions</em></a> for details.</td>
</tr>
</tbody>
</table>
</a></div><a id="N107F9" name="N107F9">

</a><div class="div3"><a id="N107F9" name="N107F9">
</a><h4><a id="N107F9" name="N107F9"></a><a id="N10822" name="N10822">4.3.2 Children</a></h4><a id="N10822" name="N10822">

</a><ul><a id="N10822" name="N10822">
</a><li><a id="N10822" name="N10822">&lt;elseif&gt; Occurs 0 or more times. See </a><a href="http://www.w3.org/TR/scxml/#elseif"><em>4.4 &lt;elseif&gt;</em></a></li>

<li>&lt;else&gt; Occurs 0 or 1 times. See <a href="http://www.w3.org/TR/scxml/#else"><em>4.5
&lt;else&gt;</em></a></li>

<li>The other children of &lt;if&gt; consist of executable content.
Note that since &lt;if&gt; itself is executable content, nested
&lt;if&gt; statements are allowed.</li>
</ul>
</div>

<p>The behavior of &lt;if&gt; is defined in terms of partitions of
executable content. The first partition consists of the executable
content between the &lt;if&gt; and the first &lt;elseif&gt;,
&lt;else&gt; or &lt;/if&gt; tag. Each &lt;elseif&gt; tag defines a
partition that extends from it to the next &lt;elseif&gt;,
&lt;else&gt; or &lt;/if&gt; tag. The &lt;else&gt; tag defines a
partition that extends from it to the closing &lt;/if&gt; tag. In a
conformant SCXML document, a partition <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> be empty.
In a conformant SCXML document, &lt;else&gt; <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> occur
after all &lt;elseif&gt; tags.</p>

<p>When the &lt;if&gt; element is executed, the SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> execute
the first partition in document order that is defined by a tag
whose 'cond' attribute evaluates to true, if there is one.
Otherwise, it <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> execute the partition defined by the
&lt;else&gt; tag, if there is one. Otherwise it <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em>
execute any of the executable content.</p>

<p>Here is an example:</p>

<div class="exampleInner">
<pre>&lt;if cond="cond1"&gt;
  &lt;!-- selected when "cond1" is true --&gt;
&lt;elseif cond="cond2"/&gt;
  &lt;!-- selected when "cond1" is false and "cond2" is true --&gt;
&lt;elseif cond="cond3"/&gt;
  &lt;!-- selected when "cond1" and "cond2" are false and "cond3" is true --&gt;
&lt;else/&gt;
  &lt;!-- selected when "cond1", "cond2", and "cond3" are false --&gt;
&lt;/if&gt;
           
</pre>
</div>
</div>

<div class="div2">
<h3><a id="elseif" name="elseif">4.4 &lt;elseif&gt;</a></h3><a id="elseif" name="elseif">

<p>[This section is normative.]</p>

</a><div class="div3"><a id="elseif" name="elseif">
</a><h4><a id="elseif" name="elseif"></a><a id="N10851" name="N10851">4.4.1 Overview</a></h4><a id="N10851" name="N10851">

<p>&lt;elseif&gt; is an empty element that partitions the content
of an &lt;if&gt;, and provides a condition that determines whether
the partition is executed.</p>
</a></div><a id="N10851" name="N10851">

<div class="div3"></div>

</a><div class="div2"><a id="N10851" name="N10851">
</a><h3><a id="N10851" name="N10851"></a><a id="else" name="else">4.5 &lt;else&gt;</a></h3><a id="else" name="else">

<p>[This section is normative.]</p>

</a><div class="div3"><a id="else" name="else">
</a><h4><a id="else" name="else"></a><a id="N1085D" name="N1085D">4.5.1 Overview</a></h4><a id="N1085D" name="N1085D">

<p>&lt;else&gt; is an empty element that partitions the content of
an &lt;if&gt;. It is equivalent to an &lt;elseif&gt; with a "cond"
that always evaluates to true.</p>
</a></div><a id="N1085D" name="N1085D">

</a><div class="div3"><a id="N1085D" name="N1085D">
</a><h4><a id="N1085D" name="N1085D"></a><a id="N10862" name="N10862">4.5.2 Attribute Details</a></h4><a id="N10862" name="N10862">

<p>None.</p>
</a></div><a id="N10862" name="N10862">
</a></div><a id="N10862" name="N10862">

</a><div class="div2"><a id="N10862" name="N10862">
</a><h3><a id="N10862" name="N10862"></a><a id="foreach" name="foreach">4.6 &lt;foreach&gt;</a></h3><a id="foreach" name="foreach">

</a><div class="div3"><a id="foreach" name="foreach">
<p>[This section is normative.]</p>

</a><h4><a id="foreach" name="foreach"></a><a id="N1086B" name="N1086B">4.6.1 Overview</a></h4><a id="N1086B" name="N1086B">

<p>The &lt;foreach&gt; element allows an SCXML application to
iterate through a collection in the data model and to execute the
actions contained within it for each item in the collection.</p>
</a></div><a id="N1086B" name="N1086B">

</a><div class="div3"><a id="N1086B" name="N1086B">
</a><h4><a id="N1086B" name="N1086B"></a><a id="N10872" name="N10872">4.6.2 Attribute Details</a></h4><a id="N10872" name="N10872">

<table border="1" summary="attibute table">
<tbody>
<tr>
<th>Name</th>
<th>Required</th>
<th>Attribute Constraints</th>
<th>Type</th>
<th>Default Value</th>
<th>Valid Values</th>
<th>Description</th>
</tr>

<tr>
<td>array</td>
<td>true</td>
<td>
</td><td>Value expression</td>
<td>none</td>
<td>A value expression that evaluates to an iterable
collection.</td>
<td>The &lt;foreach&gt; element will iterate over a shallow copy of
this collection.</td>
</tr>

<tr>
<td>item</td>
<td>true</td>
<td>
</td><td>xsd:string</td>
<td>none</td>
<td>Any variable name that is valid in the specified data
model.</td>
<td>A variable that stores a different item of the collection in
each iteration of the loop.</td>
</tr>

<tr>
<td>index</td>
<td>false</td>
<td>
</td><td>xsd:string</td>
<td>none</td>
<td>Any variable name that is valid in the specified data
model.</td>
<td>A variable that stores the current iteration index upon each
iteration of the foreach loop.</td>
</tr>
</tbody>
</table>
</a></div><a id="N10872" name="N10872">

</a><div class="div3"><a id="N10872" name="N10872">
</a><h4><a id="N10872" name="N10872"></a><a id="N108B4" name="N108B4">4.6.3 Children</a></h4><a id="N108B4" name="N108B4">

<p>The children of &lt;foreach&gt; consist of one or more items of
executable content. (Note that they are considered to be part of
the same block of executable content as the parent &lt;foreach&gt;
element.)</p>
</a></div><a id="N108B4" name="N108B4">

<p>The SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> declare a new variable if the one
specified by 'item' is not already defined. If 'index' is present,
the SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> declare a new variable if the one
specified by 'index' is not already defined. If 'array' does not
evaluate to a legal iterable collection, or if 'item' does not
specify a legal variable name, the SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> terminate
execution of the &lt;foreach&gt; element and the block that
contains it, and place the error error.execution on the internal
event queue.</p>

<p>The SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> act as if it has made a shallow copy of
the collection produced by the evaluation of 'array'. Specifically,
modifications to the collection during the execution of
&lt;foreach&gt; <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em> affect the iteration behavior. The
SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> start with the first item in the
collection and proceed to the last item in the iteration order that
is defined for the collection. (This order depends on the data
model in use. ) For each item in turn, the processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> assign it
to the item variable. (Note that the assigned value <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> be null or
undefined if the collection contains a null or undefined item.)
After making the assignment, the SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> evaluate
its child executable content. It <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> then
proceed to the next item in iteration order. If the evaluation of
any child element causes an error, the processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> cease
execution of the &lt;foreach&gt; element and the block that
contains it. (Note that SCXML does not provide break functionality
to interrupt &lt;foreach&gt;, however targetless and/or eventless
transitions can provide sophisticated iterative behavior within the
SCXML application itself.)</p>
</a></div><a id="N108B4" name="N108B4">

</a><div class="div2"><a id="N108B4" name="N108B4">
</a><h3><a id="N108B4" name="N108B4"></a><a id="log" name="log">4.7 &lt;log&gt;</a></h3><a id="log" name="log">

<p>[This section is normative.]</p>

</a><div class="div3"><a id="log" name="log">
</a><h4><a id="log" name="log"></a><a id="N108E4" name="N108E4">4.7.1 Overview</a></h4><a id="N108E4" name="N108E4">

<p>&lt;log&gt; allows an application to generate a logging or debug
message.</p>
</a></div><a id="N108E4" name="N108E4">

</a><div class="div3"><a id="N108E4" name="N108E4">
</a><h4><a id="N108E4" name="N108E4"></a><a id="N108E9" name="N108E9">4.7.2 Attribute Details</a></h4><a id="N108E9" name="N108E9">

<table border="1" summary="attibute table">
<tbody>
<tr>
<th>Name</th>
<th>Required</th>
<th>Attribute Constraints</th>
<th>Type</th>
<th>Default Value</th>
<th>Valid Values</th>
<th>Description</th>
</tr>

<tr>
<td>label</td>
<td>false</td>
<td>
</td><td>string</td>
<td>empty string</td>
<td>
</td><td>A character string with an implementation-dependent
interpretation. It is intended to provide meta-data about the log
string specified by 'expr'.</td>
</tr>

<tr>
<td>expr</td>
<td>false</td>
<td>
</td><td>Value expression</td>
<td>none</td>
<td>
</td><td>An expression returning the value to be logged. See <a href="http://www.w3.org/TR/scxml/#ValueExpressions"><em>5.9.3 Legal Data Values and Value
Expressions</em></a> for details. The nature of the logging
mechanism is implementation-dependent. For example, the SCXML
processor may convert this value to a convenient format before
logging it.</td>
</tr>
</tbody>
</table>
</a></div><a id="N108E9" name="N108E9">

</a><div class="div3"><a id="N108E9" name="N108E9">
</a><h4><a id="N108E9" name="N108E9"></a><a id="N1091E" name="N1091E">4.7.3 Children</a></h4><a id="N1091E" name="N1091E">

<p>None.</p>
</a></div><a id="N1091E" name="N1091E">

<p>The manner in which the message is displayed or logged is
platform-dependent. The SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> ensure
that &lt;log&gt; has no side-effects on document
interpretation.</p>
</a></div><a id="N1091E" name="N1091E">

</a><div class="div2"><a id="N1091E" name="N1091E">
</a><h3><a id="N1091E" name="N1091E"></a><a id="profile-dependentexecutablecontent" name="profile-dependentexecutablecontent">4.8 Other Executable
Content</a></h3><a id="profile-dependentexecutablecontent" name="profile-dependentexecutablecontent">

<p>[This section is normative.]</p>

<p>The following elements of executable content are defined
elsewhere in this specification. They <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> occur
wherever executable content is allowed and <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em>
occur anyplace else.</p>

</a><ul><a id="profile-dependentexecutablecontent" name="profile-dependentexecutablecontent">
</a><li><a id="profile-dependentexecutablecontent" name="profile-dependentexecutablecontent">&lt;assign&gt;. Changes the value of a location in the data
model. See </a><a href="http://www.w3.org/TR/scxml/#assign"><em>5.4 &lt;assign&gt;</em></a> for
details.</li>

<li>&lt;script&gt;. Provides scripting capabilities. See <a href="http://www.w3.org/TR/scxml/#script"><em>5.8 &lt;script&gt;</em></a> for details.</li>

<li>&lt;send&gt;. Sends an event to a specified destination. See <a href="http://www.w3.org/TR/scxml/#send"><em>6.2 &lt;send&gt;</em></a> for details.</li>

<li>&lt;cancel&gt;. Cancels an event that was to be sent See <a href="http://www.w3.org/TR/scxml/#cancel"><em>6.3 &lt;cancel&gt;</em></a> for details.</li>
</ul>
</div>

<div class="div2">
<h3><a id="EvaluationofExecutableContent" name="EvaluationofExecutableContent">4.9 Evaluation of Executable
Content</a></h3><a id="EvaluationofExecutableContent" name="EvaluationofExecutableContent">

<p>[This section is normative.]</p>

<p>Wherever executable content is permitted, an arbitrary number of
elements <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> occur. Such a sequence of elements of
executable content is called a block. For example, if transition t
takes the state machine from atomic state S1 to atomic state S2,
there are three blocks of executable content executed: the one in
the &lt;onexit&gt; handler of S1, the one inside t, and the one
inside the &lt;onentry&gt; handler of S2. The SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> execute
the elements of a block in document order. If the processing of an
element causes an error to be raised, the processor <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em>
process the remaining elements of the block. (The execution of
other blocks of executable content is not affected.)</p>

</a><p><a id="EvaluationofExecutableContent" name="EvaluationofExecutableContent">Events raised during the processing of executable content are
treated like any other events. Note in particular, that error
events will not be removed from the queue and processed until all
events preceding them in the queue have been processed. See </a><a href="http://www.w3.org/TR/scxml/#ErrorEvents"><em>3.12.2 Errors</em></a>. for details.</p>
</div>

<div class="div2">
<h3><a id="extensibility" name="extensibility">4.10 Extensibility
of Executable Content</a></h3><a id="extensibility" name="extensibility">

<p>[This section is normative.]</p>

<p>Implementations <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> provide additional executable content
corresponding to special features of their implementations. The
functionality of such platform-specific content is not restricted,
except that it <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em> cause transitions or any form of
change of state (except indirectly, by raising events that trigger
transitions). Note that SCXML treats the executable content
triggered by a transition as a single blocking operation and that
no events are processed until all the executable content has
completed. For example, when taking a transition into state S, the
SCXML processor will not process any events or take any transitions
until all &lt;onentry&gt; handlers in S have finished. It is thus
important that all executable content, including platform-specific
extensions, execute swiftly.</p>

</a><p><a id="extensibility" name="extensibility">In a conformant SCXML document any extensions to executable
content <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em> be defined the 'scxml' namespace.
(Note that the schema </a><a href="http://www.w3.org/TR/scxml/#schemas"><em>E Schema</em></a>
allows elements from arbitrary namespaces inside blocks of
executable content.) The following example shows the incorporation
of CCXML functionality (see <a href="http://www.w3.org/TR/scxml/#CCXML">[CCXML 1.0]</a>) into
SCXML. In particular an &lt;accept&gt; element in the 'ccxml'
namespace is invoked as executable content inside a transition.</p>

<div class="exampleInner">
<pre>&lt;transition event="ccxml:connection.alerting"&gt;
  &lt;ccxml:accept connectionid="_event.data.connectionid"/&gt;
&lt;/transition&gt;
</pre>
</div>

<p>This markup is legal on any SCXML interpreter, but the behavior
of &lt;accept&gt; element is platform-dependent. See <a href="http://www.w3.org/TR/scxml/#ConformingProcessors"><em>A.2 Conforming Processors</em></a>
for details.</p>

<p>A general method for implementing extensions using the
&lt;send&gt; element is presented in <a href="http://www.w3.org/TR/scxml/#custom_action"><em>G.7 Custom Action Elements</em></a>.</p>
</div>
</div>

<div class="div1">
<h2><a id="data-module" name="data-module">5 Data Model and Data
Manipulation</a></h2><a id="data-module" name="data-module">

</a><div class="div2"><a id="data-module" name="data-module">
</a><h3><a id="data-module" name="data-module"></a><a id="DataModelIntroduction" name="DataModelIntroduction">5.1 Introduction</a></h3><a id="DataModelIntroduction" name="DataModelIntroduction">

<p>[This section is informative.]</p>

</a><p><a id="DataModelIntroduction" name="DataModelIntroduction">The Data Model offers the capability of storing, reading, and
modifying a set of data that is internal to the state machine. This
specification does not mandate any specific data model, but instead
defines a set of abstract capabilities that can be realized by
various languages, such as ECMAScript or XML/XPath. Implementations
may choose the set of data models that they support. In addition to
the underlying data structure, the data model defines a set of
expressions as described in </a><a href="http://www.w3.org/TR/scxml/#Expressions"><em>5.9
Expressions</em></a>. These expressions are used to refer to
specific locations in the data model, to compute values to assign
to those locations, and to evaluate boolean conditions. Finally,
the data model includes a set of system variables, as defined in <a href="http://www.w3.org/TR/scxml/#SystemVariables"><em>5.10 System Variables</em></a>, which
are automatically maintained by the SCXML processor.</p>

<p>The data model is defined via the <a href="http://www.w3.org/TR/scxml/#datamodel"><em>5.2
&lt;datamodel&gt;</em></a> element, which contains zero or more <a href="http://www.w3.org/TR/scxml/#data"><em>5.3 &lt;data&gt;</em></a> elements, each of which
defines a single data element and assigns an initial value to it.
These values may be specified in-line or loaded from an external
source. They can then be updated via the <a href="http://www.w3.org/TR/scxml/#assign"><em>5.4
&lt;assign&gt;</em></a> element. The <a href="http://www.w3.org/TR/scxml/#donedata"><em>5.5
&lt;donedata&gt;</em></a>, <a href="http://www.w3.org/TR/scxml/#content"><em>5.6
&lt;content&gt;</em></a> , and <a href="http://www.w3.org/TR/scxml/#param"><em>5.7
&lt;param&gt;</em></a> elements can be used to incorporate data
into communications with external entities. Finally, the <a href="http://www.w3.org/TR/scxml/#script"><em>5.8 &lt;script&gt;</em></a> element permits the
incorporation of a scripting language.</p>

<p>The interpretation of these elements depends on the data model
in question, and not all elements are supported in all data models.
For the details of specific data models, see <a href="http://www.w3.org/TR/scxml/#profiles"><em>B Data Models</em></a>.</p>
</div>

<div class="div2">
<h3><a id="datamodel" name="datamodel">5.2 &lt;datamodel&gt;</a></h3><a id="datamodel" name="datamodel">

<p>[This section is normative.]</p>

<p>&lt;datamodel&gt; is a wrapper element which encapsulates any
number of &lt;data&gt; elements, each of which defines a single
data object. The exact nature of the data object depends on the
data model language used.</p>

</a><div class="div3"><a id="datamodel" name="datamodel">
</a><h4><a id="datamodel" name="datamodel"></a><a id="N109C2" name="N109C2">5.2.1 Attribute Details</a></h4><a id="N109C2" name="N109C2">

<p>None.</p>
</a></div><a id="N109C2" name="N109C2">

</a><div class="div3"><a id="N109C2" name="N109C2">
</a><h4><a id="N109C2" name="N109C2"></a><a id="N109C7" name="N109C7">5.2.2 Children</a></h4><a id="N109C7" name="N109C7">

<ul>
<li>&lt;data&gt; Occurs 0 or more times. Each instance defines a
named data element.</li>
</ul>
</a></div><a id="N109C7" name="N109C7">
</a></div><a id="N109C7" name="N109C7">

</a><div class="div2"><a id="N109C7" name="N109C7">
</a><h3><a id="N109C7" name="N109C7"></a><a id="data" name="data">5.3 &lt;data&gt;</a></h3><a id="data" name="data">

<p>[This section is normative.]</p>

<p>The &lt;data&gt; element is used to declare and populate
portions of the data model.</p>

</a><div class="div3"><a id="data" name="data">
</a><h4><a id="data" name="data"></a><a id="N109D6" name="N109D6">5.3.1 Attribute Details</a></h4><a id="N109D6" name="N109D6">

<table border="1" summary="attibute table">
<tbody>
<tr>
<th>Name</th>
<th>Required</th>
<th>Attribute Constraints</th>
<th>Type</th>
<th>Default Value</th>
<th>Valid Values</th>
<th>Description</th>
</tr>

<tr>
<td>id</td>
<td>true</td>
<td>
</td><td>ID</td>
<td>none</td>
<td></td>
<td>The name of the data item. See <a href="http://www.w3.org/TR/scxml/#IDs"><em>3.14
IDs</em></a> for details.</td>
</tr>

<tr>
<td>src</td>
<td>false</td>
<td>
</td><td>URI</td>
<td>none</td>
<td>
</td><td>Gives the location from which the data object should be
fetched. See <a href="http://www.w3.org/TR/scxml/#ValueExpressions"><em>5.9.3 Legal Data
Values and Value Expressions</em></a> for details.</td>
</tr>

<tr>
<td>expr</td>
<td>false</td>
<td>
</td><td>Expression</td>
<td>none</td>
<td>Any valid value expression</td>
<td>Evaluates to provide the value of the data item. See <a href="http://www.w3.org/TR/scxml/#ValueExpressions"><em>5.9.3 Legal Data Values and Value
Expressions</em></a> for details.</td>
</tr>
</tbody>
</table>
</a></div><a id="N109D6" name="N109D6">

</a><div class="div3"><a id="N109D6" name="N109D6">
</a><h4><a id="N109D6" name="N109D6"></a><a id="N10A20" name="N10A20">5.3.2 Children</a></h4><a id="N10A20" name="N10A20">

<p>The children of the &lt;data&gt; element represent an in-line
specification of the value of the data object.</p>

<p>In a conformant SCXML document, a &lt;data&gt; element <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> have either
a 'src' or an 'expr' attribute, but <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em>
have both. Furthermore, if either attribute is present, the element
<em title="MUST NOT in RFC2119 context" class="RFC2119">MUST
NOT</em> have any children. Thus 'src', 'expr' and children are
mutually exclusive in the &lt;data&gt; element.</p>

<p>The SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> use any values provided by the
environment at instantiation time in place of those contained in
the top-level &lt;data&gt; elements. (Top-level data elements are
those that are children of the &lt;datamodel &gt; element that is a
child of &lt;scxml&gt;). The manner in which the environment
specifies these overriding values is platform-dependent.</p>

</a><p><a id="N10A20" name="N10A20">If the 'expr' attribute is present, the Platform <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> evaluate
the corresponding expression at the time specified by the 'binding'
attribute of &lt;scxml&gt; and <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> assign the resulting value as the value
of the data element. If the 'src' attribute is present, the
Platform <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> fetch the specified object at the time
specified by the 'binding' attribute of &lt;scxml&gt; and <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> assign it
as the value of the data element. If child content is specified,
the Platform <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> assign it as the value of the data
element at the time specified by the 'binding' attribute of
&lt;scxml&gt;. Note that in the latter two cases, the
interpretation of the object or content will depend on the data
model. See </a><a href="http://www.w3.org/TR/scxml/#profiles"><em>B Data Models</em></a> for
details. If the value specified for a &lt;data&gt; element (by
'src', children, or the environment) is not a legal data value, the
SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> raise place error.execution in the
internal event queue and <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> create an empty data element in the data
model with the specified id.</p>

<p>Implementations <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> predeclare and predefine variables in the
data model. However, conformant SCXML implementations <em title="SHOULD NOT in RFC2119 context" class="RFC2119">SHOULD
NOT</em> assume the existence of any predeclared or predefined
variables (i.e., ones not explicitly defined by &lt;data&gt;).</p>

<p>Note that this specification does not define any way to modify
the data model except by&lt;assign&gt;, &lt;finalize&gt;, and
possibly platform-specific elements of executable content. In
particular, no means is defined for external entities to modify the
data model. In this sense the data model is local to the SCXML
session and the SCXML Processor checks for eventless transitions
(i.e. ones that are triggered based only on the state of the data
model) only after entering a state or processing an event. However
in some deployments it may be possible for external entities to
modify the data model. For example, if SCXML is implemented in
JavaScript in a browser, the scope of a document's data model is
always accessible through the main window object and thus
JavaScript code elsewhere in the window can modify the data model
independent of the SCXML interpretation algorithm. Such a situation
can lead to race conditions and unpredictable behavior</p>
</div>

<div class="div3">
<h4><a id="DataBinding" name="DataBinding">5.3.3 Data
Binding</a></h4><a id="DataBinding" name="DataBinding">

<p>Authors control when the initial values are assigned to the data
elements by means of the 'binding' attribute on the &lt;scxml&gt;
element. When 'binding' is assigned the value "early" (the
default), the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> create all data elements and assign their
initial values at document initialization time. When 'binding' is
assigned the value "late", the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> create
the data elements at document initialization time, but <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> assign
the specified initial value to a given data element only when the
state that contains it is entered for the first time, before any
&lt;onentry&gt; markup. (The value of the data element between the
time it is created and the time its parent state is first entered
will depend on the data language chosen. The initial value
specified by 'expr', 'src' or in-line content will be assigned to
the data element even if the element already has a non-null value
when the parent state is first entered.)</p>
</a></div><a id="DataBinding" name="DataBinding">
</a></div><a id="DataBinding" name="DataBinding">

</a><div class="div2"><a id="DataBinding" name="DataBinding">
</a><h3><a id="DataBinding" name="DataBinding"></a><a id="assign" name="assign">5.4 &lt;assign&gt;</a></h3><a id="assign" name="assign">

<p>[This section is normative.]</p>

<p>The &lt;assign&gt; element is used to modify the data model.</p>

</a><div class="div3"><a id="assign" name="assign">
</a><h4><a id="assign" name="assign"></a><a id="N10A70" name="N10A70">5.4.1 Attribute Details</a></h4><a id="N10A70" name="N10A70">

<table border="1" summary="attibute table">
<tbody>
<tr>
<th>Name</th>
<th>Required</th>
<th>Attribute Constraints</th>
<th>Type</th>
<th>Default Value</th>
<th>Valid Values</th>
<th>Description</th>
</tr>

<tr>
<td>location</td>
<td>true</td>
<td>
</td><td>path expression</td>
<td>none</td>
<td>Any valid location expression.</td>
<td>The location in the data model into which to insert the new
value. See <a href="http://www.w3.org/TR/scxml/#LocationExpressions"><em>5.9.2 Location
Expressions</em></a> for details.</td>
</tr>

<tr>
<td>expr</td>
<td>false</td>
<td>This attribute must not occur in an &lt;assign&gt; element that
has children.</td>
<td>value expression</td>
<td>none</td>
<td>Any valid value expression</td>
<td>An expression returning the value to be assigned. See <a href="http://www.w3.org/TR/scxml/#ValueExpressions"><em>5.9.3 Legal Data Values and Value
Expressions</em></a> for details.</td>
</tr>
</tbody>
</table>
</a></div><a id="N10A70" name="N10A70">

</a><div class="div3"><a id="N10A70" name="N10A70">
</a><h4><a id="N10A70" name="N10A70"></a><a id="N10AAB" name="N10AAB">5.4.2 Children</a></h4><a id="N10AAB" name="N10AAB">

</a><p><a id="N10AAB" name="N10AAB">The children of the &lt;assign&gt;element provide an in-line
specification of the legal data value (see </a><a href="http://www.w3.org/TR/scxml/#ValueExpressions"><em>5.9.3 Legal Data Values and Value
Expressions</em></a>) to be inserted into the data model at the
specified location.</p>
</div>

<p>A conformant SCXML document <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> specify either "expr" or children of
&lt;assign&gt;, but not both.</p>

<p>Assignment to a data model is done by using a location
expression to denote the part of the data model where the insertion
is to be made. If the location expression does not denote a valid
location in the data model or if the value specified (by 'expr' or
children) is not a legal value for the location specified, the
SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place the error 'error.execution' in the
internal event queue. Otherwise, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place the
specified value at the specified location. Note that the nature of
the insertion and the definition of a legal value depends on the
data model language used. Note also that data models <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> support
additional attributes for &lt;assign&gt; beyond those specified
here. See <a href="http://www.w3.org/TR/scxml/#profiles"><em>B Data Models</em></a> for
details.</p>
</div>

<div class="div2">
<h3><a id="donedata" name="donedata">5.5 &lt;donedata&gt;</a></h3><a id="donedata" name="donedata">

<p>[This section is normative.]</p>

<p>A wrapper element holding data to be returned when a
&lt;final&gt; state is entered.</p>

</a><div class="div3"><a id="donedata" name="donedata">
</a><h4><a id="donedata" name="donedata"></a><a id="N10ACE" name="N10ACE">5.5.1 Attribute Details</a></h4><a id="N10ACE" name="N10ACE">

<p>None.</p>
</a></div><a id="N10ACE" name="N10ACE">

</a><div class="div3"><a id="N10ACE" name="N10ACE">
</a><h4><a id="N10ACE" name="N10ACE"></a><a id="N10AD3" name="N10AD3">5.5.2 Children</a></h4><a id="N10AD3" name="N10AD3">

</a><ul><a id="N10AD3" name="N10AD3">
</a><li><a id="N10AD3" name="N10AD3">&lt;content&gt;. Specifies data to include in the event. May
occur 0 or 1 times. See </a><a href="http://www.w3.org/TR/scxml/#content"><em>5.6
&lt;content&gt;</em></a> .</li>

<li>&lt;param&gt; Extracts data from the data model to include in
the event. See <a href="http://www.w3.org/TR/scxml/#param"><em>5.7 &lt;param&gt;</em></a> for
details. May occur 0 or more times.</li>
</ul>
</div>

<p>A conformant SCXML document <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> specify either a single &lt;content&gt;
element or one or more &lt;param&gt; elements as children of
&lt;donedata&gt;, but not both.</p>

<p>In cases where the SCXML Processor generates a 'done' event upon
entry into the final state, it <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> evaluate the &lt;donedata&gt; elements
&lt;param&gt; or &lt;content&gt; children and place the resulting
data in the _event.data field. The exact format of that data will
be determined by the data model (see <a href="http://www.w3.org/TR/scxml/#profiles"><em>B Data
Models</em></a> for details). In other cases (namely when the
&lt;final&gt; element is a child of &lt;scxml&gt; and the state
machine has not been triggered by &lt;invoke&gt;), the SCXML
Processor <em title="SHOULD in RFC2119 context" class="RFC2119">SHOULD</em> return the data to the environment in
an implementation-dependent manner.</p>
</div>

<div class="div2">
<h3><a id="content" name="content">5.6 &lt;content&gt;</a></h3><a id="content" name="content">

<p>[This section is normative.]</p>

<p>A container element holding data to be passed to an external
service.</p>

</a><div class="div3"><a id="content" name="content">
</a><h4><a id="content" name="content"></a><a id="N10AFB" name="N10AFB">5.6.1 Attribute Details</a></h4><a id="N10AFB" name="N10AFB">

<table border="1" summary="attibute table">
<tbody>
<tr>
<th>Name</th>
<th>Required</th>
<th>Attribute Constraints</th>
<th>Type</th>
<th>Default Value</th>
<th>Valid Values</th>
<th>Description</th>
</tr>

<tr>
<td>expr</td>
<td>false</td>
<td>must not occur with child content</td>
<td>Value expression</td>
<td>none</td>
<td>Any valid value expression</td>
<td>A value expression. See <a href="http://www.w3.org/TR/scxml/#ValueExpressions"><em>5.9.3
Legal Data Values and Value Expressions</em></a> for details.</td>
</tr>
</tbody>
</table>
</a></div><a id="N10AFB" name="N10AFB">

</a><div class="div3"><a id="N10AFB" name="N10AFB">
</a><h4><a id="N10AFB" name="N10AFB"></a><a id="N10B25" name="N10B25">5.6.2 Children</a></h4><a id="N10B25" name="N10B25">

<p>A conformant SCXML document <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em>
specify both the 'expr' attribute and child content. When present,
the children of &lt;content&gt; <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> consist of text, XML from any namespace,
or a mixture of both.</p>
</a></div><a id="N10B25" name="N10B25">

</a><p><a id="N10B25" name="N10B25">The use of the &lt;content&gt; element depends on the context in
which it occurs. See </a><a href="http://www.w3.org/TR/scxml/#donedata"><em>5.5
&lt;donedata&gt;</em></a>, <a href="http://www.w3.org/TR/scxml/#send"><em>6.2
&lt;send&gt;</em></a> and <a href="http://www.w3.org/TR/scxml/#invoke"><em>6.4
&lt;invoke&gt;</em></a> for details. When the SCXML Processor
evaluates the &lt;content&gt; element, if the 'expr' value
expression is present, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> evaluate
it and use the result as the output of the &lt;content&gt; element.
If the evaluation of 'expr' produces an error, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place
error.execution in the internal event queue and use the empty
string as the value of the &lt;content&gt; element. If the 'expr'
attribute is not present, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> use the
children of &lt;content&gt; as the output. The interpretation of
the output of the &lt;content&gt; element depends on the data
model. See <a href="http://www.w3.org/TR/scxml/#profiles"><em>B Data Models</em></a> for
details. For the use of namespaces inside &lt;content&gt;, see <a href="http://www.w3.org/TR/scxml/#content_and_namespaces"><em>G.6 Inline Content and
Namespaces</em></a>.</p>
</div>

<div class="div2">
<h3><a id="param" name="param">5.7 &lt;param&gt;</a></h3><a id="param" name="param">

<p>[This section is normative.]</p>

<p>The &lt;param&gt; tag provides a general way of identifying a
key and a dynamically calculated value which can be passed to an
external service or included in an event.</p>

</a><div class="div3"><a id="param" name="param">
</a><h4><a id="param" name="param"></a><a id="N10B52" name="N10B52">5.7.1 Attribute Details</a></h4><a id="N10B52" name="N10B52">

<table border="1" summary="attibute table">
<tbody>
<tr>
<th>Name</th>
<th>Required</th>
<th>Attribute Constraints</th>
<th>Type</th>
<th>Default Value</th>
<th>Valid Values</th>
<th>Description</th>
</tr>

<tr>
<td>name</td>
<td>true</td>
<td>
</td><td>NMTOKEN</td>
<td>none</td>
<td>A string literal</td>
<td>The name of the key.</td>
</tr>

<tr>
<td>expr</td>
<td>false</td>
<td>May not occur with 'location'</td>
<td>value expression</td>
<td>none</td>
<td>Valid value expression</td>
<td>A value expression (see <a href="http://www.w3.org/TR/scxml/#ValueExpressions"><em>5.9.3
Legal Data Values and Value Expressions</em></a>) that is evaluated
to provide the value.</td>
</tr>

<tr>
<td>location</td>
<td>false</td>
<td>May not occur with 'expr'</td>
<td>location expression</td>
<td>none</td>
<td>Valid location expression</td>
<td>A location expression (see <a href="http://www.w3.org/TR/scxml/#LocationExpressions"><em>5.9.2 Location
Expressions</em></a>) that specifies the location in the datamodel
to retrieve the value from.</td>
</tr>
</tbody>
</table>

</a><p><a id="N10B52" name="N10B52">A conformant SCXML document <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> specify either the 'expr' attribute of
&lt;param&gt; or the 'location' attribute, but <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em>
specify both. If the 'location' attribute does not refer to a valid
location in the data model, or if the evaluation of the 'expr'
produces an error, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place the
error 'error.execution' on the internal event queue and <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> ignore
the name and value. Otherwise the use of the name and value depends
on the context in which the &lt;param&gt; element occurs. See </a><a href="http://www.w3.org/TR/scxml/#donedata"><em>5.5 &lt;donedata&gt;</em></a>, <a href="http://www.w3.org/TR/scxml/#send"><em>6.2 &lt;send&gt;</em></a> and <a href="http://www.w3.org/TR/scxml/#invoke"><em>6.4 &lt;invoke&gt;</em></a> for details.</p>
</div>

<div class="div3">
<h4><a id="N10BB3" name="N10BB3">5.7.2 Children</a></h4><a id="N10BB3" name="N10BB3">

<p>None.</p>
</a></div><a id="N10BB3" name="N10BB3">
</a></div><a id="N10BB3" name="N10BB3">

</a><div class="div2"><a id="N10BB3" name="N10BB3">
</a><h3><a id="N10BB3" name="N10BB3"></a><a id="script" name="script">5.8 &lt;script&gt;</a></h3><a id="script" name="script">

<p>[This section is normative.]</p>

<p>The &lt;script&gt; element adds scripting capability to the
state machine.</p>

</a><div class="div3"><a id="script" name="script">
</a><h4><a id="script" name="script"></a><a id="N10BC0" name="N10BC0">5.8.1 Attribute Details</a></h4><a id="N10BC0" name="N10BC0">

<table border="1" summary="attibute table">
<tbody>
<tr>
<th>Name</th>
<th>Required</th>
<th>Attribute Constraints</th>
<th>Type</th>
<th>Default Value</th>
<th>Valid Values</th>
<th>Description</th>
</tr>

<tr>
<td>src</td>
<td>false</td>
<td>May not occur if the element has children.</td>
<td>
</td><td>none</td>
<td>A valid URI</td>
<td>Gives the location from which the script should be
downloaded.</td>
</tr>
</tbody>
</table>
</a></div><a id="N10BC0" name="N10BC0">

</a><div class="div3"><a id="N10BC0" name="N10BC0">
</a><h4><a id="N10BC0" name="N10BC0"></a><a id="N10BE6" name="N10BE6">5.8.2 Children</a></h4><a id="N10BE6" name="N10BE6">

<p>The child content of the &lt;script&gt; element represents the
script code to be executed.</p>
</a></div><a id="N10BE6" name="N10BE6">

<p>A conformant SCXML document <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> specify either the 'src' attribute or
child content, but not both. If 'src' is specified, the SCXML
Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> download the script from the specified
location at load time. If the script can not be downloaded within a
platform-specific timeout interval, the document is considered
non-conformant, and the platform <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> reject
it.</p>

<p>The SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> evaluate any &lt;script&gt; element that
is a child of &lt;scxml&gt; at document load time. It <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> evaluate
all other &lt;script&gt; elements as part of normal executable
content evaluation.</p>

</a><p><a id="N10BE6" name="N10BE6">In a conformant SCXML document, the name of any script variable
<em title="MAY in RFC2119 context" class="RFC2119">MAY</em> be used
as a location expression (see </a><a href="http://www.w3.org/TR/scxml/#LocationExpressions"><em>5.9.2 Location
Expressions</em></a>).</p>

<p>For an example of a data model incorporating scripting, see <a href="http://www.w3.org/TR/scxml/#ecma-profile"><em>B.2 The ECMAScript Data
Model</em></a>.</p>
</div>

<div class="div2">
<h3><a id="Expressions" name="Expressions">5.9 Expressions</a></h3><a id="Expressions" name="Expressions">

<p>[This section is normative.]</p>

<p>SCXML contains three types of expressions, as described below.
Different data models will support different languages for these
expression types, but certain properties of the expressions are
constant across languages and are defined here.</p>

<p>When "late" data binding is used, accessing data substructure in
expressions before the corresponding &lt;data&gt; element is loaded
<em title="MUST in RFC2119 context" class="RFC2119">MUST</em> yield
the same execution-time behavior as accessing non-existent data
substructure in a loaded &lt;data&gt; instance. Such behavior is
defined by the data expression language in use.</p>

</a><div class="div3"><a id="Expressions" name="Expressions">
</a><h4><a id="Expressions" name="Expressions"></a><a id="ConditionalExpressions" name="ConditionalExpressions">5.9.1 Conditional Expressions</a></h4><a id="ConditionalExpressions" name="ConditionalExpressions">

<p>Conditional expressions are used inside the 'cond' attribute of
&lt;transition&gt;, &lt;if&gt; and &lt;elseif&gt;. If a conditional
expression cannot be evaluated as a boolean value ('true' or
'false') or if its evaluation causes an error, the SCXML Processor
<em title="MUST in RFC2119 context" class="RFC2119">MUST</em> treat
the expression as if it evaluated to 'false' and <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place the
error 'error.execution' in the internal event queue. The set of
operators in conditional expressions varies depending on the data
model, but all data models <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> support the 'In()' predicate, which takes
a state ID as its argument and returns true if the state machine is
in that state. This predicate allows coordination among parallel
regions. Conditional expressions in conformant SCXML documents <em title="SHOULD NOT in RFC2119 context" class="RFC2119">SHOULD
NOT</em> have side effects.</p>
</a></div><a id="ConditionalExpressions" name="ConditionalExpressions">

</a><div class="div3"><a id="ConditionalExpressions" name="ConditionalExpressions">
</a><h4><a id="ConditionalExpressions" name="ConditionalExpressions"></a><a id="LocationExpressions" name="LocationExpressions">5.9.2
Location Expressions</a></h4><a id="LocationExpressions" name="LocationExpressions">

<p>Location expressions are used to specify a location in the data
model, e.g. as part of the &lt;assign&gt;, &lt;param&gt;,
&lt;send&gt; or &lt;invoke&gt; elements. The exact nature of a
location depends on the data model. If a location expression cannot
be evaluated to yield a valid location, the SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place the
error 'error.execution' in the internal event queue.</p>
</a></div><a id="LocationExpressions" name="LocationExpressions">

</a><div class="div3"><a id="LocationExpressions" name="LocationExpressions">
</a><h4><a id="LocationExpressions" name="LocationExpressions"></a><a id="ValueExpressions" name="ValueExpressions">5.9.3 Legal
Data Values and Value Expressions</a></h4><a id="ValueExpressions" name="ValueExpressions">

<p>A data model definition contains a specification of the
underlying data structure. Such a specification of the data
structure implicitly defines a set of "legal data values", namely
the objects that can be part of such a data structure. In
conjunction with this, the data model definition specifies a set of
value expressions which can be evaluated at runtime to return legal
data values. If a value expression does not return a legal data
value, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place the error 'error.execution' in the
internal event queue.</p>
</a></div><a id="ValueExpressions" name="ValueExpressions">

</a><div class="div3"><a id="ValueExpressions" name="ValueExpressions">
</a><h4><a id="ValueExpressions" name="ValueExpressions"></a><a id="ErrorsinExpressions" name="ErrorsinExpressions">5.9.4
Errors in Expressions</a></h4><a id="ErrorsinExpressions" name="ErrorsinExpressions">

<p>The SCXML Processor <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> reject documents containing syntactically
ill-formed expressions at document load time, or it <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> wait and
place 'error.execution' in the internal event queue at runtime when
the expressions are evaluated. If the processor waits until it
evaluates the expressions at runtime to raise errors, it <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> raise
errors caused by expressions returning illegal values at the points
at which the expressions are to be evaluated. Note that this
requirement holds even if the implementation is optimizing
expression evaluation.</p>
</a></div><a id="ErrorsinExpressions" name="ErrorsinExpressions">
</a></div><a id="ErrorsinExpressions" name="ErrorsinExpressions">

</a><div class="div2"><a id="ErrorsinExpressions" name="ErrorsinExpressions">
</a><h3><a id="ErrorsinExpressions" name="ErrorsinExpressions"></a><a id="SystemVariables" name="SystemVariables">5.10 System
Variables</a></h3><a id="SystemVariables" name="SystemVariables">

<p>[This section is normative.]</p>

<p>The SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> maintain a protected portion of the data
model containing information that can be useful to applications. We
refer to the items in this special part of the data model as
'system variables'. Implementations <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> provide
the following system variables, and <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> support
others.</p>

</a><ul><a id="SystemVariables" name="SystemVariables">
</a><li><a id="SystemVariables" name="SystemVariables"><em>_event</em>. The SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> use the
variable '_event' to hold a structure containing the current
event's name and any data contained in the event (see </a><a href="http://www.w3.org/TR/scxml/#InternalStructureofEvents"><em>5.10.1 The Internal Structure
of Events</em></a>. The exact nature of the structure depends on
the data model being used. See <a href="http://www.w3.org/TR/scxml/#profiles"><em>B Data
Models</em></a> for details. The SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> bind the
_event variable when an event is pulled off the internal or
external event queue to be processed, and <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> keep the
variable bound to that event until another event is processed. (It
follows that when an application is testing the 'cond' attribute of
a &lt;transition&gt; element that contains an 'event' attribute,
_event will be bound to the event that the transition is being
matched against. If the transition is selected to be executed,
_event will remain bound to that event in the &lt;onexit&gt;
handlers of the states being exited, the executable content of the
transition itself, and the &lt;onentry&gt; handlers of the states
being entered. In the case of &lt;transition&gt; elements that do
not contain an 'event' attribute and the &lt;onexit&gt; and
&lt;onentry&gt; handlers of any states that are exited or entered
by such transitions, the _event variable will not have a easily
predictable value since the transition is not being driven by an
event. In these cases, _event will be bound to the last event that
was matched against a transition.) The SCXML Processor <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em>
bind _event at initialization time until the first event is
processed. Hence _event is unbound when the state machine starts
up. If the data in the event is not a legal instance of the data
model language, and the Processor cannot translate it into one,
then the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place the error 'error.execution' in the
internal event queue at the point at which it attempts to bind
_event. In this case, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> leave the
event data part of the _event structure unbound. (Note that the
event's name will still be available, however and that processing
of both the original event and the error event will proceed as
usual.)</li>

<li><em>_sessionid</em>. The SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> bind the
variable _sessionid at load time to the system-generated id for the
current SCXML session. (This is of type NMTOKEN.) The Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> keep the
variable bound to this value until the session terminates.</li>

<li><em>_name</em>. The SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> bind the
variable _name at load time to the value of the 'name' attribute of
the &lt;scxml&gt; element. The Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> keep the
variable bound to this value until the session terminates.</li>

<li><em>_ioprocessors</em>. The SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> bind the
variable _ioprocessors to a set of values, one for each Event I/O
Processor that it supports. The syntax to access it depends on the
data model. See <a href="http://www.w3.org/TR/scxml/#profiles"><em>B Data Models</em></a> for
details. The nature of the values associated with the individual
Event I/O Processors depends on the Event I/O Processor in
question. See <a href="http://www.w3.org/TR/scxml/#eventioprocessors"><em>C Event I/O
Processors</em></a> for details. The Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> keep the
variable bound to this set of values until the session
terminates.</li>

<li><em>_x</em>. The variable _x is the root element for
platform-specific system variables. The Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place all
platform-specific system variables underneath it. The exact
structure of the platform-specific variables depends on the data
model. For example, in the ECMAScript data model <a href="http://www.w3.org/TR/scxml/#ecma-profile"><em>B.2 The ECMAScript Data Model</em></a>,
'_x' will be a top-level ECMAScript object and the
platform-specific system variables will be its properties.</li>
</ul>

<p>The set of system variables may be expanded in future versions
of this specification. Variable names beginning with '_' are
reserved for system use. A conformant SCXML document <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em>
contain ids beginning with '_' in the &lt;data&gt; element.
Platforms <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place all platform-specific system
variables under the '_x' root.</p>

<p>The concrete realization of these variables in a specific data
model depends on the language used. The Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> cause any
attempt to change the value of a system variable to fail and <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place the
error 'error.execution' on the internal event queue when such an
attempt is made.</p>

<div class="div3">
<h4><a id="InternalStructureofEvents" name="InternalStructureofEvents">5.10.1 The Internal Structure of
Events</a></h4><a id="InternalStructureofEvents" name="InternalStructureofEvents">

<p>Events have an internal structure which is reflected in the
_event variable. This variable can be accessed to condition
transitions (via boolean expressions in the 'cond' attribute) or to
update the data model (via &lt;assign&gt;), etc.</p>

<p>The SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> ensure that the following fields are
present in all events, whether internal or external.</p>

</a><ul><a id="InternalStructureofEvents" name="InternalStructureofEvents">
<li><em>name</em>. This is a character string giving the name of
the event. The SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> set the name field to the name of this
event. It is what is matched against the 'event' attribute of
&lt;transition&gt;. Note that transitions can do additional tests
by using the value of this field inside boolean expressions in the
'cond' attribute.</li>

<li><em>type</em>. This field describes the event type. The SCXML
Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> set it to: "platform" (for events raised
by the platform itself, such as error events), "internal" (for
events raised by &lt;raise&gt; and &lt;send&gt; with target
'_internal') or "external" (for all other events).</li>

</a><li><a id="InternalStructureofEvents" name="InternalStructureofEvents"><em>sendid</em>. If the sending entity has specified a value
for this, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> set this field to that value (see </a><a href="http://www.w3.org/TR/scxml/#eventioprocessors"><em>C Event I/O Processors</em></a> for
details). Otherwise, in the case of error events triggered by a
failed attempt to send an event, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> set this
field to the send id of the triggering &lt;send&gt; element.
Otherwise it <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> leave it blank.</li>

<li><em>origin</em>. This is a URI, equivalent to the 'target'
attribute on the &lt;send&gt; element. For external events, the
SCXML Processor <em title="SHOULD in RFC2119 context" class="RFC2119">SHOULD</em> set this field to a value which, when
used as the value of 'target', will allow the receiver of the event
to &lt;send&gt; a response back to the originating entity via the
Event I/O Processor specified in 'origintype'. For internal and
platform events, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> leave this field blank.</li>

<li><em>origintype</em>. This is equivalent to the 'type' field on
the &lt;send&gt; element. For external events, the SCXML Processor
<em title="SHOULD in RFC2119 context" class="RFC2119">SHOULD</em>
set this field to a value which, when used as the value of 'type',
will allow the receiver of the event to &lt;send&gt; a response
back to the originating entity at the URI specified by 'origin'.
For internal and platform events, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> leave
this field blank.</li>

<li><em>invokeid</em>. If this event is generated from an invoked
child process, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> set this
field to the invoke id of the invocation that triggered the child
process. Otherwise it <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> leave it blank.</li>

<li><em>data</em>. This field contains whatever data the sending
entity chose to include in this event. The receiving SCXML
Processor <em title="SHOULD in RFC2119 context" class="RFC2119">SHOULD</em> reformat this data to match its data
model, but <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em> otherwise modify it. If the
conversion is not possible, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> leave the
field blank and <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place an error 'error.execution' in the
internal event queue.</li>
</ul>
</div>
</div>
</div>

<div class="div1">
<h2><a id="external-module" name="external-module">6 External
Communications</a></h2><a id="external-module" name="external-module">

</a><div class="div2"><a id="external-module" name="external-module">
</a><h3><a id="external-module" name="external-module"></a><a id="ExternalIntroduction" name="ExternalIntroduction">6.1
Introduction</a></h3><a id="ExternalIntroduction" name="ExternalIntroduction">

<p>[This section is informative.]</p>

</a><p><a id="ExternalIntroduction" name="ExternalIntroduction">The External Communications capability allows an SCXML session
to send and receive events from external entities, and to invoke
external services. </a><a href="http://www.w3.org/TR/scxml/#send"><em>6.2 &lt;send&gt;</em></a>
provides "fire and forget" capability to deliver events and data to
any destination, including other SCXML sessions. The 'delay'
attribute allows for deferred event delivery and can be used to
implement a timer. The details of event transport as well as the
format of the event and data are determined by the Event I/O
Processor selected. Each implementation will support one or more
such processor, and the author of the SCXML markup can choose the
one that is appropriate for the type of endpoint he is trying to
reach.</p>

<p><a href="http://www.w3.org/TR/scxml/#invoke"><em>6.4 &lt;invoke&gt;</em></a> offers a more
tightly coupled form of communication, specifically the ability to
trigger a platform-defined service and pass data to it. It and its
child &lt;finalize&gt; are useful in states that model the behavior
of an external service. The &lt;invoke&gt; element is executed
after the state's &lt;onentry&gt; element and causes an instance of
the external service to be created. The &lt;param&gt; and
&lt;content&gt; elements and the 'namelist' attribute can be used
to pass data to the service. Any events that are received by the
state machine from the invoked component during the invocation are
preprocessed by the &lt;finalize&gt; handler <em>before</em>
transitions are selected. The &lt;finalize&gt; code is used to
normalize the form of the returned data and to update the data
model before the transitions' "event" and "cond" clauses are
evaluated.</p>

<p>When parallel states invoke the same external service
concurrently, separate instances of the external service will be
started. They can be distinguished by ids which are associated with
them. Similarly, the ids contained in the events returned from the
external services can be used to determine which events are
responses to which invocation. Each event that is returned will be
processed only by the &lt;finalize&gt; in the state that invoked
it, but that event is then processed like any other event that the
state machine receives. The finalize code can thus be thought of as
a preprocessing stage that applies before the event is added to the
event queue. Note that the event will be passed to all parallel
states to check for transitions.</p>

<p>Since an invocation will be canceled when the state machine
leaves the invoking state, it does not make sense to start an
invocation in a state that will be exited immediately. Therefore
the &lt;invoke&gt; element is executed upon entry into the state,
but only <em>after</em> checking for eventless transitions and
transitions driven by pending internal events. If any such enabled
transition is found , it is taken and the state is exited
immediately, without triggering the invocation. Thus invocations
are triggered only when the state machine has reached a stable
configuration, i.e., one that it will be staying in while it waits
for external events.</p>
</div>

<div class="div2">
<h3><a id="send" name="send">6.2 &lt;send&gt;</a></h3><a id="send" name="send">

<p>[This section is normative.]</p>

</a><div class="div3"><a id="send" name="send">
</a><h4><a id="send" name="send"></a><a id="N10D3A" name="N10D3A">6.2.1 Overview</a></h4><a id="N10D3A" name="N10D3A">

<p>&lt;send&gt; is used to send events and data to external
systems, including external SCXML Interpreters, or to raise events
in the current SCXML session.</p>
</a></div><a id="N10D3A" name="N10D3A">

</a><div class="div3"><a id="N10D3A" name="N10D3A">
</a><h4><a id="N10D3A" name="N10D3A"></a><a id="N10D3F" name="N10D3F">6.2.2 Attribute Details</a></h4><a id="N10D3F" name="N10D3F">

<table border="1" summary="attibute table">
<tbody>
<tr>
<th>Name</th>
<th>Required</th>
<th>Attribute Constraints</th>
<th>Type</th>
<th>Default Value</th>
<th>Valid Values</th>
<th>Description</th>
</tr>

<tr>
<td>event</td>
<td>false</td>
<td>Must not occur with 'eventexpr'. If the type is
http://www.w3.org/TR/scxml/#SCXMLEventProcessor, either this
attribute or 'eventexpr' must be present.</td>
<td>EventType.datatype</td>
<td>none</td>
<td></td>
<td>A string indicating the name of message being generated. See <a href="http://www.w3.org/TR/scxml/#schemas"><em>E Schema</em></a> for details on the data
type.</td>
</tr>

<tr>
<td>eventexpr</td>
<td>false</td>
<td>Must not occur with 'event'. If the type is
http://www.w3.org/TR/scxml/#SCXMLEventProcessor, either this
attribute or 'event' must be present.</td>
<td>Value expression</td>
<td>none</td>
<td></td>
<td>A dynamic alternative to 'event'. If this attribute is present,
the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> evaluate it when the parent &lt;send&gt;
element is evaluated and treat the result as if it had been entered
as the value of 'event'.</td>
</tr>

<tr>
<td>target</td>
<td>false</td>
<td>Must not occur with 'targetexpr'</td>
<td>URI</td>
<td>none</td>
<td>A valid target URI</td>
<td>The unique identifier of the message target that the platform
should send the event to. See <a href="http://www.w3.org/TR/scxml/#SendTargets"><em>6.2.4 The
Target of Send</em></a> for details.</td>
</tr>

<tr>
<td>targetexpr</td>
<td>false</td>
<td>Must not occur with 'target'</td>
<td>Value expression</td>
<td>none</td>
<td>An expression evaluating to a valid target URI</td>
<td>A dynamic alternative to 'target'. If this attribute is
present, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> evaluate it when the parent &lt;send&gt;
element is evaluated and treat the result as if it had been entered
as the value of 'target'.</td>
</tr>

<tr>
<td>type</td>
<td>false</td>
<td>Must not occur with 'typeexpr'</td>
<td>URI</td>
<td>none</td>
<td></td>
<td>The URI that identifies the transport mechanism for the
message. See <a href="http://www.w3.org/TR/scxml/#SendTypes"><em>6.2.5 The Type of
Send</em></a> for details.</td>
</tr>

<tr>
<td>typeexpr</td>
<td>false</td>
<td>Must not occur with 'type'</td>
<td>value expression</td>
<td>none</td>
<td></td>
<td>A dynamic alternative to 'type'. If this attribute is present,
the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> evaluate it when the parent &lt;send&gt;
element is evaluated and treat the result as if it had been entered
as the value of 'type'.</td>
</tr>

<tr>
<td>id</td>
<td>false</td>
<td>Must not occur with 'idlocation'.</td>
<td>xml:ID</td>
<td>none</td>
<td>Any valid token</td>
<td>A string literal to be used as the identifier for this instance
of &lt;send&gt;. See <a href="http://www.w3.org/TR/scxml/#IDs"><em>3.14 IDs</em></a> for
details.</td>
</tr>

<tr>
<td>idlocation</td>
<td>false</td>
<td>Must not occur with 'id'.</td>
<td>Location expression</td>
<td>none</td>
<td>Any valid location expression</td>
<td>Any location expression evaluating to a data model location in
which a system-generated id can be stored. See below for
details.</td>
</tr>

<tr>
<td>delay</td>
<td>false</td>
<td>Must not occur with 'delayexpr' or when the attribute 'target'
has the value "_internal".</td>
<td>Duration.datatype</td>
<td>None</td>
<td>A time designation as defined in CSS2 <a href="http://www.w3.org/TR/scxml/#">[CSS2]</a>
format</td>
<td>Indicates how long the processor should wait before dispatching
the message. See <a href="http://www.w3.org/TR/scxml/#schemas"><em>E Schema</em></a> for
details on the data type.</td>
</tr>

<tr>
<td>delayexpr</td>
<td>false</td>
<td>Must not occur with 'delay' or when the attribute 'target' has
the value "_internal".</td>
<td>Value expression</td>
<td>None</td>
<td>A value expression which returns a time designation as defined
in CSS2 <a href="http://www.w3.org/TR/scxml/#">[CSS2]</a> format</td>
<td>A dynamic alternative to 'delay'. If this attribute is present,
the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> evaluate it when the parent &lt;send&gt;
element is evaluated and treat the result as if it had been entered
as the value of 'delay'.</td>
</tr>

<tr>
<td>namelist</td>
<td>false</td>
<td>Must not be specified in conjunction with &lt;content&gt;
element.</td>
<td>List of location expressions</td>
<td>none</td>
<td>List of valid location expressions</td>
<td>A space-separated list of one or more data model locations to
be included as attribute/value pairs with the message. (The name of
the location is the attribute and the value stored at the location
is the value.) See <a href="http://www.w3.org/TR/scxml/#LocationExpressions"><em>5.9.2
Location Expressions</em></a> for details.</td>
</tr>
</tbody>
</table>
</a></div><a id="N10D3F" name="N10D3F">

</a><div class="div3"><a id="N10D3F" name="N10D3F">
</a><h4><a id="N10D3F" name="N10D3F"></a><a id="N10E20" name="N10E20">6.2.3 Children</a></h4><a id="N10E20" name="N10E20">

</a><ul><a id="N10E20" name="N10E20">
</a><li><a id="N10E20" name="N10E20">&lt;param&gt;. The SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> evaluate
this element when the parent &lt;send&gt; element is evaluated and
pass the resulting data to the external service when the message is
delivered. Occurs 0 or more times. See </a><a href="http://www.w3.org/TR/scxml/#param"><em>5.7
&lt;param&gt;</em></a> for details.</li>

<li>&lt;content&gt;. The SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> evaluate
this element when the parent &lt;send&gt; element is evaluated and
pass the resulting data to the external service when the message is
delivered. Occurs 0 or 1 times. See <a href="http://www.w3.org/TR/scxml/#content"><em>5.6
&lt;content&gt;</em></a> for details.</li>
</ul>

<p>A conformant SCXML document <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> specify exactly one of 'event',
'eventexpr' and &lt;content&gt;. A conformant document <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em>
specify "namelist" or &lt;param&gt; with &lt;content&gt;.</p>

<p>The SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> include all attributes and values
provided by &lt;param&gt; or 'namelist' even if duplicates
occur.</p>

<p>If 'idlocation' is present, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> generate
an id when the parent &lt;send&gt; element is evaluated and store
it in this location. See <a href="http://www.w3.org/TR/scxml/#IDs"><em>3.14 IDs</em></a> for
details.</p>

<p>If a delay is specified via 'delay' or 'delayexpr', the SCXML
Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> interpret the character string as a time
interval. It <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> dispatch the message only when the delay
interval elapses. (Note that the evaluation of the
<code>send</code> tag will return immediately.) The Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> evaluate
all arguments to &lt;send&gt; when the &lt;send&gt; element is
evaluated, and not when the message is actually dispatched. If the
evaluation of &lt;send&gt;'s arguments produces an error, the
Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> discard the message without attempting to
deliver it. If the SCXML session terminates before the delay
interval has elapsed, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> discard
the message without attempting to deliver it.</p>
</div>

<div class="div3">
<h4><a id="SendTargets" name="SendTargets">6.2.4 The Target of
Send</a></h4><a id="SendTargets" name="SendTargets">

<p>The target of the &lt;send&gt; operation specifies the
destination of the event. The target is defined by either the
'target' or the 'targetexpr' attribute. In most cases, the format
of the target depends on the type of the target (for example a SIP
URL for SIP-INFO messages or a HTTP URL for Web Services). If the
value of the 'target' or 'targetexpr' attribute is not supported or
invalid, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place the error error.execution on the
internal event queue. If it is unable to dispatch the message, the
Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place the error error.communication on
the internal event queue.</p>
</a></div><a id="SendTargets" name="SendTargets">

</a><div class="div3"><a id="SendTargets" name="SendTargets">
</a><h4><a id="SendTargets" name="SendTargets"></a><a id="SendTypes" name="SendTypes">6.2.5 The Type of
Send</a></h4><a id="SendTypes" name="SendTypes">

<p>The type of the &lt;send&gt; operation specifies the method that
the SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> use to deliver the message to its target.
A conformant SCXML document <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> use either the 'type' or the 'typeexpr'
attribute to define the type. If neither the 'type' nor the
'typeexpr' is defined, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> assume
the default value of
http://www.w3.org/TR/scxml/#SCXMLEventProcessor. If the SCXML
Processor does not support the type that is specified, it <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place the
event error.execution on the internal event queue.</p>

<p>SCXML Processors <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> support the following type:</p>

<table border="1" cellpadding="2" cellspacing="2" summary="send type values" width="100%">
<tbody>
<tr>
<th align="center">Value</th>
<th align="center">Details</th>
</tr>

<tr>
<td align="center">
http://www.w3.org/TR/scxml/#SCXMLEventProcessor</td>
<td align="left">Target is an SCXML session. The transport
mechanism is platform-specific.</td>
</tr>
</tbody>
</table>

</a><p><a id="SendTypes" name="SendTypes">For details on the
http://www.w3.org/TR/scxml/#SCXMLEventProcessor type, see </a><a href="http://www.w3.org/TR/scxml/#SCXMLEventProcessor"><em>C.1 SCXML Event I/O
Processor</em></a>.</p>

<p>Support for HTTP POST is optional, however Processors that
support it <em>must</em> use the following value for the "type"
attribute:</p>

<table border="1" cellpadding="2" cellspacing="2" summary="send type values" width="100%">
<tbody>
<tr>
<th align="center">Value</th>
<th align="center">Details</th>
</tr>

<tr>
<td align="center">
http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor</td>
<td align="left">Target is a URL. Data is sent via HTTP POST</td>
</tr>
</tbody>
</table>

<p>For details on the
http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor type, see <a href="http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor"><em>C.2 Basic HTTP Event I/O
Processor</em></a>.</p>

<p>Processors <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> support other types such as web-services,
SIP or basic HTTP GET. When they do so, they <em title="SHOULD in RFC2119 context" class="RFC2119">SHOULD</em>
assign such types the URI of the description of the relevant Event
I/O Processor. Processors <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> define short form notations as an
authoring convenience (e.g., "scxml" as equivalent to
http://www.w3.org/TR/scxml/#SCXMLEventProcessor).</p>
</div>

<div class="div3">
<h4><a id="SendContent" name="SendContent">6.2.6 Message
Content</a></h4><a id="SendContent" name="SendContent">

<p>The sending SCXML Interpreter <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> not alter
the content of the &lt;send&gt; and <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> include
it in the message that it sends to the destination specified in the
target attribute of &lt;send&gt;.</p>

<p>Note that the document author can specify the message content in
one of two mutually exclusive ways:</p>

</a><ul><a id="SendContent" name="SendContent">
<li>An optional 'event' attribute, combined with an optional
'namelist' attribute, combined with 0 or more &lt;param&gt;
children. Here is an example using the 'event' and 'namelist'
attributes: 

<div class="exampleInner">
<pre>&lt;datamodel&gt;
&lt;data id="target" expr="'tel:+18005551212'"/&gt;
&lt;data id="content" expr="'http://www.example.com/mycontent.txt'"/&gt;
&lt;/datamodel&gt;
   ...
&lt;send target="target" type="x-messaging" event="fax.SEND" namelist="content"/&gt;
</pre>
</div>
</li>

</a><li><a id="SendContent" name="SendContent">A single &lt;content&gt; child containing inline content
specifying the message body. See </a><a href="http://www.w3.org/TR/scxml/#content"><em>5.6
&lt;content&gt;</em></a> for details. 

<div class="exampleInner">
<pre>&lt;send target="csta://csta-server.example.com/" type="x-csta"&gt;
      &lt;content&gt;
      &lt;csta:MakeCall&gt;
        &lt;csta:callingDevice&gt;22343&lt;/callingDevice&gt;
        &lt;csta:calledDirectoryNumber&gt;18005551212&lt;/csta:calledDirectoryNumber&gt;
      &lt;/csta:MakeCall&gt;
      &lt;/content&gt;
&lt;/send&gt;
</pre>
</div>
</li>
</ul>

<p>Note that the absence of any error events does not mean that the
event was successfully delivered to its target, but only that the
platform was able to dispatch the event.</p>
</div>
</div>

<div class="div2">
<h3><a id="cancel" name="cancel">6.3 &lt;cancel&gt;</a></h3><a id="cancel" name="cancel">

<p>[This section is normative.]</p>

<p>The &lt;cancel&gt; element is used to cancel a delayed
&lt;send&gt; event. The SCXML Processor <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em>
allow &lt;cancel&gt; to affect events that were not raised in the
same session. The Processor <em title="SHOULD in RFC2119 context" class="RFC2119">SHOULD</em> make its best attempt to cancel all
delayed events with the specified id. Note, however, that it can
not be guaranteed to succeed, for example if the event has already
been delivered by the time the &lt;cancel&gt; tag executes.</p>

</a><div class="div3"><a id="cancel" name="cancel">
</a><h4><a id="cancel" name="cancel"></a><a id="N10F08" name="N10F08">6.3.1 Attribute Details</a></h4><a id="N10F08" name="N10F08">

<table border="1" summary="attibute table">
<tbody>
<tr>
<th>Name</th>
<th>Required</th>
<th>Attribute Constraints</th>
<th>Type</th>
<th>Default Value</th>
<th>Valid Values</th>
<th>Description</th>
</tr>

<tr>
<td>sendid</td>
<td>false</td>
<td>Must not occur with sendidexpr.</td>
<td>IDREF</td>
<td>none</td>
<td>The sendid of a delayed event</td>
<td>The ID of the event(s) to be cancelled. If multiple delayed
events have this sendid, the Processor will cancel them all.</td>
</tr>

<tr>
<td>sendidexpr</td>
<td>false</td>
<td>Must not occur with sendid.</td>
<td>Value Expression</td>
<td>none</td>
<td>Any expression that evaluates to the ID of a delayed event</td>
<td>A dynamic alternative to 'sendid'. If this attribute is
present, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> evaluate it when the parent
&lt;cancel&gt; element is evaluated and treat the result as if it
had been entered as the value of 'sendid'.</td>
</tr>
</tbody>
</table>
</a></div><a id="N10F08" name="N10F08">

<p>A conformant SCXML document <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> specify exactly one of sendid or
sendidexpr.</p>

</a><div class="div3"><a id="N10F08" name="N10F08">
</a><h4><a id="N10F08" name="N10F08"></a><a id="N10F46" name="N10F46">6.3.2 Children</a></h4><a id="N10F46" name="N10F46">

<p>None</p>
</a></div><a id="N10F46" name="N10F46">
</a></div><a id="N10F46" name="N10F46">

</a><div class="div2"><a id="N10F46" name="N10F46">
</a><h3><a id="N10F46" name="N10F46"></a><a id="invoke" name="invoke">6.4 &lt;invoke&gt;</a></h3><a id="invoke" name="invoke">

<p>[This section is normative.]</p>

<p>The &lt;invoke&gt; element is used to create an instance of an
external service.</p>

</a><div class="div3"><a id="invoke" name="invoke">
</a><h4><a id="invoke" name="invoke"></a><a id="invokeattrs" name="invokeattrs">6.4.1 Attribute
Details</a></h4><a id="invokeattrs" name="invokeattrs">

<table border="1" summary="attibute table">
<tbody>
<tr>
<th>Name</th>
<th>Required</th>
<th>Attribute Constraints</th>
<th>Type</th>
<th>Default Value</th>
<th>Valid Values</th>
<th>Description</th>
</tr>

<tr>
<td>type</td>
<td>false</td>
<td>Must not occur with the 'typeexpr' attribute.</td>
<td>URI</td>
<td>none</td>
<td>http://www.w3.org/TR/scxml/, http://www.w3.org/TR/ccxml/,
http://www.w3.org/TR/voicexml30/, http://www.w3.org/TR/voicexml21/
plus other platform-specific values.</td>
<td>A URI specifying the type of the external service. See below
for details.</td>
</tr>

<tr>
<td>typeexpr</td>
<td>false</td>
<td>Must not occur with the 'type' attribute.</td>
<td>value expression</td>
<td>none</td>
<td>Any value expression that evaluates to a URI that would be a
valid value for 'type'.</td>
<td>A dynamic alternative to 'type'. If this attribute is present,
the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> evaluate it when the parent
&lt;invoke&gt; element is evaluated and treat the result as if it
had been entered as the value of 'type'.</td>
</tr>

<tr>
<td>src</td>
<td>false</td>
<td>Must not occur with the 'srcexpr' attribute or the
&lt;content&gt; element.</td>
<td>URI</td>
<td>None</td>
<td>Any URI.</td>
<td>A URI to be passed to the external service. See below for
details.</td>
</tr>

<tr>
<td>srcexpr</td>
<td>false</td>
<td>Must not occur with the 'src' attribute or the &lt;content&gt;
element.</td>
<td>Value expression</td>
<td>None</td>
<td>Any expression evaluating to a valid URI.</td>
<td>A dynamic alternative to 'src'. If this attribute is present,
the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> evaluate it when the parent
&lt;invoke&gt; element is evaluated and treat the result as if it
had been entered as the value of 'src'.</td>
</tr>

<tr>
<td>id</td>
<td>false</td>
<td>Must not occur with the 'idlocation' attribute.</td>
<td>ID</td>
<td>none</td>
<td>Any valid token</td>
<td>A string literal to be used as the identifier for this instance
of &lt;invoke&gt;. See <a href="http://www.w3.org/TR/scxml/#IDs"><em>3.14 IDs</em></a> for
details.</td>
</tr>

<tr>
<td>idlocation</td>
<td>false</td>
<td>Must not occur with the 'id' attribute.</td>
<td>Location expression</td>
<td>none</td>
<td>Any valid location expression</td>
<td>Any data model expression evaluating to a data model location.
See <a href="http://www.w3.org/TR/scxml/#LocationExpressions"><em>5.9.2 Location
Expressions</em></a> for details.</td>
</tr>

<tr>
<td>namelist</td>
<td>false</td>
<td>Must not occur with the &lt;param&gt; element.</td>
<td>List of location expressions</td>
<td>none</td>
<td>List of valid location expressions</td>
<td>A space-separated list of one or more data model locations to
be passed as attribute/value pairs to the invoked service. (The
name of the location is the attribute and the value stored at the
location is the value.) See <a href="http://www.w3.org/TR/scxml/#DataSharing"><em>6.4.4 Data
Sharing</em></a> and <a href="http://www.w3.org/TR/scxml/#LocationExpressions"><em>5.9.2
Location Expressions</em></a> for details.</td>
</tr>

<tr>
<td>autoforward</td>
<td>false</td>
<td>
</td><td>boolean</td>
<td>false</td>
<td>true or false</td>
<td>A flag indicating whether to forward events to the invoked
process. See below for details.</td>
</tr>
</tbody>
</table>
</a></div><a id="invokeattrs" name="invokeattrs">

</a><div class="div3"><a id="invokeattrs" name="invokeattrs">
</a><h4><a id="invokeattrs" name="invokeattrs"></a><a id="N10FF5" name="N10FF5">6.4.2 Children</a></h4><a id="N10FF5" name="N10FF5">

</a><ul><a id="N10FF5" name="N10FF5">
</a><li><a id="N10FF5" name="N10FF5">&lt;param&gt;. Element containing data to be passed to the
external service. Occurs 0 or more times. See </a><a href="http://www.w3.org/TR/scxml/#param"><em>5.7 &lt;param&gt;</em></a>.</li>

<li>&lt;finalize&gt;. Element containing executable content to
massage the data returned from the invoked component. Occurs 0 or 1
times. See <a href="http://www.w3.org/TR/scxml/#finalize"><em>6.5 &lt;finalize&gt;</em></a>
for details.</li>

<li>&lt;content&gt;. The SCXML Processor MUST evaluate this element
when the parent &lt;invoke&gt; element is evaluated and pass the
resulting data to the invoked service. Occurs 0 or 1 times. See <a href="http://www.w3.org/TR/scxml/#content"><em>5.6 &lt;content&gt;</em></a> for details.</li>
</ul>
</div>

<p>Platforms <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> support http://www.w3.org/TR/scxml/ as a
value for the 'type' attribute. Platforms <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> support
http://www.w3.org/TR/voicexml21/, which indicates a VoiceXML 2.1
interpreter, http://www.w3.org/TR/voicexml30/, which indicates a
VoiceXML 3.x interpreter, and http://www.w3.org/TR/ccxml/, which
indicates a CCXML 1.0 interpreter. Platforms <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> support
additional values, but they <em title="SHOULD in RFC2119 context" class="RFC2119">SHOULD</em> assign them the URI of a description of
the relevant service. Processors <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> define short form notations as an
authoring convenience (e.g., "scxml" as equivalent to
http://www.w3.org/TR/scxml/).</p>

<p>A conformant SCXML document <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> specify either the 'id' or 'idlocation'
attribute, but <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em> specify both. If the 'idlocation'
attribute is present, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> generate
an id automatically when the &lt;invoke&gt; element is evaluated
and store it in the location specified by 'idlocation'. (In the
rest of this document, we will refer to this identifier as the
"invokeid", regardless of whether it is specified by the author or
generated by the platform). The automatically generated identifier
<em title="MUST in RFC2119 context" class="RFC2119">MUST</em> have
the form <em>stateid.platformid</em>, where <em>stateid</em> is the
id of the state containing this element and <em>platformid</em> is
automatically generated. <em>platformid</em> <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> be unique
within the current session.</p>

<p>When the &lt;invoke&gt; element is executed, if the evaluation
of its arguments produces an error, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> terminate
the processing of the element without further action. Otherwise the
Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> start a new logical instance of the
external service specified in 'type' or 'typeexpr', passing it the
URL specified by 'src' or the data specified by &lt;content&gt;,
"namelist" or &lt;param&gt;. (Note that the invoked service may
ignore some or all of the data passed to it. See <a href="http://www.w3.org/TR/scxml/#invokeimplementation"><em>6.4.3 Implementation of
&lt;invoke&gt;</em></a> for a discussion of how the passed data is
treated by an invoked SCXML service.) The service instance <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> be local or
remote. In addition to the explicit arguments, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> keep
track of the unique invokeid and ensure that it is included in all
events that the invoked service returns to the invoking
session.</p>

<p>When the 'autoforward' attribute is set to true, the SCXML
Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> send an exact copy of every external
event it receives to the invoked process. All the fields specified
in <a href="http://www.w3.org/TR/scxml/#InternalStructureofEvents"><em>5.10.1 The Internal
Structure of Events</em></a> <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> have the same values in the forwarded
copy of the event. The SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> forward
the event at the point at which it removes it from the external
event queue of the invoking session for processing.</p>

<p>The external service <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> return multiple events while it is
processing. If there is a &lt;finalize&gt; handler in the instance
of &lt;invoke&gt; that created the service that generated the
event, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> execute the code in that &lt;finalize&gt;
handler right before it removes the event from the event queue for
processing. It <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em> execute the &lt;finalize&gt; handler
in any other instance of &lt;invoke&gt;. Once the external service
has finished processing it <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> return a special event
'done.invoke.<em>id</em>' to the external event queue of the
invoking process, where <em>id</em> is the invokeid for the
corresponding &lt;invoke&gt; element. The external service <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em>
generate any other events after this done event. If the invoking
session takes a transition out of the state containing the
&lt;invoke&gt; before it receives the 'done.invoke.<em>id</em>'
event, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> automatically cancel the invoked
component and stop its processing. The cancel operation <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> act as if
it were the final &lt;onexit&gt; handler in the invoking state.</p>

<p>Invoked services of type http://www.w3.org/TR/scxml/,
http://www.w3.org/TR/ccxml/, http://www.w3.org/TR/voicexml30/, or
http://www.w3.org/TR/voicexml21/ <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> interpret
values specified by the &lt;content&gt; element or 'src' attribute
as markup to be executed. Similarly, they <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> interpret
values specified by &lt;param&gt; element or 'namelist' attribute
as values that are to be injected into their data models. For
targets of other invoked service types, the interpretation of
&lt;param&gt; and &lt;content&gt; elements and the 'src' and
'namelist' attributes is platform-specific. However, these services
<em title="MUST in RFC2119 context" class="RFC2119">MUST</em> treat
values specified by &lt;param&gt; and namelist identically. They
<em title="MUST in RFC2119 context" class="RFC2119">MUST</em> also
treat values specified by 'src' and &lt;content&gt;
identically.</p>

<div class="div3">
<h4><a id="invokeimplementation" name="invokeimplementation">6.4.3 Implementation of
&lt;invoke&gt;</a></h4><a id="invokeimplementation" name="invokeimplementation">

<p>The implementation of &lt;invoke&gt;, including communication
between parent and child processes, is platform-specific, but the
following requirements hold in the case where the invoked process
is itself an SCXML session:</p>

</a><ul><a id="invokeimplementation" name="invokeimplementation">
<li>If the 'name' of a &lt;param&gt; element in the &lt;invoke&gt;
matches the 'id' of a &lt;data&gt; element in the top-level data
declarations of the invoked session, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> use the
value of the &lt;param&gt; element as the initial value of the
corresponding &lt;data&gt; element. (The top-level data
declarations are those that are contained in the &lt;datamodel&gt;
element that is a child of &lt;scxml&gt;.) (Note that this means
that any value specified in the &lt;data&gt; element is ignored.)
The behavior of 'namelist' is similar. If the value of a key in the
namelist matches the 'id' of a &lt;data&gt; element in the
top-level data model of the invoked session, the SCXML Processor
<em title="MUST in RFC2119 context" class="RFC2119">MUST</em> use
the value of the key as the initial value of the corresponding
&lt;data&gt; element. If the names do not match, the Processor <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em>
add the value of the &lt;param&gt; element or namelist key/value
pair to the invoked session's data model. However the Processor <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> make the
values available by some other platform-specific means.</li>

<li>When the invoked state machine reaches a top-level final state,
the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place the event done.invoke.<em>id</em>
on the external event queue of the invoking machine, where
<em>id</em> is the invokeid for this invocation. Note that reaching
a top level final state corresponds to normal termination of the
machine and that it cannot generate or process any further events
once it is in this state.</li>

<li>As described above, if the invoking state machine exits the
state containing the invocation before it receives the
done.invoke.<em>id</em> event, it cancels the invoked session. The
method for doing this is platform-specific. However, when it is
cancelled, the invoked session <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> exit at the end of the next microstep.
The Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> execute the &lt;onexit&gt; handlers for
all active states in the invoked session, but it <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em>
generate the done.invoke.<em>id</em> event. Once it cancels the
invoked session, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> ignore any events it receives from that
session. In particular it <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em> not insert them into the external
event queue of the invoking session.</li>

</a><li><a id="invokeimplementation" name="invokeimplementation">The SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> support the use of SCXML Event/IO
processor (</a><a href="http://www.w3.org/TR/scxml/#SCXMLEventProcessor"><em>C.1 SCXML Event I/O
Processor</em></a>) to communicate between the invoking and the
invoked sessions. The Processor <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> support the use of other Event/IO
processors to communicate between the invoking and the invoked
sessions.</li>
</ul>
</div>

<div class="div3">
<h4><a id="DataSharing" name="DataSharing">6.4.4 Data
Sharing</a></h4><a id="DataSharing" name="DataSharing">

<p>[This section is informative.]</p>

<p>The invoked external resource is logically separate from the
state machine that invokes it and does not share data with it
unless the author explicitly requests this with the &lt;param&gt;
or &lt;content&gt; elements and/or the 'src' and 'namelist'
attributes.</p>

<p>The invoked and invoking process can also communicate via
events. In addition to automatic forwarding specified by the
'autoforward' attribute. SCXML scripts can also use the
&lt;send&gt; tag to send messages to the child process on an ad-hoc
basis. The 'type' attribute of &lt;send&gt; is set to the same
value as was used in the original &lt;invoke&gt;, while the target
has the special form #_<em>invokeid</em>, where <em>invokeid</em>
is the identifier corresponding to the original &lt;invoke&gt; tag.
For example, in a document using ECMAScript as the data model, the
following code would invoke a VoiceXML session:</p>

<div class="exampleInner">
<pre>  &lt;invoke type="http://www.w3.org/TR/voicexml21/" idlocation="myInvoke"/&gt;
      
</pre>
</div>

<p>In this case, the unique invoke identifier has been stored in
the data model location MyInvoke. Since the target attribute is an
expression which is evaluated, the following code will extract that
identifier and send a message to the invoked VoiceXML session:</p>

<div class="exampleInner">
<pre>         
  &lt;send type="http://www.w3.org/TR/voicexml21/" targetexpr="'#_' + myInvoke"/&gt;
           
</pre>
</div>

<p>Finally, in the case where the invoked external service is an
SCXML session, it can use &lt;send&gt; with the special target
'_parent' and type 'scxml' to send events, possibly containing
data, to the invoking session.</p>
</a></div><a id="DataSharing" name="DataSharing">
</a></div><a id="DataSharing" name="DataSharing">

</a><div class="div2"><a id="DataSharing" name="DataSharing">
</a><h3><a id="DataSharing" name="DataSharing"></a><a id="finalize" name="finalize">6.5 &lt;finalize&gt;</a></h3><a id="finalize" name="finalize">

<p>[This section is normative.]</p>

<p>The &lt;finalize&gt; element enables an invoking session to
update its data model with data contained in events returned by the
invoked session. &lt;finalize&gt; contains executable content that
is executed whenever the external service returns an event after
the &lt;invoke&gt; has been executed. This content is applied
before the system looks for transitions that match the event.
Within the executable content, the system variable '_event' can be
used to refer to the data contained in the event which is being
processed.In the case of parallel states, only the finalize code in
the original invoking state is executed.</p>

</a><div class="div3"><a id="finalize" name="finalize">
</a><h4><a id="finalize" name="finalize"></a><a id="N110EA" name="N110EA">6.5.1 Attribute Details</a></h4><a id="N110EA" name="N110EA">

<p>None.</p>
</a></div><a id="N110EA" name="N110EA">

</a><div class="div3"><a id="N110EA" name="N110EA">
</a><h4><a id="N110EA" name="N110EA"></a><a id="N110EF" name="N110EF">6.5.2 Children</a></h4><a id="N110EF" name="N110EF">

<p>&lt;finalize&gt;'s children consist of 0 or more elements of
executable content.</p>
</a></div><a id="N110EF" name="N110EF">

<p>In a conformant SCXML document, the executable content inside
&lt;finalize&gt; <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em> raise events or invoke external
actions. In particular, the &lt;send&gt; and &lt;raise&gt; elements
<em title="MUST NOT in RFC2119 context" class="RFC2119">MUST
NOT</em> occur.</p>

<p>If one or more elements of executable content is specified, the
SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> execute them each time an event is
received from the child process that was created by the parent
&lt;invoke&gt; element. The Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> execute
them right before the event is pulled off the external event queue
for processing. The Processor <em title="MUST NOT in RFC2119 context" class="RFC2119">MUST NOT</em>
execute them at any other time or in response to any other
events.</p>

<p>If no executable content is specified, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> update
the data model each time an event is received from the child
process that was created by the parent &lt;invoke&gt; element.
Specifically if the parent &lt;invoke&gt; element contains a
'namelist' attribute or one or more &lt;param&gt; children
containing 'location' attributes, then for each item in the
'namelist' attribute and each such &lt;param&gt; element, the
Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> update the corresponding location as if
by &lt;assign&gt; with any return value that has a name that
matches the 'namelist' item or the 'name' of the &lt;param&gt;
element. Thus the effect of an &lt;invoke&gt; with an empty
&lt;finalize&gt; element and either a 'namelist' attribute or a
&lt;param&gt; element with a 'location' attribute is first to send
the part of the data model specified by 'namelist' or 'location' to
the invoked component and then to update that part of the data
model with any returned values that have the same name. Note that
the automatic update does not take place if the &lt;finalize&gt;
element is absent as opposed to empty.</p>

<p>In the example below, a state machine using an ECMAScript data
model invokes a clock object that returns the current time in a
ping event with an XML payload that includes the currentSecond,
currentMinute, currentHour (1-12), and an isAm flag.
&lt;finalize&gt; maps this data into an ECMAScript date object that
is used in the condition of a transition. Thus &lt;finalize&gt;
normalizes the data before the conditions on transitions are
evaluated.</p>

<div class="exampleInner">
<pre>&lt;scxml version="1.0" datamodel="ecmascript"&gt;
....
 &lt;state id=”getTime”&gt;
   &lt;transition event=”ping” cond=”time.getHours() &gt; 17 || time.getHours() &lt; 9” target=”storeClosed”/&gt;
   &lt;transition event=”ping” target=”takeOrder”/&gt;
   &lt;datamodel&gt;
     &lt;data id=”time” expr=”new Date()”/&gt;
   &lt;/datamodel&gt;
   &lt;invoke id=”timer” type=”x-clock” src=”clock.pl”&gt;
     &lt;finalize&gt;
       &lt;script&gt;
         time.setSeconds(_event.data.currentSecond);
         time.setMinutes(_event.data.currentMinute);
         time.setHours(_event.data.currentHour + (_event.isAm ? 0 : 12) - 1);
       &lt;/script&gt;
     &lt;/finalize&gt;
   &lt;/invoke&gt;
 &lt;/state&gt;
....

</pre>
</div>
</a></div><a id="N110EF" name="N110EF">
</a></div><a id="N110EF" name="N110EF">
</a></div><a id="N110EF" name="N110EF">

</a><div class="back"><a id="N110EF" name="N110EF">
</a><div class="div1"><a id="N110EF" name="N110EF">
</a><h2><a id="N110EF" name="N110EF"></a><a id="conformance" name="conformance">A Conformance</a></h2><a id="conformance" name="conformance">

<p>[This section is normative.]</p>

</a><div class="div2"><a id="conformance" name="conformance">
</a><h3><a id="conformance" name="conformance"></a><a id="ConformingDocuments" name="ConformingDocuments">A.1
Conforming Documents</a></h3><a id="ConformingDocuments" name="ConformingDocuments">

<p>The following conformance requirements hold for all SCXML
documents.</p>

</a><ol class="enumar"><a id="ConformingDocuments" name="ConformingDocuments">
<li>The root element of the document <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> be
&lt;scxml&gt;.</li>

<li>The &lt;scxml&gt; element <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> include a "version" attribute with the
value "1.0".</li>

</a><li><a id="ConformingDocuments" name="ConformingDocuments">The &lt;scxml&gt; element <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> designate the SCXML namespace. This can
be achieved by declaring an "xmlns" attribute or an attribute with
an "xmlns" prefix </a><a href="http://www.w3.org/TR/scxml/#XMLNames">[XMLNames]</a>. The namespace
for SCXML is defined to be http://www.w3.org/2005/07/scxml.</li>

<li>The document <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> conform to all the syntactic constraints
defined in this specification, including those contained in the
schema, those contained in the "Attribute Constraints" and "Valid
Values" fields in the attribute tables, and those contained in the
definition of its children.</li>

<li>The document <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> conform to any additional syntactic
constraints that are defined for the data model that it has chosen.
See <a href="http://www.w3.org/TR/scxml/#profiles"><em>B Data Models</em></a> for the
definition of the individual data models.</li>
</ol>
</div>

<div class="div2">
<h3><a id="ConformingProcessors" name="ConformingProcessors">A.2
Conforming Processors</a></h3><a id="ConformingProcessors" name="ConformingProcessors">

<p>A SCXML 1.0 processor is a user agent that can parse and process
Conforming SCXML 1.0 documents.</p>

</a><p><a id="ConformingProcessors" name="ConformingProcessors">In a Conforming SCXML 1.0 Processor, the XML parser <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> be able
to parse and process all well-formed XML constructs defined within
</a><a href="http://www.w3.org/TR/scxml/#XML">[XML]</a> and <a href="http://www.w3.org/TR/scxml/#XMLNames">[XMLNames]</a>. It
is not required that a Conforming SCXML 1.0 processor use a
validating parser.</p>

<p>A Conforming SCXML 1.0 Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> support
the syntax and semantics of all mandatory SCXML elements described
in this document. A Conforming SCXML 1.0 Processor <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> support the
syntax and semantics of any optional SCXML elements described in
this document.</p>

<p>When a Conforming SCXML 1.0 Processor encounters a
non-conformant document, or one containing non-SCXML elements or
attributes which are proprietary, or defined in a non-SCXML
namespace, its behavior is undefined.</p>

<p>There is no conformance requirement with respect to performance
characteristics of the SCXML 1.0 Processor.</p>
</div>
</div>

<div class="div1">
<h2><a id="profiles" name="profiles">B Data Models</a></h2><a id="profiles" name="profiles">

<p>[This section is normative.]</p>

<p>The 'datamodel' attribute on &lt;scxml&gt; defines the data
model that the document uses. The data model includes the
underlying data structure plus languages for boolean expressions,
location expressions, value expressions, and scripting. A
conformant SCXML document <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> specify the data model it uses. Conformant
SCXML processors <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> support the null data model, and <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> support
other data models, including the ECMAScript and XPath data models.
The ECMAScript and XPath model definitions given here are normative
in the sense that they define how implementations that support one
of these languages <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> behave. The intent is to ensure
interoperability among all processors that support ECMAScript, and
all those that support XPath, without requiring all implementations
to support either of those data model languages.</p>

<p>The definition of a data model <em title="MUST in RFC2119 context" class="RFC2119">MUST</em>:</p>

<ul>
<li>Specify the boolean expression language used as the value of
the 'cond' attribute in &lt;transition&gt;, &lt;if&gt; and
&lt;elseif&gt; This language <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> not have side effects and <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> include
the predicate 'In', which takes a single argument, the id of a
state in the enclosing state machine, and returns 'true' if the
state machine is in that state.</li>

<li>Specify the location expression language that is used as the
value of the 'location' attribute of the &lt;assign&gt; tag.</li>

<li>Specify the value expression language that is used as the value
of the 'expr' attribute of the &lt;data&gt; and &lt;assign&gt;
elements.</li>

<li>Specify the scripting language used inside the &lt;script&gt;
element</li>
</ul>

</a><div class="div2"><a id="profiles" name="profiles">
</a><h3><a id="profiles" name="profiles"></a><a id="minimal-profile" name="minimal-profile">B.1 The Null
Data Model</a></h3><a id="minimal-profile" name="minimal-profile">

<p>The value "null" for the 'datamodel' attribute results in an
absent or empty data model. In particular:</p>

</a><div class="div3"><a id="minimal-profile" name="minimal-profile">
</a><h4><a id="minimal-profile" name="minimal-profile"></a><a id="N1118D" name="N1118D">B.1.1 Data Model</a></h4><a id="N1118D" name="N1118D">

<p>There is no underlying data model.</p>
</a></div><a id="N1118D" name="N1118D">

</a><div class="div3"><a id="N1118D" name="N1118D">
</a><h4><a id="N1118D" name="N1118D"></a><a id="N11192" name="N11192">B.1.2 Conditional
Expressions</a></h4><a id="N11192" name="N11192">

<p>The boolean expression language consists of the In predicate
<em>only</em>. It has the form 'In(<em>id</em>)', where <em>id</em>
is the id of a state in the enclosing state machine. The predicate
<em title="MUST in RFC2119 context" class="RFC2119">MUST</em>
return 'true' if and only if that state is in the current state
configuration.</p>
</a></div><a id="N11192" name="N11192">

</a><div class="div3"><a id="N11192" name="N11192">
</a><h4><a id="N11192" name="N11192"></a><a id="N111A3" name="N111A3">B.1.3 Location Expressions</a></h4><a id="N111A3" name="N111A3">

<p>There is no location expression language.</p>
</a></div><a id="N111A3" name="N111A3">

</a><div class="div3"><a id="N111A3" name="N111A3">
</a><h4><a id="N111A3" name="N111A3"></a><a id="N111A8" name="N111A8">B.1.4 Value Expressions</a></h4><a id="N111A8" name="N111A8">

<p>There is no value expression language.</p>
</a></div><a id="N111A8" name="N111A8">

</a><div class="div3"><a id="N111A8" name="N111A8">
</a><h4><a id="N111A8" name="N111A8"></a><a id="N111AD" name="N111AD">B.1.5 Scripting</a></h4><a id="N111AD" name="N111AD">

<p>There is no scripting language.</p>
</a></div><a id="N111AD" name="N111AD">

</a><div class="div3"><a id="N111AD" name="N111AD">
</a><h4><a id="N111AD" name="N111AD"></a><a id="N111B2" name="N111B2">B.1.6 System Variables</a></h4><a id="N111B2" name="N111B2">

<p>System variables are not accessible.</p>
</a></div><a id="N111B2" name="N111B2">

</a><div class="div3"><a id="N111B2" name="N111B2">
</a><h4><a id="N111B2" name="N111B2"></a><a id="N111B7" name="N111B7">B.1.7 Unsupported Elements</a></h4><a id="N111B7" name="N111B7">

</a><p><a id="N111B7" name="N111B7">The &lt;foreach&gt; element and the elements defined in </a><a href="http://www.w3.org/TR/scxml/#data-module"><em>5 Data Model and Data Manipulation</em></a>
are not supported in the Null Data Model.</p>
</div>
</div>

<div class="div2">
<h3><a id="ecma-profile" name="ecma-profile">B.2 The ECMAScript
Data Model</a></h3><a id="ecma-profile" name="ecma-profile">

</a><p><a id="ecma-profile" name="ecma-profile">The value 'ecmascript' for the 'datamodel' attribute results in
an ECMAScript data model. Implementations that support this value
<em title="MUST in RFC2119 context" class="RFC2119">MUST</em>
support the third edition of ECMAScript </a><a href="http://www.w3.org/TR/scxml/#ECMAScript262">[ECMASCRIPT-262]</a>. Implementations <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> support
JSON <a href="http://www.w3.org/TR/scxml/#JSON">[RFC 4627]</a> or ECMAScript for XML (E4X) <a href="http://www.w3.org/TR/scxml/#E4X">[E4X]</a>.</p>

<div class="div3">
<h4><a id="ecma_core_module" name="ecma_core_module">B.2.1 Data
Model</a></h4><a id="ecma_core_module" name="ecma_core_module">

<p>For each &lt;data&gt; element in the document, the SCXML
Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> create an ECMAScript variable object
whose name is the value of the 'id' attribute of
<code>&lt;data&gt;</code>. In cases where the 'src' attribute or
in-line content is provided in the &lt;data&gt; element, then if an
indication of the type of the content is available (e.g., via a
Content-Type header), then the Processor <em title="SHOULD in RFC2119 context" class="RFC2119">SHOULD</em> try
to interpret the content according to that indication. Otherwise if
the content (whether fetched or provided in-line) is JSON (and the
Processor supports JSON), the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> create
the corresponding ECMAScript object. Otherwise, if the content is a
valid XML document, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> create
the corresponding DOM structure and assign it as the value of the
variable. Otherwise the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> treat the
content as a space-normalized string literal and assign it as the
value of the variable. If no value is assigned, the SCXML Processor
<em title="MUST in RFC2119 context" class="RFC2119">MUST</em>
assign the variable the default value ECMAScript undefined. Note
that the assignment takes place at the time indicated by the
'binding' attribute on the &lt;scxml&gt; element.</p>

</a><div class="exampleOuter"><a id="ecma_core_module" name="ecma_core_module">
</a><div class="exampleHeader"><a id="ecma_core_module" name="ecma_core_module"></a><a id="N111EF" name="N111EF">Example:
Datamodel &lt;data&gt; initialization</a></div><a id="N111EF" name="N111EF">

<div class="exampleInner">
<pre>&lt;scxml version="1.0" xmlns="http://www.w3.org/2005/07/scxml" datamodel="ecmascript"&gt;
  &lt;datamodel&gt;
   &lt;data id="employees" src="http://example.com/employees.json"/&gt;
   &lt;data id="year" expr="2008"/&gt;
   &lt;data id="CEO" expr="'Mr Big'"/&gt;
   &lt;data id="profitable" expr="true"/&gt;
  &lt;/datamodel&gt;
&lt;/scxml&gt;
</pre>
</div>
</a></div><a id="N111EF" name="N111EF">
</a></div><a id="N111EF" name="N111EF">

</a><div class="div3"><a id="N111EF" name="N111EF">
</a><h4><a id="N111EF" name="N111EF"></a><a id="ecma-scoping" name="ecma-scoping">B.2.2 Scoping</a></h4><a id="ecma-scoping" name="ecma-scoping">

<p>The Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place all variables in a single global
ECMAScript scope. Specifically, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> allow any
data element to be accessed from any state. Ordering dependencies
between &lt;data&gt; elements are not permitted. In the case of
early binding, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> evaluate
all &lt;data&gt; elements at initialization time but <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> do so in
any order it chooses. When late binding is selected, the SCXML
Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> create data model elements at
initialization time but <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> do so in any order it chooses. Similarly,
the processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> assign the specified initial values to
data elements only when the state containing them is first entered,
but <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> do
so in any order it chooses.</p>
</a></div><a id="ecma-scoping" name="ecma-scoping">

</a><div class="div3"><a id="ecma-scoping" name="ecma-scoping">
</a><h4><a id="ecma-scoping" name="ecma-scoping"></a><a id="ecma_cond_expressions" name="ecma_cond_expressions">B.2.3 Conditional Expressions</a></h4><a id="ecma_cond_expressions" name="ecma_cond_expressions">

</a><p><a id="ecma_cond_expressions" name="ecma_cond_expressions">The Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> convert ECMAScript expressions used in
conditional expressions into their effective boolean value using
the ToBoolean operator as described in Section 9.2 of </a><a href="http://www.w3.org/TR/scxml/#ECMAScript262">[ECMASCRIPT-262]</a>.</p>

<p>The following example illustrates this usage.</p>

<div class="exampleOuter">
<div class="exampleHeader"><a id="N11221" name="N11221">Example:
Use of a boolean expression to determine whether or not a
transition is taken.</a></div><a id="N11221" name="N11221">

<div class="exampleInner">
<pre>&lt;state id="errorSwitch"&gt;
  &lt;datamodel&gt;
   &lt;data id="time"/&gt;
  &lt;/datamodel&gt;
        
  &lt;onentry&gt;
    &lt;assign location="time" expr="currentDateTime()"/&gt;
  &lt;/onentry&gt;
          
  &lt;transition cond="yearFromDatetime(time) &gt; 2009" target="newBehavior"/&gt;
 
  &lt;transition target="currentBehavior"/&gt;
&lt;/state&gt;
</pre>
</div>
</a></div><a id="N11221" name="N11221">

</a><p><a id="N11221" name="N11221">The SCXML processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> define an ECMAScript function named
'In()' that takes a stateID as its argument and returns 'true' if
and only if that state is in the current state configuration, as
described in </a><a href="http://www.w3.org/TR/scxml/#ConditionalExpressions"><em>5.9.1
Conditional Expressions</em></a>. Here is an example of its use,
taken from <a href="http://www.w3.org/TR/scxml/#MicrowaveParallel"><em>G.3 Microwave Example
(Using parallel)</em></a> below:</p>

<div class="exampleOuter">
<div class="exampleInner">
<pre> 
  &lt;transition cond="In('closed')" target="cooking"/&gt;
</pre>
</div>
</div>
</div>

<div class="div3">
<h4><a id="ecma_location_expressions" name="ecma_location_expressions">B.2.4 Location Expressions</a></h4><a id="ecma_location_expressions" name="ecma_location_expressions">

<p>The SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> accept any ECMAScript left-hand-side
expression as a location expression. The following example
illustrates this usage. (Note that the example assumes that the
data loaded from http://example.com/employees.json creates the
necessary data structure, so that employees.employee[12].salary
exists when &lt;assign&gt; is evaluated. If it didn't, the
Processor would raise error.execution and the &lt;assign&gt; would
have no effect.)</p>

</a><div class="exampleOuter"><a id="ecma_location_expressions" name="ecma_location_expressions">
</a><div class="exampleHeader"><a id="ecma_location_expressions" name="ecma_location_expressions"></a><a id="N1123F" name="N1123F">Example:
Use of the location attribute of the assign to update the salary of
an employee.</a></div><a id="N1123F" name="N1123F">

<div class="exampleInner">
<pre>&lt;state id="errorSwitch"&gt;
    &lt;datamodel&gt;
      &lt;data id="employees" src="http://example.com/employees.json"/&gt;
    &lt;/datamodel&gt;
    
    &lt;onentry&gt;
        &lt;assign location="employees.employee[12].salary" expr="42000"/&gt;
    &lt;/onentry&gt;
&lt;/state&gt;
</pre>
</div>
</a></div><a id="N1123F" name="N1123F">
</a></div><a id="N1123F" name="N1123F">

</a><div class="div3"><a id="N1123F" name="N1123F">
</a><h4><a id="N1123F" name="N1123F"></a><a id="ecma_value_expressions" name="ecma_value_expressions">B.2.5 Value Expressions</a></h4><a id="ecma_value_expressions" name="ecma_value_expressions">

<p>The SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> accept any ECMAScript expression as a
value expression.</p>

</a><div class="exampleOuter"><a id="ecma_value_expressions" name="ecma_value_expressions">
</a><div class="exampleHeader"><a id="ecma_value_expressions" name="ecma_value_expressions"></a><a id="N1124E" name="N1124E">Example:
Copying event data into the local data model for the state.</a></div><a id="N1124E" name="N1124E">

<div class="exampleInner">
<pre>&lt;state id="processEvent"&gt;
    &lt;datamodel&gt;
        &lt;data id="myEvent"/&gt;
    &lt;/datamodel&gt;
    
    &lt;onentry&gt;
        &lt;assign location="myEvent" expr="_event.data"/&gt;
    &lt;/onentry&gt;
&lt;/state&gt;
</pre>
</div>
</a></div><a id="N1124E" name="N1124E">
</a></div><a id="N1124E" name="N1124E">

</a><div class="div3"><a id="N1124E" name="N1124E">
</a><h4><a id="N1124E" name="N1124E"></a><a id="ecma_inline_content" name="ecma_inline_content">B.2.6
&lt;content&gt;</a></h4><a id="ecma_inline_content" name="ecma_inline_content">

</a><p><a id="ecma_inline_content" name="ecma_inline_content">When &lt;content&gt; is a child of &lt;donedata&gt;, the
Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> interpret its value as defined in </a><a href="http://www.w3.org/TR/scxml/#ecma_eventdata"><em>B.2.8.1 _event.data</em></a>. When
&lt;content&gt; is a child of &lt;send&gt;, the interpretation of
its value depends on the Event I/O Processor. When &lt;content&gt;
is a child of &lt;invoke&gt;, the interpretation of its value is
platform-specific.</p>
</div>

<div class="div3">
<h4><a id="ecma_assign" name="ecma_assign">B.2.7
&lt;assign&gt;</a></h4><a id="ecma_assign" name="ecma_assign">

<p>When evaluating an &lt;assign&gt; element in the ECMAScript data
model, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> replace the existing value at 'location'
with the value produced by evaluating 'expr'. If it is unable to do
so (for example, if the &lt;assign&gt; element attempts to assign
to a read-only attribute), it <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place the error error.execution on the
internal event queue.</p>
</a></div><a id="ecma_assign" name="ecma_assign">

</a><div class="div3"><a id="ecma_assign" name="ecma_assign">
</a><h4><a id="ecma_assign" name="ecma_assign"></a><a id="ecma_system_variables" name="ecma_system_variables">B.2.8 System Variables</a></h4><a id="ecma_system_variables" name="ecma_system_variables">

</a><p><a id="ecma_system_variables" name="ecma_system_variables">The SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> define an ECMAScript read-only variable
for each system variable defined in </a><a href="http://www.w3.org/TR/scxml/#SystemVariables"><em>5.10 System Variables</em></a>. The
<code>_sessionid</code> and <code>_name</code> system variables are
defined as variables with ECMAScript String values. The
<code>_event</code> system variable is defined as an object with
properties for each of the fields defined in <a href="http://www.w3.org/TR/scxml/#InternalStructureofEvents"><em>5.10.1 The Internal Structure
of Events</em></a>: <code>name</code>,<code>type</code>,
<code>sendid</code>, <code>origin</code>, <code>origintype</code>,
and <code>invokeid</code> are String values, while
<code>data</code> can be of any type. In cases where this
specification does not specify a value for one of these fields or
states that the field is empty or has no value, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> set the
value to ECMAScript undefined. As the value of the _ioprocessors
system variable the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> create an object with a named property
for each Event I/O processor that it supports, where the name of
the property is the same as that of the I/O processor and the value
of the property is an object that represents the I/O processor. For
the SCXML and BasicHTTP Event I/O processors, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> create a
"location" property under that object, assigning the access URI as
its String value. For example, in systems that support the
BasicHTTP Event I/O Processor, the access URI of the BasicHTTP
Event I/O processor can be accessed as
_ioprocessors['http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor'].location.</p>

<div class="div4">
<h5><a id="ecma_eventdata" name="ecma_eventdata">B.2.8.1
_event.data</a></h5><a id="ecma_eventdata" name="ecma_eventdata">

<p>_event.data is populated with content provided by an external
event or by &lt;param&gt; or &lt;content&gt;. In some
circumstances, the entity that generated the event may have
indicated how the data is to be interpreted. In such cases, the
Processor <em title="SHOULD in RFC2119 context" class="RFC2119">SHOULD</em> try to format the data according to
those indications. Otherwise, if the SCXML Processsor can interpret
the content as key-value pairs, then for each unique key, the
Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> create a property of _event.data whose
name is the name of the key-value pair and whose value is the value
of the key-value pair. In the case of duplicate keys, the behavior
is platform-specific. (Note that content specified by &lt;param&gt;
or delivered as POST parameters via the BasicHTTP Event I/O
Processor consists unambiguously of key-value pairs.) Otherwise
(i.e., if the content does not consist of key-value pairs), if the
Processor supports JSON and it can interpret the content as JSON,
it <em title="MUST in RFC2119 context" class="RFC2119">MUST</em>
create the corresponding ECMAScript object(s) as the value of
_event.data. Otherwise, if the Processor can interpret the content
as a valid XML document, it <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> create the corresponding DOM structure
and assign it as the value _event.data. Otherwise, the Processor
<em title="MUST in RFC2119 context" class="RFC2119">MUST</em> treat
the content as a space-normalized string literal and assign it as
the value of _event.data.</p>
</a></div><a id="ecma_eventdata" name="ecma_eventdata">

<p>Suppose as part of executing a state machine named "myName" with
a platform-assigned sessionid "12345", we are processing an event
with the name "foo.bar" and the following object payload:</p>

<div class="exampleOuter">
<div class="exampleInner">
<pre>    { "answer" : 42 }

</pre>
</div>
</div>

<p>Then the underlying ECMAScript data model would have the
following form:</p>

</a><div class="exampleOuter"><a id="ecma_eventdata" name="ecma_eventdata">
</a><div class="exampleHeader"><a id="ecma_eventdata" name="ecma_eventdata"></a><a id="N112BF" name="N112BF">Example:
Illustration of system injected properties</a></div><a id="N112BF" name="N112BF">

<div class="exampleInner">
<pre>{
  // The four properties below are automatically populated by the system

  "_name"      : "myName" ,
  "_sessionid" : "12345"  ,
  "_event"     : {
                    "name" : "foo.bar" ,
                    "data" : {
                               "answer"  :  42
                             }
                 } ,
  "_ioprocessors" : {
  "http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor" : {
  "location" : "http://example.com/scxml-http/12345"
}
  "http://www.w3.org/TR/scxml/#SCXMLEventProcessor" :  {
  "location" : "http://example.com/scxml-http/23456"
}
} , 

  // Rest of the application / developer-authored data model goes here
}

</pre>
</div>
</a></div><a id="N112BF" name="N112BF">

<p>As an example, here is a sample transition that accesses the
<code>_event</code> variable in that data model.</p>

</a><div class="exampleOuter"><a id="N112BF" name="N112BF">
</a><div class="exampleHeader"><a id="N112BF" name="N112BF"></a><a id="N112CA" name="N112CA">Example:
Accessing system _event name in a condition</a></div><a id="N112CA" name="N112CA">

<div class="exampleInner">
<pre>&lt;state id="checkEventName"&gt;
    &lt;transition cond="_event.name=='foo.bar'" target="nextState"&gt;
     ...
    &lt;/transition&gt;
&lt;/state&gt;
</pre>
</div>
</a></div><a id="N112CA" name="N112CA">
</a></div><a id="N112CA" name="N112CA">

</a><div class="div3"><a id="N112CA" name="N112CA">
</a><h4><a id="N112CA" name="N112CA"></a><a id="ecma-serialization" name="ecma-serialization">B.2.9
Serialization</a></h4><a id="ecma-serialization" name="ecma-serialization">

<p>In certain circumstances, e.g. when including data in events
sent via the BasicHTTP Event I/O Processor, the SCXML Processor is
required to serialize data from the ECMAScript data model for
transmission to a remote entity. In such cases, if the Processor
supports JSON, and is able to serialize the data in sufficient
detail to allow its reconstruction, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> serialize
the data to JSON. Otherwise, the Processor <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> use
platform-specific methods (including JSON despite the loss of
information) to serialize the data. The Processor <em title="SHOULD in RFC2119 context" class="RFC2119">SHOULD</em>
provide a warning if the serialization entails loss of information
or if it is unable to serialize at all.</p>
</a></div><a id="ecma-serialization" name="ecma-serialization">

</a><div class="div3"><a id="ecma-serialization" name="ecma-serialization">
</a><h4><a id="ecma-serialization" name="ecma-serialization"></a><a id="ecma_script_module" name="ecma_script_module">B.2.10
Scripting</a></h4><a id="ecma_script_module" name="ecma_script_module">

</a><p><a id="ecma_script_module" name="ecma_script_module">The SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> accept any ECMAScript program as defined
in Section 14 of </a><a href="http://www.w3.org/TR/scxml/#ECMAScript262">[ECMASCRIPT-262]</a> as
the content of a &lt;script&gt; element.</p>
</div>

<div class="div3">
<h4><a id="ecma_foreach" name="ecma_foreach">B.2.11
&lt;foreach&gt;</a></h4><a id="ecma_foreach" name="ecma_foreach">

<p>In the ECMAScript data model, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> support
iteration over objects that satisfy instanceof(Array) in
ECMAScript. It <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> support iteration over other types of
objects. The legal values for the 'item' attribute are legal
ECMAScript variable names. In cases where ECMAScript specification
defines the iteration order for the object, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> follow
that ordering. (For arrays and strings, this goes from 0 to
length-1.) In cases where the ECMAScript specification does not
define the iteration order, the Processor <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> follow any
order that it chooses as long as 1) it iterates over the object's
own enumerable properties only 2) it visits each such property once
and only once. Note that since the Processor is required to behave
as if it has made a shallow copy, in the case of an array
&lt;foreach&gt; assignment is equivalent to item =
array_name[index] in ECMAScript. Note also that the assigned value
could be undefined for a sparse array.</p>

</a><div class="exampleOuter"><a id="ecma_foreach" name="ecma_foreach">
</a><div class="exampleHeader"><a id="ecma_foreach" name="ecma_foreach"></a><a id="N112FD" name="N112FD">Example:
Logging ISBN of all books in bookstore shopping cart</a></div><a id="N112FD" name="N112FD">

<div class="exampleInner">
<pre>&lt;foreach array="cart.books" item="book"&gt;
&lt;log expr="'Cart contains book with ISBN ' + book.isbn"/&gt;
&lt;/foreach&gt;
</pre>
</div>
</a></div><a id="N112FD" name="N112FD">
</a></div><a id="N112FD" name="N112FD">
</a></div><a id="N112FD" name="N112FD">
</a></div><a id="N112FD" name="N112FD">

</a><div class="div1"><a id="N112FD" name="N112FD">
</a><h2><a id="N112FD" name="N112FD"></a><a id="eventioprocessors" name="eventioprocessors">C Event
I/O Processors</a></h2><a id="eventioprocessors" name="eventioprocessors">

<p>[This section is normative.]</p>

</a><div class="div2"><a id="eventioprocessors" name="eventioprocessors">
</a><h3><a id="eventioprocessors" name="eventioprocessors"></a><a id="SCXMLEventProcessor" name="SCXMLEventProcessor">C.1
SCXML Event I/O Processor</a></h3><a id="SCXMLEventProcessor" name="SCXMLEventProcessor">

<p>The SCXML Event I/O Processor is intended to transport messages
between SCXML sessions. This specification defines the mapping
between the parameters in the sending session and the event that is
raised in the receiving session, but the transport mechanism is
platform-specific.</p>

<p>The sending and receiving SCXML Processors <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> maintain
the following mappings:</p>

</a><ol><a id="SCXMLEventProcessor" name="SCXMLEventProcessor">
<li>The 'name' field of the event raised in the receiving session
<em title="MUST in RFC2119 context" class="RFC2119">MUST</em> match
the value of the 'event' attribute of the &lt;send&gt; element in
the sending session.</li>

<li>The 'origin' field of the event raised in the receiving session
<em title="MUST in RFC2119 context" class="RFC2119">MUST</em> match
the value of the 'location' field inside the entry for the SCXML
Event I/O Processor in the _ioprocessors system variable in the
sending session.</li>

<li>The 'sendid' field of the event raised in the receiving session
<em title="MUST in RFC2119 context" class="RFC2119">MUST</em> match
the sendid in the sending session, if the author of the sending
session specifies either the 'id' or 'idlocation' attribute. If the
author does not specify either the 'id' or 'idlocation' attribute,
the 'sendid' field <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> be left empty.</li>

<li>The 'origintype' field of the event raised in the receiving
session <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> have the value "scxml".</li>

</a><li><a id="SCXMLEventProcessor" name="SCXMLEventProcessor">The 'data' field of the event raised in the receiving session
<em title="MUST in RFC2119 context" class="RFC2119">MUST</em>
contain a copy of the data specified in the 'namelist' attribute or
in &lt;param&gt; or &lt;content&gt; elements in the sending
session. The nature of the copy operation depends on the data model
in question. However, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> ensure
that changes to the transmitted data in the receiving session do
not affect the data in the sending session and vice-versa. The
format of the 'data' field will depend on the data model of the
receiving session. See </a><a href="http://www.w3.org/TR/scxml/#profiles"><em>B Data
Models</em></a> for details. If the data models in the sending and
receiving sessions are different, the mapping between them is
platform-specific.</li>
</ol>

<p>When using the SCXML Event I/O Processor, SCXML Processors <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> support
the following special targets for &lt;send&gt;:</p>

<ul>
<li>#_internal. If the target is the special term '#_internal', the
Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> add the event to the internal event queue
of the sending session.</li>

<li>#_scxml_<em>sessionid</em>. If the target is the special term
'#_scxml_<em>sessionid</em>', where <em>sessionid</em> is the id of
an SCXML session that is accessible to the Processor, the Processor
<em title="MUST in RFC2119 context" class="RFC2119">MUST</em> add
the event to the external queue of that session. The set of SCXML
sessions that are accessible to a given SCXML Processor is
platform-dependent.</li>

<li>#_parent. If the target is the special term '#_parent', the
Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> add the event to the external event queue
of the SCXML session that invoked the sending session, if there is
one. See <a href="http://www.w3.org/TR/scxml/#invoke"><em>6.4 &lt;invoke&gt;</em></a> for
details.</li>

<li>#_<em>invokeid</em>. If the target is the special term
'#_<em>invokeid</em>', where <em>invokeid</em> is the invokeid of
an SCXML session that the sending session has created by
&lt;invoke&gt;, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> add the event to the external queue of
that session. See <a href="http://www.w3.org/TR/scxml/#invoke"><em>6.4 &lt;invoke&gt;</em></a>
for details.</li>
</ul>

<p>If neither the 'target' nor the 'targetexpr' attribute is
specified, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> add the event to the external event queue
of the sending session.</p>

<p>If the sending SCXML session specifies a session that does not
exist or is inaccessible, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place the
error error.communication on the internal event queue of the
sending session. If the receiving Processor cannot handle the data
format contained in the message, the receiving Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> place the
error error.communication in internal queue of the session for
which the message was intended and <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> ignore
the message. The Processor <em title="SHOULD in RFC2119 context" class="RFC2119">SHOULD</em> also notify the sending processor of
the error. If no errors occur, the receiving Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> convert
the message into an SCXML event, using the mapping defined above,
and insert the event into the appropriate queue, as defined in <a href="http://www.w3.org/TR/scxml/#SendTargets"><em>6.2.4 The Target of Send</em></a></p>

<div class="div3">
<h4><a id="N11382" name="N11382">C.1.1 _ioprocessors Value</a></h4><a id="N11382" name="N11382">

<p>SCXML Processors <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> maintain a
'http://www.w3.org/TR/scxml/#SCXMLEventProcessor' entry in the
_ioprocessors system variable. The Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> maintain
a 'location' field inside this entry whose value holds an address
that external entities can use to communicate with this SCXML
session using the SCXML Event I/O Processor.</p>
</a></div><a id="N11382" name="N11382">

</a><div class="div3"><a id="N11382" name="N11382">
</a><h4><a id="N11382" name="N11382"></a><a id="N1138D" name="N1138D">C.1.2 Examples</a></h4><a id="N1138D" name="N1138D">

<p>Here are some examples of SCXML messages sent between SCXML
sessions. Each example shows the original &lt;send&gt; element and
a transition handling the resulting event in the receiving SCXML
session.</p>

<p><em>EXAMPLE 1:</em> First, here is a message with an XML payload
generated by &lt;send&gt; with a 'namelist':</p>

<div class="exampleInner">
<pre>SESSION1 : SENDING SESSION
Pattern: "event" attribute with an optional "namelist"

&lt;datamodel&gt;
  &lt;data id="email" expr="'mailto:recipient@example.com'"/&gt;
  &lt;data id="content" expr="'http://www.example.com/mycontent.txt'"/&gt;
  &lt;data id="xmlcontent"&gt;
    &lt;headers xmlns="http://www.example.com/headers"&gt;
      &lt;cc&gt;archive@example.com&lt;/cc&gt;
      &lt;subject&gt;Example email&lt;/subject&gt;
    &lt;/headers&gt;
  &lt;/data&gt;
&lt;/datamodel&gt;

  ...

&lt;send id="send-123"
      target="http://scxml-processors.example.com/session2"
      type="http://www.w3.org/TR/scxml/#SCXMLEventProcessor" event="email.send"
      namelist="email content xmlcontent"/&gt;


</pre>
</div>

<p>Here is sample SCXML code to process that event in the receiving
SCXML session. In this example &lt;my:email&gt; is
platform-specific executable content that sends an email:</p>

<div class="exampleInner">
<pre>SESSION2 : RECEIVING SESSION
Pattern: "event" attribute with an optional "namelist"

&lt;scxml:transition event="email.send"&gt;
  &lt;my:email to="data('_event')/scxml:property[@name='email']"
            cc="data('_event')/scxml:property[@name='xmlcontent']/h:headers/h:cc"
            subject="data('_event')/scxml:property[@name='xmlcontent']/h:headers/h:subject"
            content="data('_event')/scxml:property[@name='content']"/&gt;
&lt;/scxml:transition&gt;
</pre>
</div>

<p><em>EXAMPLE 2:</em> The next example shows &lt;send&gt; using
inline XML content:</p>

<div class="exampleInner">
<pre>SESSION1 : SENDING SESSION
Pattern: "xmlns" attribute with explicit inline content

&lt;send id="send-123"
      target="http://scxml-processors.example.com/session2"
      type="http://www.w3.org/TR/scxml/#SCXMLEventProcessor"
      xmlns:csta="http://www.ecma.ch/standards/ecma-323/csta"&gt;

  &lt;content&gt;
     &lt;csta:MakeCall&gt;
       &lt;csta:callingDevice&gt;22343&lt;/csta:callingDevice&gt;
       &lt;csta:calledDirectoryNumber&gt;18005551212&lt;/csta:calledDirectoryNumber&gt;
     &lt;/csta:MakeCall&gt;
  &lt;/content&gt;

&lt;/send&gt;

</pre>
</div>

<p>Here is sample SCXML code to process the resulting event in the
receiving SCXML session. It uses the special executable content
&lt;csta:makecall&gt; to generate a telephone call:</p>

<div class="exampleInner">
<pre>SESSION2 : RECEIVING SESSION
Pattern: "xmlns" attribute with explicit inline content

&lt;scxml:transition event="external.event"&gt;
  &lt;csta:makecall callingDevice="data('_event')/csta:MakeCall/csta:callingDevice"
                 callingDirectoryNumber="data('_event')/csta:MakeCall/csta:callingDirectoryNumber"/&gt;
&lt;/scxml:transition&gt;
</pre>
</div>

<p></p>

<p><em>EXAMPLE 3:</em> Finally, here is an example generated by
&lt;send&gt; using both 'event' and 'namelist' attributes and using
JSON content:</p>

<div class="exampleInner">
<pre>SESSION1 : SENDING SESSION
Pattern: "event" attribute with an optional "namelist"

&lt;datamodel&gt;
  &lt;data id="email" expr="'mailto:recipient@example.com'"/&gt;
  &lt;data id="content" expr="'http://www.example.com/mycontent.txt'"/&gt;
  &lt;data id="jsoncontent" src="http://www.example.com/headers.json"/&gt;
&lt;/datamodel&gt;

  ...

&lt;send sendid="send-123"
      target="'http://scxml-processors.example.com/session2'"
      type="http://www.w3.org/TR/scxml/#SCXMLEventProcessor" event="'email.send'"
      namelist="email content jsoncontent"/&gt;

</pre>
</div>

<p>Here is sample SCXML code to process the resulting event in the
receiving SCXML session. In this example, &lt;my:email&gt; is
special executable content as in the first example.</p>

<div class="exampleInner">
<pre>SESSION2 : RECEIVING SESSION
Pattern: "event" attribute with an optional "namelist"

&lt;scxml:transition event="email.send"&gt;
  &lt;my:email to="_event.email"
            cc="_event.jsoncontent.headers.cc"
            subject="_event.jsoncontent.headers.subject"
            content="_event.content"/&gt;
&lt;/scxml:transition&gt;
</pre>
</div>
</a></div><a id="N1138D" name="N1138D">
</a></div><a id="N1138D" name="N1138D">

</a><div class="div2"><a id="N1138D" name="N1138D">
</a><h3><a id="N1138D" name="N1138D"></a><a id="BasicHTTPEventProcessor" name="BasicHTTPEventProcessor">C.2 Basic HTTP Event I/O
Processor</a></h3><a id="BasicHTTPEventProcessor" name="BasicHTTPEventProcessor">

<p>The Basic HTTP Event I/O Processor is intended as a minimal
interoperable mechanism for sending and receiving events to and
from external components and SCXML 1.0 implementations. Support for
the Basic HTTP Event I/O Processor is optional.</p>

</a><div class="div3"><a id="BasicHTTPEventProcessor" name="BasicHTTPEventProcessor">
</a><h4><a id="BasicHTTPEventProcessor" name="BasicHTTPEventProcessor"></a><a id="N113BD" name="N113BD">C.2.1 Receiving Events</a></h4><a id="N113BD" name="N113BD">

</a><p><a id="N113BD" name="N113BD">An SCXML Processor that supports the Basic HTTP Event I/O
Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> accept messages at the access URI as HTTP
POST requests (see </a><a href="http://www.w3.org/TR/scxml/#HTTP">[RFC 2616]</a>). The SCXML
Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> validate the message it receives and then
<em title="MUST in RFC2119 context" class="RFC2119">MUST</em> build
the appropriate SCXML event and <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> add it to the external event queue.</p>

<p>If a single instance of the parameter '_scxmleventname' is
present, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> use its value as the name of the SCXML
event that it raises. If multiple instances of the parameter are
present, the behavior is platform-specific. If the parameter
'_scxmleventname' is not present, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> use the
name of the HTTP method that was used to deliver the message as the
name of the event that it raises. The processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> use any
message content other than '_scxmleventname' to populate
_event.data. See <a href="http://www.w3.org/TR/scxml/#profiles"><em>B Data Models</em></a> for
details.</p>

<p>After it adds the received message to the appropriate event
queue, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> then indicate the result to the external
component via a success response code 2XX. Note that this response
is sent before the event is removed from the queue and processed.
In the cases where the message cannot be formed into an SCXML
event, the Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> return an HTTP error code as defined in
<a href="http://www.w3.org/TR/scxml/#HTTP">[RFC 2616]</a>.</p>
</div>

<div class="div3">
<h4><a id="N113EA" name="N113EA">C.2.2 Sending Events</a></h4><a id="N113EA" name="N113EA">

</a><p><a id="N113EA" name="N113EA">An SCXML implementation can send events with the Basic HTTP
Event I/O Processor using the &lt;send&gt; element (see </a><a href="http://www.w3.org/TR/scxml/#send"><em>6.2 &lt;send&gt;</em></a>) with the type attribute
set to "http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor" and
the target attribute set to the access URI of the target. If
neither the 'target' nor the 'targetexpr' attribute is specified,
the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> add the event error.communication to the
internal event queue of the sending session.</p>

<p>The SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> attempt to deliver the message using HTTP
method "POST" and with parameter values encoded by default in an
application/x-www-form-urlencoded body (POST method). An SCXML
Processor <em title="MAY in RFC2119 context" class="RFC2119">MAY</em> support other encodings, and allow them to
be specified in a platform-specific way.</p>

<p>If the 'event' parameter of &lt;send&gt; is defined, the SCXML
Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> use its value as the value of the HTTP
POST parameter _scxmleventname. If the namelist attribute is
defined, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> map its variable names and values to HTTP
POST parameters. If one or more &lt;param&gt; children are present,
the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> map their names (i.e. name attributes)
and values to HTTP POST parameters. If a &lt;content&gt; child is
present, the SCXML Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> use its value as the body of the
message.</p>
</div>

<div class="div3">
<h4><a id="N1140B" name="N1140B">C.2.3 _ioprocessors Value</a></h4><a id="N1140B" name="N1140B">

<p>SCXML Processors that support the BasicHTTP Event I/O Processor
<em title="MUST in RFC2119 context" class="RFC2119">MUST</em>
maintain a 'http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor'
entry in the _ioprocessors system variable. The Processor <em title="MUST in RFC2119 context" class="RFC2119">MUST</em> maintain
a 'location' field inside this entry whose value holds an address
that external entities can use to communicate with this SCXML
session using the Basic HTTP Event I/O Processor.</p>
</a></div><a id="N1140B" name="N1140B">
</a></div><a id="N1140B" name="N1140B">
</a></div><a id="N1140B" name="N1140B">

</a><div class="div1"><a id="N1140B" name="N1140B">
</a><h2><a id="N1140B" name="N1140B"></a><a id="AlgorithmforSCXMLInterpretation" name="AlgorithmforSCXMLInterpretation">D Algorithm for SCXML
Interpretation</a></h2><a id="AlgorithmforSCXMLInterpretation" name="AlgorithmforSCXMLInterpretation">

<p>[This section is informative.]</p>

<p>This section contains an illustrative algorithm for the
interpretation of an SCXML document. It is intended as a guide for
implementers only. Implementations are free to implement SCXML
interpreters in any way they choose.</p>

<h2 id="InformalSemantics">Informal Semantics</h2>

<p>The following definitions and highlevel principles and
constraint are intended to provide a background to the algorithm,
and to serve as a guide for the proper understanding of it.</p>

<h3 id="PrelimaryDefinitions">Preliminary definitions</h3>

<dl>
<dt class="label">state</dt>

<dd>An element of type &lt;state&gt;, &lt;parallel&gt;, or
&lt;final&gt;.</dd>

<dt class="label">pseudo state</dt>

<dd>An element of type &lt;initial&gt; or &lt;history&gt;.</dd>

<dt class="label">transition target</dt>

<dd>A state, or an element of type &lt;history&gt;.</dd>

<dt class="label">atomic state</dt>

<dd>A state of type &lt;state&gt; with no child states, or a state
of type &lt;final&gt;.</dd>

<dt class="label">compound state</dt>

<dd>A state of type &lt;state&gt; with at least one child
state.</dd>

<dt class="label">configuration</dt>

<dd>The maximal consistent set of states (including parallel and
final states) that the machine is currently in. We note that if a
state s is in the configuration c, it is always the case that the
parent of s (if any) is also in c. Note, however, that
&lt;scxml&gt; is not a(n explicit) member of the
configuration.</dd>

<dt class="label">source state</dt>

<dd>The source state of a transition is the state which contains
the transition.</dd>

<dt class="label">target state</dt>

<dd>A target state of a transition is a state that the transition
is entering. Note that a transition can have zero or more target
states.</dd>

<dt class="label">targetless transition</dt>

<dd>A transition having zero target states.</dd>

<dt class="label">eventless transition</dt>

<dd>A transition lacking the 'event' attribute.</dd>

<dt class="label">external event</dt>

<dd>An SCXML event appearing in the external event queue. Such
events are either sent by external sources or generated with the
&lt;send&gt; element.</dd>

<dt class="label">internal event</dt>

<dd>An event appearing in the internal event queue. Such events are
either raised automatically by the platform or generated with the
&lt;raise&gt; or &lt;send&gt; elements.</dd>

<dt class="label">microstep</dt>

<dd>A microstep involves the processing of a single transition (or,
in the case of parallel states, a single set of transitions.) A
microstep may change the current configuration, update the data
model and/or generate new (internal and/or external) events. This,
by causality, may in turn enable additional transitions which will
be handled in the next microstep in the sequence, and so on.</dd>

<dt class="label">macrostep</dt>

<dd>A macrostep consists of a sequence (a chain) of microsteps, at
the end of which the state machine is in a stable state and ready
to process an external event. Each external event causes an SCXML
state machine to take exactly one macrostep. However, if the
external event does not enable any transitions, no microstep will
be taken, and the corresponding macrostep will be empty.</dd>
</dl>

<h3 id="PrinciplesandConstraints">Principles and Constraints</h3>

<p>We state here some principles and constraints, on the level of
semantics, that SCXML adheres to:</p>

<dl>
<dt class="label">Encapsulation</dt>

<dd>An SCXML processor is a <em>pure event processor</em>. The only
way to get data into an SCXML state machine is to send external
events to it. The only way to get data out is to receive events
from it.</dd>

<dt class="label">Causality</dt>

<dd>There shall be a <em>causal justification</em> of why events
are (or are not) returned back to the environment, which can be
traced back to the events provided by the system environment.</dd>

<dt class="label">Determinism</dt>

<dd>An SCXML state machine which does not invoke any external event
processor must always react with the same behavior (i.e. the same
sequence of output events) to a given sequence of input events
(unless, of course, the state machine is explicitly programmed to
exhibit an non-deterministic behavior). In particular, the
availability of the &lt;parallel&gt; element must not introduce any
non-determinism of the kind often associated with concurrency. Note
that observable determinism does not necessarily hold for state
machines that invoke other event processors.</dd>

<dt class="label">Completeness</dt>

<dd>An SCXML interpreter must always treat an SCXML document as
<em>completely</em> specifying the behavior of a state machine. In
particular, SCXML is designed to use priorities (based on document
order) to resolve situations which other state machine frameworks
would allow to remain under-specified (and thus non-deterministic,
although in a different sense from the above).</dd>

<dt class="label">Run to completion</dt>

<dd>SCXML adheres to a run to completion semantics in the sense
that an external event can only be processed when the processing of
the previous external event has completed, i.e. when all microsteps
(involving all triggered transitions) have been completely
taken.</dd>

<dt class="label">Termination</dt>

<dd>A microstep always terminates. A macrostep may not. A macrostep
that does not terminate may be said to consist of an infinitely
long sequence of microsteps. This is currently allowed.</dd>
</dl>

<h2 id="Algorithm">Algorithm</h2>

<p>Note that the algorithm assumes a Lisp-like semantics in which
the empty Set null is equivalent to boolean 'false' and all other
entities are equivalent to 'true'.</p>

<h3 id="Datatypes">Datatypes</h3>

<p>These are the abstract datatypes that are used in the
algorithm.</p>

<pre>datatype List
   <code>function</code> head()      // Returns the head of the list
   <code>function</code> tail()      // Returns the tail of the list (i.e., the rest of the list once the head is removed)
   <code>function</code> append(l)   // Returns the list appended with l
   <code>function</code> filter(f)   // Returns the list of elements that satisfy the predicate f
   <code>function</code> some(f)     // Returns true if some element in the list satisfies the predicate f.  Returns false for an empty list.
   <code>function</code> every(f)    // Returns true if every element in the list satisfies the predicate f.  Returns true for an empty list.
The notation [...] is used as a list constructor, so that '[t]' denotes a list whose only member is the object t.
 
datatype OrderedSet
   <code>procedure</code> add(e)              // Adds e to the set if it is not already a member
   <code>procedure</code> delete(e)           // Deletes e from the set
   <code>procedure</code> union(s)            // Adds all members of s that are not already members of the set (s must also be an OrderedSet)
   <code>function</code> isMember(e)          // Is e a member of set?
   <code>function</code> some(f)              // Returns true if some element in the set satisfies the predicate f.  Returns false for an empty set.
   <code>function</code> every(f)             // Returns true if every element in the set satisfies the predicate f. Returns true for an empty set.
   <code>function</code> hasIntersection(s)   // Returns true if this set and  set s have at least one member in common
   <code>function</code>  isEmpty()           // Is the set empty?
   <code>procedure</code> clear()             // Remove all elements from the set (make it empty) 
   <code>function</code>  toList()            // Converts the set to a list that reflects the order in which elements were originally added
                                 // In the case of sets created by intersection, the order of the first set (the one on which the method was called) is used 
                                 // In the case of sets created by union, the members of the first set (the one on which union was called) retain their original ordering
                                 // while any members belonging to the second set only are placed after, retaining their ordering in their original set. 
 

datatype Queue
   <code>procedure</code> enqueue(e) // Puts e last in the queue
   <code>function</code> dequeue()   // Removes and returns first element in queue
   <code>function</code> isEmpty()   // Is the queue empty?

datatype BlockingQueue
   <code>procedure</code> enqueue(e) // Puts e last in the queue
   <code>function</code> dequeue()   // Removes and returns first element in queue, blocks if queue is empty

datatype HashTable // table[foo] returns the value associated with foo.  table[foo] = bar sets the value associated with foo to be bar.
</pre>

<h3 id="GlobalVariables">Global variables</h3>

<p>The following variables are global from the point of view of the
algorithm. Their values will be set in the procedure
interpret().</p>

<pre>global configuration
global statesToInvoke
global datamodel
global internalQueue
global externalQueue
global historyValue
global running
global binding

</pre>

<h3 id="Predicates">Predicates</h3>

<p>The following binary predicates are used for determining the
order in which states are entered and exited.</p>

</a><pre><a id="AlgorithmforSCXMLInterpretation" name="AlgorithmforSCXMLInterpretation"><code></code></a><code><a id="entryOrder" name="entryOrder">entryOrder</a></code> // Ancestors precede descendants, with document order being used to break ties 
    (Note:since ancestors precede descendants, this is equivalent to document order.)
<code><a id="exitOrder" name="exitOrder">exitOrder</a></code>  // Descendants precede ancestors, with reverse document order being used to break ties 
    (Note: since descendants follow ancestors, this is equivalent to reverse document order.)
</pre>

<p>The following binary predicate is used to determine the order in
which we examine transitions within a state.</p>

<pre><code><a id="documentOrder" name="documentOrder">documentOrder</a></code>// The order in which the elements occurred in the original document.
</pre>

<h3 id="ProceduresandFunctions">Procedures and Functions</h3>

<p>This section defines the procedures and functions that make up
the core of the SCXML interpreter. N.B. in the code below, the
keyword 'continue' has its traditional meaning in languages like C:
break off the current iteration of the loop and proceed to the next
iteration.</p>

<h4 id="interpret"><code>procedure</code> interpret(scxml,id)</h4>

<p>The purpose of this procedure is to initialize the interpreter
and to start processing.</p>

<p>In order to interpret an SCXML document, first (optionally)
perform <a href="http://www.w3.org/TR/scxml/#xinclude">[xinclude]</a> processing and
(optionally) validate the document, throwing an exception if
validation fails. Then convert initial attributes to
&lt;initial&gt; container children with transitions to the state
specified by the attribute. (This step is done purely to simplify
the statement of the algorithm and has no effect on the system's
behavior. Such transitions will not contain any executable
content). Initialize the global data structures, including the data
model. If binding is set to 'early', initialize the data model.
Then execute the global &lt;script&gt; element, if any. Finally
call enterStates on the initial configuration, set the global
running variable to true and start the interpreter's event
loop.</p>

<pre>procedure interpret(doc):
    if not valid(doc): failWithError()
    expandScxmlSource(doc)
    configuration = new OrderedSet()
    statesToInvoke = new OrderedSet()
    internalQueue = new Queue()
    externalQueue = new BlockingQueue()
    historyValue = new HashTable()
    datamodel = new Datamodel(doc)
    if doc.binding == "early":
        initializeDatamodel(datamodel, doc)
    running = true
    executeGlobalScriptElement(doc)
    enterStates([doc.initial.transition])
    mainEventLoop()
</pre>

<h4 id="mainEventLoop"><code>procedure</code> mainEventLoop()</h4>

<p>This loop runs until we enter a top-level final state or an
external entity cancels processing. In either case 'running' will
be set to false (see EnterStates, below, for termination by
entering a top-level final state.)</p>

<p>At the top of the loop, we have either just entered the state
machine, or we have just processed an external event. Each
iteration through the loop consists of four main steps: 1)Complete
the macrostep by repeatedly taking any internally enabled
transitions, namely those that don't require an event or that are
triggered by an internal event. After each such
transition/microstep, check to see if we have reached a final
state. 2) When there are no more internally enabled transitions
available, the macrostep is done. Execute any &lt;invoke&gt; tags
for states that we entered on the last iteration through the loop
3) If any internal events have been generated by the invokes,
repeat step 1 to handle any errors raised by the &lt;invoke&gt;
elements. 4) When the internal event queue is empty, wait for an
external event and then execute any transitions that it triggers.
However special preliminary processing is applied to the event if
the state has executed any &lt;invoke&gt; elements. First, if this
event was generated by an invoked process, apply &lt;finalize&gt;
processing to it. Secondly, if any &lt;invoke&gt; elements have
autoforwarding set, forward the event to them. These steps apply
before the transitions are taken.</p>

<p>This event loop thus enforces run-to-completion semantics, in
which the system process an external event and then takes all the
'follow-up' transitions that the processing has enabled before
looking for another external event. For example, suppose that the
<em>external</em> event queue contains events ext1 and ext2 and the
machine is in state s1. If processing ext1 takes the machine to s2
and generates <em>internal</em> event int1, and s2 contains a
transition t triggered by int1, the system is guaranteed to take t,
no matter what transitions s2 or other states have that would be
triggered by ext2. Note that this is true even though ext2 was
already in the external event queue when int1 was generated. In
effect, the algorithm treats the processing of int1 as finishing up
the processing of ext1.</p>

<pre>procedure mainEventLoop():
    while running:
        enabledTransitions = null
        macrostepDone = false
        # Here we handle eventless transitions and transitions 
        # triggered by internal events until macrostep is complete
        while running and not macrostepDone:
            enabledTransitions = selectEventlessTransitions()
            if enabledTransitions.isEmpty():
                if internalQueue.isEmpty(): 
                    macrostepDone = true
                else:
                    internalEvent = internalQueue.dequeue()
                    datamodel["_event"] = internalEvent
                    enabledTransitions = selectTransitions(internalEvent)
            if not enabledTransitions.isEmpty():
                microstep(enabledTransitions.toList())
        # either we're in a final state, and we break out of the loop 
        if not running:
            break
        # or we've completed a macrostep, so we start a new macrostep by waiting for an external event
        # Here we invoke whatever needs to be invoked. The implementation of 'invoke' is platform-specific
        for state in statesToInvoke.sort(entryOrder):
            for inv in state.invoke.sort(documentOrder):
                invoke(inv)
        statesToInvoke.clear()
        # Invoking may have raised internal error events and we iterate to handle them        
        if not internalQueue.isEmpty():
            continue
        # A blocking wait for an external event.  Alternatively, if we have been invoked
        # our parent session also might cancel us.  The mechanism for this is platform specific,
        # but here we assume it’s a special event we receive
        externalEvent = externalQueue.dequeue()
        if isCancelEvent(externalEvent):
            running = false
            continue
        datamodel["_event"] = externalEvent
        for state in configuration:
            for inv in state.invoke:
                if inv.invokeid == externalEvent.invokeid:
                    applyFinalize(inv, externalEvent)
                if inv.autoforward:
                    send(inv.id, externalEvent) 
        enabledTransitions = selectTransitions(externalEvent)
        if not enabledTransitions.isEmpty():
            microstep(enabledTransitions.toList()) 
    # End of outer while running loop.  If we get here, we have reached a top-level final state or have been cancelled          
    exitInterpreter()            
</pre>

<h4 id="exitInterpreter"><code>procedure</code>
exitInterpreter()</h4>

<p>The purpose of this procedure is to exit the current SCXML
process by exiting all active states. If the machine is in a
top-level final state, a Done event is generated. (Note that in
this case, the final state will be the only active state.) The
implementation of returnDoneEvent is platform-dependent, but if
this session is the result of an &lt;invoke&gt; in another SCXML
session, returnDoneEvent will cause the event
done.invoke.&lt;id&gt; to be placed in the external event queue of
that session, where &lt;id&gt; is the id generated in that session
when the &lt;invoke&gt; was executed.</p>

<pre>procedure exitInterpreter():
    statesToExit = configuration.toList().sort(exitOrder)
    for s in statesToExit:
        for content in s.onexit.sort(documentOrder):
            executeContent(content)
        for inv in s.invoke:
            cancelInvoke(inv)
        configuration.delete(s)
        if isFinalState(s) and isScxmlElement(s.parent):   
            returnDoneEvent(s.donedata)
</pre>

<h4 id="selectEventlessTransitions"><code>function</code>
selectEventlessTransitions()</h4>

<p>This function selects all transitions that are enabled in the
current configuration that do not require an event trigger. First
find a transition with no 'event' attribute whose condition
evaluates to <code>true</code>. If multiple matching transitions
are present, take the first in document order. If none are present,
search in the state's ancestors in ancestry order until one is
found. As soon as such a transition is found, add it to
enabledTransitions, and proceed to the next atomic state in the
configuration. If no such transition is found in the state or its
ancestors, proceed to the next state in the configuration. When all
atomic states have been visited and transitions selected, filter
the set of enabled transitions, removing any that are preempted by
other transitions, then return the resulting set.</p>

<pre>function selectEventlessTransitions():
    enabledTransitions = new OrderedSet()
    atomicStates = configuration.toList().filter(isAtomicState).sort(documentOrder)
    for state in atomicStates:
        loop: for s in [state].append(getProperAncestors(state, null)):
            for t in s.transition.sort(documentOrder):
                if not t.event and conditionMatch(t): 
                    enabledTransitions.add(t)
                    break loop
    enabledTransitions = removeConflictingTransitions(enabledTransitions)
    return enabledTransitions
</pre>

<h4 id="selectTransitions"><code>function</code>
selectTransitions(event)</h4>

<p>The purpose of the selectTransitions()procedure is to collect
the transitions that are enabled by this event in the current
configuration.</p>

<p>Create an empty set of <code>enabledTransitions</code>. For each
atomic state , find a transition whose 'event' attribute matches
<code>event</code> and whose condition evaluates to
<code>true</code>. If multiple matching transitions are present,
take the first in document order. If none are present, search in
the state's ancestors in ancestry order until one is found. As soon
as such a transition is found, add it to enabledTransitions, and
proceed to the next atomic state in the configuration. If no such
transition is found in the state or its ancestors, proceed to the
next state in the configuration. When all atomic states have been
visited and transitions selected, filter out any preempted
transitions and return the resulting set.</p>

<pre>function selectTransitions(event):
    enabledTransitions = new OrderedSet()
    atomicStates = configuration.toList().filter(isAtomicState).sort(documentOrder)
    for state in atomicStates:
        loop: for s in [state].append(getProperAncestors(state, null)):
            for t in s.transition.sort(documentOrder):
                if t.event and nameMatch(t.event, event.name) and conditionMatch(t):
                    enabledTransitions.add(t)
                    break loop
    enabledTransitions = removeConflictingTransitions(enabledTransitions)
    return enabledTransitions
</pre>

<h4 id="removeConflictingTransitions"><code>function</code>
removeConflictingTransitions(enabledTransitions)</h4>

<p>enabledTransitions will contain multiple transitions only if a
parallel state is active. In that case, we may have one transition
selected for each of its children. These transitions may conflict
with each other in the sense that they have incompatible target
states. Loosely speaking, transitions are compatible when each one
is contained within a single &lt;state&gt; child of the
&lt;parallel&gt; element. Transitions that aren't contained within
a single child force the state machine to leave the
&lt;parallel&gt; ancestor (even if they reenter it later). Such
transitions conflict with each other, and with transitions that
remain within a single &lt;state&gt; child, in that they may have
targets that cannot be simultaneously active. The test that
transitions have non-intersecting exit sets captures this
requirement. (If the intersection is null, the source and targets
of the two transitions are contained in separate &lt;state&gt;
descendants of &lt;parallel&gt;. If intersection is non-null, then
at least one of the transitions is exiting the &lt;parallel&gt;).
When such a conflict occurs, then if the source state of one of the
transitions is a descendant of the source state of the other, we
select the transition in the descendant. Otherwise we prefer the
transition that was selected by the earlier state in document order
and discard the other transition. Note that targetless transitions
have empty exit sets and thus do not conflict with any other
transitions.</p>

<p>We start with a list of enabledTransitions and produce a
conflict-free list of filteredTransitions. For each t1 in
enabledTransitions, we test it against all t2 that are already
selected in filteredTransitions. If there is a conflict, then if
t1's source state is a descendant of t2's source state, we prefer
t1 and say that it preempts t2 (so we we make a note to remove t2
from filteredTransitions). Otherwise, we prefer t2 since it was
selected in an earlier state in document order, so we say that it
preempts t1. (There's no need to do anything in this case since t2
is already in filteredTransitions. Furthermore, once one transition
preempts t1, there is no need to test t1 against any other
transitions.) Finally, if t1 isn't preempted by any transition in
filteredTransitions, remove any transitions that it preempts and
add it to that list.</p>

<pre>function removeConflictingTransitions(enabledTransitions):
    filteredTransitions = new OrderedSet()
    //toList sorts the transitions in the order of the states that selected them
    for t1 in enabledTransitions.toList():
        t1Preempted = false
        transitionsToRemove = new OrderedSet()
        for t2 in filteredTransitions.toList():
            if computeExitSet([t1]).hasIntersection(computeExitSet([t2])):
                if isDescendant(t1.source, t2.source):
                    transitionsToRemove.add(t2)
                else: 
                    t1Preempted = true
                    break
        if not t1Preempted:
            for t3 in transitionsToRemove.toList():
                filteredTransitions.delete(t3)
            filteredTransitions.add(t1)
           
    return filteredTransitions
</pre>

<h4 id="microstepProcedure"><code>procedure</code>
microstep(enabledTransitions)</h4>

<p>The purpose of the microstep <code>procedure</code> is to
process a single set of transitions. These may have been enabled by
an external event, an internal event, or by the presence or absence
of certain values in the data model at the current point in time.
The processing of the enabled transitions must be done in parallel
('lock step') in the sense that their source states must first be
exited, then their actions must be executed, and finally their
target states entered.</p>

<p>If a single atomic state is active, then enabledTransitions will
contain only a single transition. If multiple states are active
(i.e., we are in a parallel region), then there may be multiple
transitions, one per active atomic state (though some states may
not select a transition.) In this case, the transitions are taken
in the document order of the atomic states that selected them.</p>

<pre>procedure microstep(enabledTransitions):
    exitStates(enabledTransitions)
    executeTransitionContent(enabledTransitions)
    enterStates(enabledTransitions)
</pre>

<h4 id="exitStates"><code>procedure</code>
exitStates(enabledTransitions)</h4>

<p>Compute the set of states to exit. Then remove all the states on
statesToExit from the set of states that will have invoke
processing done at the start of the next macrostep. (Suppose
macrostep M1 consists of microsteps m11 and m12. We may enter state
s in m11 and exit it in m12. We will add s to statesToInvoke in
m11, and must remove it in m12. In the subsequent macrostep M2, we
will apply invoke processing to all states that were entered, and
not exited, in M1.) Then convert statesToExit to a list and sort it
in exitOrder.</p>

<p>For each state s in the list, if s has a deep history state h,
set the history value of h to be the list of all atomic descendants
of s that are members in the current configuration, else set its
value to be the list of all immediate children of s that are
members of the current configuration. Again for each state s in the
list, first execute any onexit handlers, then cancel any ongoing
invocations, and finally remove s from the current
configuration.</p>

<pre>procedure exitStates(enabledTransitions):
    statesToExit = computeExitSet(enabledTransitions)           
    for s in statesToExit:
        statesToInvoke.delete(s)
    statesToExit = statesToExit.toList().sort(exitOrder)
    for s in statesToExit:
        for h in s.history:
            if h.type == "deep":
                f = lambda s0: isAtomicState(s0) and isDescendant(s0,s) 
            else:
                f = lambda s0: s0.parent == s
            historyValue[h.id] = configuration.toList().filter(f)
    for s in statesToExit:
        for content in s.onexit.sort(documentOrder):
            executeContent(content)
        for inv in s.invoke:
            cancelInvoke(inv)
        configuration.delete(s)
</pre>

<h4 id="computeExitSet"><code>procedure</code>
computeExitSet(enabledTransitions)</h4>

<p>For each transition t in enabledTransitions, if t is targetless
then do nothing, else compute the transition's domain. (This will
be the source state in the case of internal transitions) or the
least common compound ancestor state of the source state and target
states of t (in the case of external transitions. Add to the
statesToExit set all states in the configuration that are
descendants of the domain.</p>

<pre>function computeExitSet(transitions)
    statesToExit = new OrderedSet
    for t in transitions:
        if t.target:
            domain = getTransitionDomain(t)
            for s in configuration:
                if isDescendant(s,domain):
                    statesToExit.add(s)
    return statesToExit   
   
</pre>

<h4 id="executeTransitionContent"><code>procedure</code>
executeTransitionContent(enabledTransitions)</h4>

<p>For each transition in the list of
<code>enabledTransitions</code>, execute its executable
content.</p>

<pre>procedure executeTransitionContent(enabledTransitions):
    for t in enabledTransitions:
        executeContent(t)
</pre>

<h4 id="enterStates"><code>procedure</code>
enterStates(enabledTransitions)</h4>

<p>First, compute the list of all the states that will be entered
as a result of taking the transitions in enabledTransitions. Add
them to statesToInvoke so that invoke processing can be done at the
start of the next macrostep. Convert statesToEnter to a list and
sort it in entryOrder. For each state s in the list, first add s to
the current configuration. Then if we are using late binding, and
this is the first time we have entered s, initialize its data
model. Then execute any onentry handlers. If s's initial state is
being entered by default, execute any executable content in the
initial transition. If a history state in s was the target of a
transition, and s has not been entered before, execute the content
inside the history state's default transition. Finally, if s is a
final state, generate relevant Done events. If we have reached a
top-level final state, set running to false as a signal to stop
processing.</p>

<pre>procedure enterStates(enabledTransitions):
    statesToEnter = new OrderedSet()
    statesForDefaultEntry = new OrderedSet()
    // initialize the temporary table for default content in history states
    defaultHistoryContent = new HashTable() 
    computeEntrySet(enabledTransitions, statesToEnter, statesForDefaultEntry, defaultHistoryContent) 
    for s in statesToEnter.toList().sort(entryOrder):
        configuration.add(s)
        statesToInvoke.add(s)
        if binding == "late" and s.isFirstEntry:
            initializeDataModel(datamodel.s,doc.s)
            s.isFirstEntry = false
        for content in s.onentry.sort(documentOrder):
            executeContent(content)
        if statesForDefaultEntry.isMember(s):
            executeContent(s.initial.transition)
        if defaultHistoryContent[s.id]:
            executeContent(defaultHistoryContent[s.id]) 
        if isFinalState(s):
            if isSCXMLElement(s.parent):
                running = false
            else:
                parent = s.parent
                grandparent = parent.parent
                internalQueue.enqueue(new Event("done.state." + parent.id, s.donedata))
                if isParallelState(grandparent):
                    if getChildStates(grandparent).every(isInFinalState):
                        internalQueue.enqueue(new Event("done.state." + grandparent.id))
 
</pre>

<h4 id="computeEntrySet"><code>procedure</code>
computeEntrySet(transitions, statesToEnter, statesForDefaultEntry,
defaultHistoryContent)</h4>

<p>Compute the complete set of states that will be entered as a
result of taking 'transitions'. This value will be returned in
'statesToEnter' (which is modified by this procedure). Also place
in 'statesForDefaultEntry' the set of all states whose default
initial states were entered. First gather up all the target states
in 'transitions'. Then add them and, for all that are not atomic
states, add all of their (default) descendants until we reach one
or more atomic states. Then add any ancestors that will be entered
within the domain of the transition. (Ancestors outside of the
domain of the transition will not have been exited.)</p>

<pre>procedure computeEntrySet(transitions, statesToEnter, statesForDefaultEntry, defaultHistoryContent)
    for t in transitions:
        for s in t.target:
            addDescendantStatesToEnter(s,statesToEnter,statesForDefaultEntry, defaultHistoryContent) 
        ancestor = getTransitionDomain(t) 
        for s in getEffectiveTargetStates(t)):            
            addAncestorStatesToEnter(s, ancestor, statesToEnter, statesForDefaultEntry, defaultHistoryContent)
</pre>

<h4 id="addDescendantStatesToEnter"><code>procedure</code>
addDescendantStatesToEnter(state,statesToEnter,statesForDefaultEntry,
defaultHistoryContent)</h4>

<p>The purpose of this procedure is to add to statesToEnter 'state'
and any of its descendants that the state machine will end up
entering when it enters 'state'. (N.B. If 'state' is a history
pseudo-state, we dereference it and add the history value instead.)
Note that this procedure permanently modifies both statesToEnter
and statesForDefaultEntry.</p>

<p>First, If state is a history state then add either the history
values associated with state or state's default target to
statesToEnter. Then (since the history value may not be an
immediate descendant of 'state's parent) add any ancestors between
the history value and state's parent. Else (if state is not a
history state), add state to statesToEnter. Then if state is a
compound state, add state to statesForDefaultEntry and recursively
call addStatesToEnter on its default initial state(s). Then, since
the default initial states may not be children of 'state', add any
ancestors between the default initial states and 'state'.
Otherwise, if state is a parallel state, recursively call
addStatesToEnter on any of its child states that don't already have
a descendant on statesToEnter.</p>

<pre>procedure addDescendantStatesToEnter(state,statesToEnter,statesForDefaultEntry, defaultHistoryContent):
    if isHistoryState(state):
        if historyValue[state.id]:
            for s in historyValue[state.id]:
                addDescendantStatesToEnter(s,statesToEnter,statesForDefaultEntry, defaultHistoryContent)
            for s in historyValue[state.id]:
                addAncestorStatesToEnter(s, state.parent, statesToEnter, statesForDefaultEntry, defaultHistoryContent)
        else:
            defaultHistoryContent[state.parent.id] = state.transition.content
            for s in state.transition.target:
                addDescendantStatesToEnter(s,statesToEnter,statesForDefaultEntry, defaultHistoryContent)
            for s in state.transition.target:     
                addAncestorStatesToEnter(s, state.parent, statesToEnter, statesForDefaultEntry, defaultHistoryContent)
    else:
        statesToEnter.add(state)
        if isCompoundState(state):
            statesForDefaultEntry.add(state)
            for s in state.initial.transition.target:
                addDescendantStatesToEnter(s,statesToEnter,statesForDefaultEntry, defaultHistoryContent)
            for s in state.initial.transition.target:    
                addAncestorStatesToEnter(s, state, statesToEnter, statesForDefaultEntry, defaultHistoryContent)
        else:
            if isParallelState(state):
                for child in getChildStates(state):
                    if not statesToEnter.some(lambda s: isDescendant(s,child)):
                        addDescendantStatesToEnter(child,statesToEnter,statesForDefaultEntry, defaultHistoryContent) 

</pre>

<h4 id="addAncestorStatesToEnter"><code>procedure</code>
addAncestorStatesToEnter(state, ancestor, statesToEnter,
statesForDefaultEntry, defaultHistoryContent)</h4>

<p>Add to statesToEnter any ancestors of 'state' up to, but not
including, 'ancestor' that must be entered in order to enter
'state'. If any of these ancestor states is a parallel state, we
must fill in its descendants as well.</p>

<pre>procedure addAncestorStatesToEnter(state, ancestor, statesToEnter, statesForDefaultEntry, defaultHistoryContent)
    for anc in getProperAncestors(state,ancestor):
        statesToEnter.add(anc)
        if isParallelState(anc):
            for child in getChildStates(anc):
                if not statesToEnter.some(lambda s: isDescendant(s,child)):
                    addDescendantStatesToEnter(child,statesToEnter,statesForDefaultEntry, defaultHistoryContent) 
</pre>

<h4 id="isInFinalState"><code>procedure</code>
isInFinalState(s)</h4>

<p>Return true if s is a compound &lt;state&gt; and one of its
children is an active &lt;final&gt; state (i.e. is a member of the
current configuration), or if s is a &lt;parallel&gt; state and
isInFinalState is true of all its children.</p>

<pre>function isInFinalState(s):
    if isCompoundState(s):
        return getChildStates(s).some(lambda s: isFinalState(s) and configuration.isMember(s))
    elif isParallelState(s):
        return getChildStates(s).every(isInFinalState)
    else:
        return false
</pre>

<h4 id="getTransitionDomain"><code>function</code>
getTransitionDomain(transition)</h4>

<p>Return the compound state such that 1) all states that are
exited or entered as a result of taking 'transition' are
descendants of it 2) no descendant of it has this property.</p>

<pre>function getTransitionDomain(t)
    tstates = getEffectiveTargetStates(t)
    if not tstates:
        return null
    elif t.type == "internal" and isCompoundState(t.source) and tstates.every(lambda s: isDescendant(s,t.source)):
        return t.source
    else:
        return findLCCA([t.source].append(tstates))

</pre>

<h4 id="findLCCA"><code>function</code> findLCCA(stateList)</h4>

<p>The <a id="LCCA" name="LCCA">Least Common Compound Ancestor</a>
is the &lt;state&gt; or &lt;scxml&gt; element s such that s is a
proper ancestor of all states on stateList and no descendant of s
has this property. Note that there is guaranteed to be such an
element since the &lt;scxml&gt; wrapper element is a common
ancestor of all states. Note also that since we are speaking of
proper ancestor (parent or parent of a parent, etc.) the LCCA is
never a member of stateList.</p>

<pre>function findLCCA(stateList):
    for anc in getProperAncestors(stateList.head(),null).filter(isCompoundStateOrScxmlElement):
        if stateList.tail().every(lambda s: isDescendant(s,anc)):
            return anc

</pre>

<h4 id="getEffectiveTargetStates"><code>function</code>
getEffectiveTargetStates(transition)</h4>

<p>Returns the states that will be the target when 'transition' is
taken, dereferencing any history states.</p>

<pre>function getEffectiveTargetStates(transition)
    targets = new OrderedSet()
    for s in transition.target
        if isHistoryState(s):
            if historyValue[s.id]:
                targets.union(historyValue[s.id])
            else:
                targets.union(getEffectiveTargetStates(s.transition))
        else:
            targets.add(s)
    return targets
   
</pre>

<h4 id="getProperAncestors"><code>function</code>
getProperAncestors(state1, state2)</h4>

<p>If state2 is null, returns the set of all ancestors of state1 in
ancestry order (state1's parent followed by the parent's parent,
etc. up to an including the &lt;scxml&gt; element). If state2 is
non-null, returns in ancestry order the set of all ancestors of
state1, up to but not including state2. (A "proper ancestor" of a
state is its parent, or the parent's parent, or the parent's
parent's parent, etc.))If state2 is state1's parent, or equal to
state1, or a descendant of state1, this returns the empty set.</p>

<h4 id="isDescendant"><code>function</code> isDescendant(state1,
state2)</h4>

<p>Returns 'true' if state1 is a descendant of state2 (a child, or
a child of a child, or a child of a child of a child, etc.)
Otherwise returns 'false'.</p>

<h4 id="getChildStates"><code>function</code>
getChildStates(state1)</h4>

<p>Returns a list containing all &lt;state&gt;, &lt;final&gt;, and
&lt;parallel&gt; children of state1.</p>
</div>

<div class="div1">
<h2><a id="schemas" name="schemas">E Schema</a></h2><a id="schemas" name="schemas">

<p>[This section is informative.]</p>

</a><p><a id="schemas" name="schemas">Schemas for SCXML can be found in </a><a href="http://www.w3.org/2011/04/SCXML/">www.w3.org/2011/04/SCXML</a>.
Two sets of schemas are available. One uses Schema 1.0 and is
relatively loose, in the sense that it does not enforce all the
restrictions contained in this specification. Its master schema is
<a href="http://www.w3.org/2011/04/SCXML/scxml.xsd">http://www.w3.org/2011/04/SCXML/scxml.xsd</a>.
The other set of schemas uses Schema 1.1, in particular the
&lt;assert&gt; element, and is stricter. Its master schema is <a href="http://www.w3.org/2011/04/SCXML/scxml.xsd">http://www.w3.org/2011/04/SCXML/scxml-strict.xsd</a>.</p>
</div>

<div class="div1">
<h2><a id="relatedWork" name="relatedWork">F Related Work</a></h2><a id="relatedWork" name="relatedWork">

<p>[This section is informative.]</p>

</a><p><a id="relatedWork" name="relatedWork">A number of other XML-based state machine notations have been
developed, but none serves the same purpose as SCXML. XMI </a><a href="http://www.w3.org/TR/scxml/#XMI">[UML XMI]</a> is a notation developed for representing
UML diagrams, including Harel statecharts. However it is intended
as a machine interchange format and is not readily authorable by
humans. ebXML <a href="http://www.w3.org/TR/scxml/#ebXML">[ebXML]</a> is a language for
business process specification intended to support B2B e-commerce
applications. It contains a state machine language that is in some
ways similar to the one presented here, but its syntax and
semantics are closely tied to its intended use in e-commerce. It is
therefore not suitable as a general-purpose state machine language.
XTND <a href="http://www.w3.org/TR/scxml/#XTND">[XTND]</a>, also called XML Transition Network
Definition, is a notation for simple finite state machines but
lacks Harel's notions of hierarchical and parallel states and are
thus not suitable for a general-purpose state machine that is
semantically equivalent to Harel state charts.</p>
</div>

<div class="div1">
<h2><a id="Examples" name="Examples">G Examples</a></h2><a id="Examples" name="Examples">

<p>[This section is informative.]</p>

</a><div class="div2"><a id="Examples" name="Examples">
</a><h3><a id="Examples" name="Examples"></a><a id="N11608" name="N11608">G.1 Language Overview</a></h3><a id="N11608" name="N11608">

<p>This SCXML document gives an overview of the SCXML language and
shows the use of its state machine transition flows:</p>

</a><div class="exampleOuter"><a id="N11608" name="N11608">
</a><div class="exampleHeader"><a id="N11608" name="N11608"></a><a id="N1160D" name="N1160D">Example:
Main.scxml</a></div><a id="N1160D" name="N1160D">

<div class="exampleInner">
<pre>&lt;?xml version="1.0" encoding="us-ascii"?&gt;
&lt;!-- A wrapper state that contains all other states in this file
- it represents the complete state machine --&gt; 
&lt;scxml xmlns="http://www.w3.org/2005/07/scxml"
       xmlns:xi="http://www.w3.org/2001/XInclude"
       version="1.0"
       initial="Main"
       datamodel="ecmascript"&gt;
  &lt;state id="Main"&gt;
    &lt;!-- its initial state is Test1 --&gt;
    &lt;initial&gt;
      &lt;transition target="Test1"/&gt;
    &lt;/initial&gt;

    &lt;!-- Really simple state showing the basic syntax. --&gt;
    &lt;state id="Test1"&gt;
      &lt;initial&gt;
        &lt;transition target="Test1Sub1"/&gt;
      &lt;/initial&gt;
      &lt;!-- Runs before we go into the substate --&gt;
      &lt;onentry&gt; 
        &lt;log expr="'Inside Test1'"/&gt;
      &lt;/onentry&gt;

      &lt;!-- Here is our first substate --&gt;
      &lt;state id="Test1Sub1"&gt;
        &lt;onentry&gt;
          &lt;log expr="'Inside Test1Sub1.'"/&gt;
        &lt;/onentry&gt;
        &lt;onexit&gt;
          &lt;log expr="'Leaving Test1Sub1'"/&gt;
        &lt;/onexit&gt;
        &lt;!-- Go to Sub2 on Event1 --&gt;
        &lt;transition event="Event1" target="Test1Sub2"/&gt;
      &lt;/state&gt;

      &lt;!-- Here is the second substate 
           It is final, so Test1 is done when we get here --&gt;
      &lt;final id="Test1Sub2"/&gt;

      &lt;!-- We get this event when we reach Test1Sub2. --&gt;
      &lt;transition event="Test1.done" target="Test2"/&gt;

      &lt;!-- We run this on the way out of Test1 --&gt;
      &lt;onexit&gt;
        &lt;log expr="'Leaving Test1...'"/&gt;
      &lt;/onexit&gt;
    &lt;/state&gt;

    &lt;state id="Test2" xmlns:xi="http://www.w3.org/2001/XInclude"&gt;
      &lt;initial&gt;
        &lt;transition target="Test2Sub1"/&gt;
      &lt;/initial&gt;

      &lt;!-- This time we reference a state 
           defined in an external file.   --&gt;
       &lt;xi:include href="SCXMLExamples/Test2Sub1.xml" parse="text"/&gt;
  
      &lt;final id="Test2Sub2"/&gt;

      &lt;!-- Test2Sub2 is defined as final, so this
           event is generated when we reach it --&gt;
      &lt;transition event="done.state.Test2" next="Test3"/&gt;
    &lt;/state&gt;

    &lt;state id="Test3"&gt;
      &lt;initial&gt;
        &lt;transition target="Test3Sub1"/&gt;
      &lt;/initial&gt;

      &lt;state id="Test3Sub1"&gt;
        &lt;onentry&gt;
          &lt;log expr="'Inside Test3Sub1...'"/&gt;
          &lt;!-- Send our self an event in 5s --&gt;
          &lt;send event="Timer"  delay="5s"/&gt;
        &lt;/onentry&gt;
        &lt;!-- Transition on to Test4.
             This will exit both us and our parent. --&gt;
        &lt;transition event="Timer" target="Test4"/&gt;
        &lt;onexit&gt;
          &lt;log expr="'Leaving Test3Sub1...'"/&gt;
        &lt;/onexit&gt;
      &lt;/state&gt;

      &lt;onexit&gt;
        &lt;log expr="'Leaving Test3...'"/&gt;
      &lt;/onexit&gt;
    &lt;/state&gt;
    
    &lt;state id="Test4"&gt;
      &lt;onentry&gt;
        &lt;log expr="'Inside Test4...'"/&gt;
      &lt;/onentry&gt;
      &lt;initial&gt;
        &lt;transition target="Test4Sub1"/&gt;
      &lt;/initial&gt;

      &lt;state id="Test4Sub1"&gt;
        &lt;onexit&gt;
          &lt;log expr="'Leaving Test4Sub1...'"/&gt;
        &lt;/onexit&gt;
        &lt;!-- This transition causes the state to exit immediately
             after entering Test4Sub1.  The transition has no event
             or guard so it is always active --&gt;
        &lt;transition target="Test5"/&gt;
      &lt;/state&gt;
    &lt;/state&gt;
       
    &lt;state id="Test5"&gt;
      &lt;onentry&gt;
        &lt;log expr="'Inside Test5...'"/&gt;
      &lt;/onentry&gt;
      &lt;initial&gt;
        &lt;transition target="Test5P"/&gt;
      &lt;/initial&gt;

      &lt;!-- Fire off parallel states.  In a more realistic example
      the parallel substates Test5PSub1 and Test5PSub2 would themselves
      have substates and would do some real work before transitioning to final substates --&gt;
      &lt;parallel id="Test5P"&gt;
        &lt;state id="Test5PSub1" initial="Test5PSub1Final"&gt;
           &lt;final id="Test5PSub1Final"/&gt;
           &lt;/state&gt;
        &lt;state id="Test5PSub2" initial="Test5PSub2Final"&gt;
            &lt;final id="Test5PSub2Final"/&gt;
            &lt;/state&gt;
        &lt;onexit&gt;
          &lt;log expr="'all parallel states done'"/&gt;
        &lt;/onexit&gt;
      &lt;/parallel&gt;

      &lt;!-- The parallel states immediately transition to final substates,
      so this event is generated immediately.   --&gt;
      &lt;transition event="done.state.Test5P" target="Test6"/&gt;
    &lt;/state&gt;

    &lt;!-- 
         - This state shows invocation of an external component.
         - We will use CCXML + VoiceXML actions as an example 
         - as it is a good smoke test to show how it all 
         - fits together. 
         - Note: In a real app you would likely 
         - split this over several states but we 
         - are trying to keep it simple here. 
    --&gt;
    &lt;state id="Test6"
           xmlns:ccxml="http://www.w3.org/2002/09/ccxml"
           xmlns:v3="http://www.w3.org/2005/07/vxml3"&gt;
      &lt;datamodel&gt;
        &lt;data id="ccxmlid" expr="32459"/&gt;
        &lt;data id="v3id" expr="17620"/&gt;
        &lt;data id="dest" expr="'tel:+18315552020'"/&gt;
        &lt;data id="src" expr="'helloworld2.vxml'"/&gt;
        &lt;data id="id" expr="'HelloWorld'"/&gt;
      &lt;/datamodel&gt;

      &lt;onentry&gt;
        &lt;!-- Use &lt;send&gt; a message to a CCXML Processor asking it to run createcall --&gt;
        &lt;send target="ccxmlid" type="http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor" event="ccxml:createcall" namelist="dest"/&gt;
      &lt;/onentry&gt;

      &lt;transition event="ccxml:connection.connected"&gt;      
        &lt;!-- Here as a platform-specific extension we use example V3 
             Custom Action Elements instead of send. The implementation of this logic 
             would be platform-dependent. --&gt;
        &lt;v3:form id="HelloWorld"&gt;
          &lt;v3:block&gt;&lt;v3:prompt&gt;Hello World!&lt;/v3:prompt&gt;&lt;/v3:block&gt;          
        &lt;/v3:form&gt;
      &lt;/transition&gt;

      &lt;transition event="v3:HelloWorld.done"&gt;
        &lt;!-- Here we are using the low level &lt;send&gt; 
             element to run a v3 form. Note that the event "v3:HelloWorld.done" 
             is assumed either to be set/sent explicitly by the v3:form code or 
             implicitly by some process outside of the v3:form --&gt;
        &lt;send target="v3id" type="http://www.w3.org/TR/scxml/#BasicEventProcessor" event="v3:formstart" namelist="src id"/&gt;
      &lt;/transition&gt;

      &lt;transition event="v3:HelloWorld2.done"&gt;
        &lt;!-- we use _event.data to access data in the event we're processing.
             Again we assume the v3:HelloWorld2.done is set/sent from outside
             this document --&gt;
        &lt;ccxml:disconnect connectionid="_event.data.connectionid"/&gt;      
      &lt;/transition&gt;

      &lt;transition event="ccxml:connection.disconnected" target="Done"/&gt;
  
      &lt;transition event="send.failed" target="Done"&gt;
        &lt;!-- If we get an error event we move to the Done state that 
             is a final state. --&gt;
        &lt;log expr="'Sending to and External component failed'"/&gt;
      &lt;/transition&gt;

      &lt;onexit&gt;
        &lt;log expr="'Finished with external component'"/&gt;
      &lt;/onexit&gt;
    &lt;/state&gt;

    &lt;!-- This final state is an immediate child of Main
         -  when we get here, Main.done is generated. --&gt;
    &lt;final id="Done"/&gt;
    &lt;!-- End of Main &gt; --&gt;
  &lt;/state&gt;
&lt;/scxml&gt;
</pre>
</div>
</a></div><a id="N1160D" name="N1160D">

</a><div class="exampleOuter"><a id="N1160D" name="N1160D">
</a><div class="exampleHeader"><a id="N1160D" name="N1160D"></a><a id="N11613" name="N11613">Example:
Test2Sub1.xml</a></div><a id="N11613" name="N11613">

<div class="exampleInner">
<pre>  &lt;!-- This is an example substate defined in
  - an external file and included by Main.scxml.
  --&gt;
  &lt;state id="Test2Sub1"&gt;
    &lt;onentry&gt;
      &lt;log expr="'Inside Test2Sub1'"/&gt;
    &lt;/onentry&gt;
    &lt;transition event="Event2" target="Test2Sub2"/&gt;
  &lt;/state&gt;
</pre>
</div>
</a></div><a id="N11613" name="N11613">
</a></div><a id="N11613" name="N11613">

</a><div class="div2"><a id="N11613" name="N11613">
</a><h3><a id="N11613" name="N11613"></a><a id="N11619" name="N11619">G.2 Microwave Example</a></h3><a id="N11619" name="N11619">

<p>The example below shows the implementation of a simple microwave
oven using SCXML.</p>

</a><div class="exampleOuter"><a id="N11619" name="N11619">
</a><div class="exampleHeader"><a id="N11619" name="N11619"></a><a id="N1161E" name="N1161E">Example:
microwave-01.scxml</a></div><a id="N1161E" name="N1161E">

<div class="exampleInner">
<pre>&lt;?xml version="1.0"?&gt;
&lt;scxml xmlns="http://www.w3.org/2005/07/scxml"
       version="1.0"
       datamodel="ecmascript"
       initial="off"&gt;

  &lt;!--  trivial 5 second microwave oven example --&gt;
  &lt;datamodel&gt;
    &lt;data id="cook_time" expr="5"/&gt;
    &lt;data id="door_closed" expr="true"/&gt;
    &lt;data id="timer" expr="0"/&gt;
  &lt;/datamodel&gt;

  &lt;state id="off"&gt;
    &lt;!-- off state --&gt;
    &lt;transition event="turn.on" target="on"/&gt;
  &lt;/state&gt;

  &lt;state id="on"&gt;
    &lt;initial&gt;
        &lt;transition target="idle"/&gt;
    &lt;/initial&gt;
    &lt;!-- on/pause state --&gt;

    &lt;transition event="turn.off" target="off"/&gt;
    &lt;transition cond="timer &amp;gt;= cook_time" target="off"/&gt;

    &lt;state id="idle"&gt;
      &lt;!-- default immediate transition if door is shut --&gt;
      &lt;transition cond="door_closed" target="cooking"/&gt;
      &lt;transition event="door.close" target="cooking"&gt;
        &lt;assign location="door_closed" expr="true"/&gt;
        &lt;!-- start cooking --&gt;
      &lt;/transition&gt;
    &lt;/state&gt;

    &lt;state id="cooking"&gt;
      &lt;transition event="door.open" target="idle"&gt;
        &lt;assign location="door_closed" expr="false"/&gt;
      &lt;/transition&gt;

      &lt;!-- a 'time' event is seen once a second --&gt;
      &lt;transition event="time"&gt;
        &lt;assign location="timer" expr="timer + 1"/&gt;
      &lt;/transition&gt;
    &lt;/state&gt;

  &lt;/state&gt;

&lt;/scxml&gt;
</pre>
</div>
</a></div><a id="N1161E" name="N1161E">
</a></div><a id="N1161E" name="N1161E">

</a><div class="div2"><a id="N1161E" name="N1161E">
</a><h3><a id="N1161E" name="N1161E"></a><a id="MicrowaveParallel" name="MicrowaveParallel">G.3
Microwave Example (Using parallel)</a></h3><a id="MicrowaveParallel" name="MicrowaveParallel">

<p>The example below shows the implementation of a simple microwave
oven using &lt;parallel&gt; and the SCXML In() predicate.</p>

</a><div class="exampleOuter"><a id="MicrowaveParallel" name="MicrowaveParallel">
</a><div class="exampleHeader"><a id="MicrowaveParallel" name="MicrowaveParallel"></a><a id="N1162A" name="N1162A">Example:
microwave-02.scxml</a></div><a id="N1162A" name="N1162A">

<div class="exampleInner">
<pre>&lt;?xml version="1.0"?&gt;
&lt;scxml xmlns="http://www.w3.org/2005/07/scxml"
       version="1.0"
       datamodel="ecmascript"
       initial="oven"&gt; 

  &lt;!-- trivial 5 second microwave oven example --&gt;
  &lt;!-- using parallel and In() predicate --&gt;
  &lt;datamodel&gt;
    &lt;data id="cook_time" expr="5"/&gt;
    &lt;data id="door_closed" expr="true"/&gt;
    &lt;data id="timer" expr="0"/&gt;
  &lt;/datamodel&gt;

  &lt;parallel id="oven"&gt;

    &lt;!-- this region tracks the microwave state and timer --&gt;
    &lt;state id="engine"&gt;
    &lt;initial&gt;
      &lt;transition target="off"/&gt;
      &lt;/initial&gt;

      &lt;state id="off"&gt;
        &lt;!-- off state --&gt;
        &lt;transition event="turn.on" target="on"/&gt;
      &lt;/state&gt;
      
      &lt;state id="on"&gt;
      &lt;initial&gt;
        &lt;transition target="idle"/&gt;
        &lt;/initial&gt;
        
         &lt;!-- on/pause state --&gt;
        
        &lt;transition event="turn.off" target="off"/&gt;
        &lt;transition cond="timer &amp;gt;= cook_time" target="off"/&gt;
        
        &lt;state id="idle"&gt;
          &lt;transition cond="In('closed')" target="cooking"/&gt;
        &lt;/state&gt;
        
        &lt;state id="cooking"&gt;
          &lt;transition cond="In('open')" target="idle"/&gt;

          &lt;!-- a 'time' event is seen once a second --&gt;
          &lt;transition event="time"&gt;
            &lt;assign location="timer" expr="timer + 1"/&gt;
          &lt;/transition&gt;
        &lt;/state&gt;
      &lt;/state&gt;
    &lt;/state&gt;

    &lt;!-- this region tracks the microwave door state --&gt;
    &lt;state id="door"&gt;
      &lt;initial&gt;
        &lt;transition target="closed"/&gt;
      &lt;/initial&gt;
      &lt;state id="closed"&gt;
        &lt;transition event="door.open" target="open"/&gt;
      &lt;/state&gt;
      &lt;state id="open"&gt;
        &lt;transition event="door.close" target="closed"/&gt;
       &lt;/state&gt;
    &lt;/state&gt;

  &lt;/parallel&gt;

&lt;/scxml&gt;
</pre>
</div>
</a></div><a id="N1162A" name="N1162A">
</a></div><a id="N1162A" name="N1162A">

</a><div class="div2"><a id="N1162A" name="N1162A">
</a><h3><a id="N1162A" name="N1162A"></a><a id="N11630" name="N11630">G.4 Calculator Example</a></h3><a id="N11630" name="N11630">

<p>The example below shows the implementation of a simple
calculator in SCXML.</p>

</a><div class="exampleOuter"><a id="N11630" name="N11630">
</a><div class="exampleHeader"><a id="N11630" name="N11630"></a><a id="N11635" name="N11635">Example:
calc.scxml</a></div><a id="N11635" name="N11635">

<div class="exampleInner">
<pre>&lt;?xml version="1.0" ?&gt;
&lt;scxml xmlns="http://www.w3.org/2005/07/scxml" version="1.0"
       initial="on" datamodel="ecmascript" name="calc"&gt;
    &lt;datamodel&gt;
         &lt;data id="long_expr" /&gt;
         &lt;data id="short_expr" expr="0" /&gt;
         &lt;data id="res" /&gt;
    &lt;/datamodel&gt;
    &lt;state id="wrapper" initial="on"&gt;
    &lt;state id="on" initial="ready"&gt;
        &lt;onentry&gt;
            &lt;send event="DISPLAY.UPDATE" /&gt;
        &lt;/onentry&gt;
        &lt;state id="ready" initial="begin"&gt;
        &lt;state id="begin"&gt;
            &lt;transition event="OPER.MINUS" target="negated1" /&gt;
            &lt;onentry&gt;
                &lt;send event="DISPLAY.UPDATE" /&gt;
            &lt;/onentry&gt;
        &lt;/state&gt;
        &lt;state id="result"&gt;
        &lt;/state&gt;
            &lt;transition event="OPER" target="opEntered" /&gt;
            &lt;transition event="DIGIT.0" target="zero1"&gt;
                &lt;assign location="short_expr" expr="''" /&gt;
            &lt;/transition&gt;
            &lt;transition event="DIGIT" target="int1"&gt;
                &lt;assign location="short_expr" expr="''" /&gt;
            &lt;/transition&gt;
            &lt;transition event="POINT" target="frac1"&gt;
                &lt;assign location="short_expr" expr="''" /&gt;
            &lt;/transition&gt;
        &lt;/state&gt;
        &lt;state id="negated1"&gt;
            &lt;onentry&gt;
                &lt;assign location="short_expr" expr="'-'" /&gt;
                &lt;send event="DISPLAY.UPDATE" /&gt;
            &lt;/onentry&gt;
            &lt;transition event="DIGIT.0" target="zero1" /&gt;
            &lt;transition event="DIGIT" target="int1" /&gt;
            &lt;transition event="POINT" target="frac1" /&gt;
        &lt;/state&gt;
        &lt;state id="operand1"&gt;
            &lt;state id="zero1"&gt;
                &lt;transition event="DIGIT" cond="_event.name != 'DIGIT.0'" target="int1" /&gt;
                &lt;transition event="POINT" target="frac1" /&gt;
            &lt;/state&gt;
            &lt;state id="int1"&gt;
                &lt;transition event="POINT" target="frac1" /&gt;
                &lt;transition event="DIGIT"&gt;
                    &lt;assign location="short_expr" expr="short_expr+_event.name.substr(_event.name.lastIndexOf('.')+1)" /&gt;
                    &lt;send event="DISPLAY.UPDATE" /&gt;
                &lt;/transition&gt;
                &lt;onentry&gt;
                    &lt;assign location="short_expr" expr="short_expr+_event.name.substr(_event.name.lastIndexOf('.')+1)" /&gt;
                    &lt;send event="DISPLAY.UPDATE" /&gt;
                &lt;/onentry&gt;
            &lt;/state&gt;
            &lt;state id="frac1"&gt;
                &lt;onentry&gt;
                    &lt;assign location="short_expr" expr="short_expr+'.'" /&gt;
                    &lt;send event="DISPLAY.UPDATE" /&gt;
                &lt;/onentry&gt;
                &lt;transition event="DIGIT"&gt;
                    &lt;assign location="short_expr" expr="short_expr+_event.name.substr(_event.name.lastIndexOf('.')+1)" /&gt;
                    &lt;send event="DISPLAY.UPDATE" /&gt;
                &lt;/transition&gt;
            &lt;/state&gt;
            &lt;transition event="OPER" target="opEntered" /&gt;
        &lt;/state&gt;
        &lt;state id="opEntered"&gt;
            &lt;transition event="OPER.MINUS" target="negated2" /&gt;
            &lt;transition event="POINT" target="frac2" /&gt;
            &lt;transition event="DIGIT.0" target="zero2" /&gt;
            &lt;transition event="DIGIT" target="int2" /&gt;
            &lt;onentry&gt;
                &lt;raise event="CALC.SUB" /&gt;
                &lt;send target="_internal" event="OP.INSERT"&gt;
                    &lt;param name="operator" expr="_event.name" /&gt;
                &lt;/send&gt;
            &lt;/onentry&gt;
        &lt;/state&gt;
        &lt;state id="negated2"&gt;
            &lt;onentry&gt;
                &lt;assign location="short_expr" expr="'-'" /&gt;
                &lt;send event="DISPLAY.UPDATE" /&gt;
            &lt;/onentry&gt;
            &lt;transition event="DIGIT.0" target="zero2" /&gt;
            &lt;transition event="DIGIT" target="int2" /&gt;
            &lt;transition event="POINT" target="frac2" /&gt;
        &lt;/state&gt;
        &lt;state id="operand2"&gt;
            &lt;state id="zero2"&gt;
                &lt;transition event="DIGIT" cond="_event.name != 'DIGIT.0'" target="int2" /&gt;
                &lt;transition event="POINT" target="frac2" /&gt;
            &lt;/state&gt;
            &lt;state id="int2"&gt;
               &lt;transition event="DIGIT"&gt;
                    &lt;assign location="short_expr" expr="short_expr+_event.name.substr(_event.name.lastIndexOf('.')+1)" /&gt;
                    &lt;send event="DISPLAY.UPDATE" /&gt;
                &lt;/transition&gt;
                &lt;onentry&gt;
                    &lt;assign location="short_expr" expr="short_expr+_event.name.substr(_event.name.lastIndexOf('.')+1)" /&gt;
                    &lt;send event="DISPLAY.UPDATE" /&gt;
                &lt;/onentry&gt;
                &lt;transition event="POINT" target="frac2" /&gt;
            &lt;/state&gt;
            &lt;state id="frac2"&gt;
                &lt;onentry&gt;
                    &lt;assign location="short_expr" expr="short_expr +'.'" /&gt;
                    &lt;send event="DISPLAY.UPDATE" /&gt;
                &lt;/onentry&gt;
                &lt;transition event="DIGIT"&gt;
                    &lt;assign location="short_expr" expr="short_expr +_event.name.substr(_event.name.lastIndexOf('.')+1)" /&gt;
                    &lt;send event="DISPLAY.UPDATE" /&gt;
                &lt;/transition&gt;
            &lt;/state&gt;
            &lt;transition event="OPER" target="opEntered"&gt;
                &lt;raise event="CALC.SUB" /&gt;
                &lt;raise event="OP.INSERT" /&gt;
            &lt;/transition&gt;
            &lt;transition event="EQUALS" target="result"&gt;
                &lt;raise event="CALC.SUB" /&gt;
                &lt;raise event="CALC.DO" /&gt;
            &lt;/transition&gt;
        &lt;/state&gt;
        &lt;transition event="C" target="on" /&gt;
    &lt;/state&gt;
    &lt;transition event="CALC.DO"&gt;
        &lt;assign location="short_expr" expr="''+ res" /&gt;
        &lt;assign location="long_expr" expr="''" /&gt;
        &lt;assign location="res" expr="0" /&gt;
    &lt;/transition&gt;
    &lt;transition event="CALC.SUB"&gt;
        &lt;if cond="short_expr!=''"&gt;
            &lt;assign location="long_expr" expr="long_expr+'('+short_expr+')'" /&gt;
        &lt;/if&gt;
        &lt;assign location="res" expr="eval(long_expr)" /&gt;
        &lt;assign location="short_expr" expr="''" /&gt;
        &lt;send event="DISPLAY.UPDATE" /&gt;
    &lt;/transition&gt;
    &lt;transition event="DISPLAY.UPDATE"&gt;
        &lt;log level="0" label="'result'" expr=".short_expr==''?res:short_expr" /&gt;
    &lt;/transition&gt;
    &lt;transition event="OP.INSERT"&gt;
        &lt;log level="0" expr="_event.data[0]" /&gt;
        &lt;if cond="_event.data[0] == 'OPER.PLUS'"&gt;
            &lt;assign location="long_expr" expr="long_expr+'+'" /&gt;
        &lt;elseif cond="_event.data[0]=='OPER.MINUS'" /&gt;
            &lt;assign location="long_expr" expr="long_expr+'-'" /&gt;
        &lt;elseif cond="_event.data[0]=='OPER.STAR'" /&gt;
            &lt;assign location="long_expr" expr="long_expr+'*'" /&gt;
        &lt;elseif cond="_event.data[0]=='OPER.DIV'" /&gt;
            &lt;assign location="long_expr" expr="long_expr+'/'" /&gt;
        &lt;/if&gt;
    &lt;/transition&gt;
    &lt;/state&gt;
&lt;/scxml&gt;
</pre>
</div>
</a></div><a id="N11635" name="N11635">
</a></div><a id="N11635" name="N11635">

</a><div class="div2"><a id="N11635" name="N11635">
</a><h3><a id="N11635" name="N11635"></a><a id="invokeex" name="invokeex">G.5 Examples of Invoke and
finalize</a></h3><a id="invokeex" name="invokeex">

<p>The following two SCXML documents demonstrate the use of Invoke
and finalize. The first example shows the control flow for a voice
portal offering traffic reports.</p>

</a><div class="exampleOuter"><a id="invokeex" name="invokeex">
</a><div class="exampleHeader"><a id="invokeex" name="invokeex"></a><a id="N11641" name="N11641">Example:
Traffic Report</a></div><a id="N11641" name="N11641">

<div class="exampleInner">
<pre>&lt;?xml version="1.0"?&gt;
&lt;?access-control allow="*"?&gt;
&lt;scxml version="1.0" initial="Intro" datamodel="ecmascript"&gt;
  &lt;state id="Intro"&gt;
    &lt;invoke src="dialog.vxml#Intro" type="vxml2"/&gt;
    &lt;transition event="success" cond="sessionChrome.playAds" target="PlayAds"/&gt;
    &lt;transition event="success" cond="!sessionChrome.playAds &amp;amp;&amp;amp; ANIQuality" 
                    target="ShouldGoBack"/&gt;
    &lt;transition event="success" cond="!sessionChrome.playAds &amp;amp;&amp;amp; !ANIQuality" 
                    target="StartOver"/&gt;
  &lt;/state&gt;

  &lt;state id="PlayAds"&gt;
    &lt;invoke src="dialog.vxml#PlayAds" type="vxml2"/&gt;
    &lt;transition event="success" cond="ANIQuality" target="ShouldGoBack"/&gt;
    &lt;transition event="success" cond="!ANIQuality" target="StartOver"/&gt;
  &lt;/state&gt;

  &lt;state id="StartOver"&gt;
    &lt;onenter&gt;
      &lt;script&gt;enterStartOver();&lt;/script&gt;
    &lt;/onenter&gt;
    &lt;invoke src="dialog.vxml#StartOver" type="vxml2"&gt;
      &lt;param name="gotItFromANI" expr="gotItFromANI"/&gt;
      &lt;finalize&gt;
        &lt;script&gt;finalizeStartOver();&lt;/script&gt;
      &lt;/finalize&gt;
    &lt;/invoke&gt;
    &lt;transition event="success" target="ShouldGoBack"/&gt;
    &lt;transition event="doOver" target="StartOver"/&gt;
    &lt;transition event="restart" target="Intro"/&gt; &lt;!-- bail out to caller --&gt;
  &lt;/state&gt;

  &lt;state id="ShouldGoBack"&gt;
    &lt;invoke src="dialog.vxml#ShouldGoBack" type="vxml2"&gt;
      &lt;param name="cityState" expr="cityState"/&gt;
      &lt;param name="gotItFromANI" expr="gotItFromANI"/&gt;
      &lt;finalize&gt;
        &lt;script&gt;finalizeShouldGoBack();&lt;/script&gt;
      &lt;/finalize&gt;
    &lt;/invoke&gt;
    &lt;transition event="highWay" target="HighwayReport"/&gt;
    &lt;transition event="go_back" target="StartOver"/&gt;
    &lt;transition event="doOver" target="ShouldGoBack"/&gt;
    &lt;transition event="restart" target="Intro"/&gt;
  &lt;/state&gt;

  &lt;state id="HighwayReport"&gt;
    &lt;invoke src="dialog.vxml#HighwayReport" type="vxml2"&gt;
      &lt;param name="cityState" expr="cityState"/&gt;
      &lt;param name="gotItFromANI" expr="gotItFromANI"/&gt;
      &lt;param name="playHRPrompt" expr="playHRPrompt"/&gt;
      &lt;param name="metroArea" expr="metroArea"/&gt;
      &lt;finalize&gt;
        &lt;script&gt;finalizeHighwayReport();&lt;/script&gt;
      &lt;/finalize&gt;
    &lt;/invoke&gt;
    &lt;transition event="highway" target="PlayHighway"/&gt;
    &lt;transition event="go_back" target="StartOver"/&gt;
    &lt;transition event="doOver" target="HighwayReport"/&gt;
    &lt;transition event="fullreport" target="FullReport"/&gt;
    &lt;transition event="restart" target="Intro"/&gt;
  &lt;/state&gt;

  &lt;state id="FullReport"&gt;
    &lt;invoke src="dialog.vxml#FullReport" type="vxml2"&gt;
      &lt;param name="cityState" expr="cityState"/&gt;
      &lt;param name="metroArea" expr="metroArea"/&gt;
      &lt;finalize&gt;
        &lt;script&gt;finalizeFullReport();&lt;/script&gt;
      &lt;/finalize&gt;
    &lt;/invoke&gt;
    &lt;transition event="go_back" target="HighwayReport"/&gt;
    &lt;transition event="new_city" target="StartOver"/&gt;
  &lt;/state&gt;

  &lt;state id="PlayHighway"&gt;
    &lt;invoke src="dialog.vxml#PlayHighway" type="vxml2"&gt;
      &lt;param name="cityState" expr="cityState"/&gt;
      &lt;param name="curHighway" expr="curHighway"/&gt;
      &lt;finalize&gt;
        &lt;script&gt;finalizePlayHighway();&lt;/script&gt;
      &lt;/finalize&gt;
    &lt;/invoke&gt;
    &lt;transition event="go_back" target="HighwayReport"/&gt;
  &lt;/state&gt;
&lt;/scxml&gt;

</pre>
</div>
</a></div><a id="N11641" name="N11641">

<p>The following example shows a the control flow for a blackjack
game.</p>

</a><div class="exampleOuter"><a id="N11641" name="N11641">
</a><div class="exampleHeader"><a id="N11641" name="N11641"></a><a id="N11649" name="N11649">Example:
Blackjack</a></div><a id="N11649" name="N11649">

<div class="exampleInner">
<pre>&lt;?xml version="1.0"?&gt;
&lt;?access-control allow="*"?&gt;
&lt;scxml version="1.0" datamodel="ecmascript" initial="master"&gt; &lt;state id="master"&gt;
    &lt;initial id="init1"&gt;
      &lt;transition target="_home"/&gt;
    &lt;/initial&gt;
    &lt;transition event="new_dealer" target="NewDealer"/&gt;
    &lt;transition event="mumble" target="_home"/&gt; &lt;!-- bail out to caller --&gt;
    &lt;transition event="silence" target="_home"/&gt; &lt;!-- bail out to caller --&gt;
    &lt;state id="_home"&gt;
      &lt;onenter&gt;
        &lt;script&gt;
        _data = {};
        &lt;/script&gt;
      &lt;/onenter&gt;
      &lt;invoke src="datamodel.v3#InitDataModel" type="vxml3"&gt;
        &lt;finalize&gt;
          &lt;script&gt;
          var n;
          for (n in event) {
              _data[n] = event[n];
          }
          &lt;/script&gt;
        &lt;/finalize&gt;
      &lt;/invoke&gt;
      &lt;transition event="success" target="Welcome"/&gt;
    &lt;/state&gt;

    &lt;state id="Welcome"&gt;
      &lt;invoke src="dialog.vxml#Welcome" type="vxml3"&gt;
        &lt;param name="skinpath" expr="skinpath"/&gt;
      &lt;/invoke&gt;
      &lt;transition event="success" target="Intro2"/&gt;
    &lt;/state&gt;

    &lt;state id="Intro2"&gt;
      &lt;invoke src="dialog.vxml#Intro2" type="vxml3"&gt;
        &lt;param name="skinpath" expr="skinpath"/&gt;
      &lt;/invoke&gt;
      &lt;transition event="success" target="EvalDeal"/&gt;
    &lt;/state&gt;

    &lt;state id="EvalDeal"&gt;
      &lt;onenter&gt;
        &lt;script&gt;enterEvalDeal();&lt;/script&gt;
      &lt;/onenter&gt;
      &lt;invoke src="dialog.vxml#EvalDeal" type="vxml3"&gt;
        &lt;param name="skinpath" expr="skinpath"/&gt;
        &lt;param name="playercard1" expr="playercard1"/&gt;
        &lt;param name="playercard2" expr="playercard2"/&gt;
        &lt;param name="playertotal" expr="blackjack.GetTotalOf('caller').toString()"/&gt;
        &lt;param name="dealercardshowing" expr="dealercardshowing"/&gt;
      &lt;/invoke&gt;
      &lt;transition event="success" target="AskHit"/&gt;
    &lt;/state&gt;

    &lt;state id="AskHit"&gt;
      &lt;invoke src="dialog.vxml#AskHit" type="vxml3"&gt;
        &lt;param name="skinpath" expr="skinpath"/&gt;
        &lt;finalize&gt;
          &lt;script&gt;finalizeAskHit();&lt;/script&gt;
        &lt;/finalize&gt;
      &lt;/invoke&gt;
      &lt;transition event="hit" target="PlayNewCard"/&gt;
      &lt;transition event="stand" target="PlayDone"/&gt;
    &lt;/state&gt;

    &lt;state id="PlayNewCard"&gt;
      &lt;invoke src="dialog.vxml#PlayNewCard" type="vxml3"&gt;
        &lt;param name="skinpath" expr="skinpath"/&gt;
        &lt;param name="playernewcard" expr="playernewcard"/&gt;
        &lt;param name="playertotal" expr="blackjack.GetTotalOf('caller').toString()"/&gt;
      &lt;/invoke&gt;
      &lt;transition event="success" cond="blackjack.GetTotalOf('caller') &amp;gt;= 21" target="PlayDone"/&gt;
      &lt;transition event="success" target="AskHit"/&gt; &lt;!-- less than 21 --&gt;
    &lt;/state&gt;

    &lt;state id="PlayDone"&gt;
      &lt;onenter&gt;
        &lt;script&gt;enterPlayDone();&lt;/script&gt;
      &lt;/onenter&gt;
      &lt;invoke src="dialog.vxml#PlayDone" type="vxml3"&gt;
        &lt;param name="skinpath" expr="skinpath"/&gt;
        &lt;param name="gameresult" expr="blackjack.GetGameResult()"/&gt;
        &lt;param name="dealertotal" expr="blackjack.GetTotalOf('dealer').toString()"/&gt;
      &lt;/invoke&gt;
      &lt;transition event="playagain" target="Intro2"/&gt;
      &lt;transition event="quit" target="_home"/&gt;
    &lt;/state&gt;

    &lt;state id="NewDealer"&gt;
      &lt;onenter&gt;
       &lt;script&gt;enterNewDealer();&lt;/script&gt;
      &lt;/onenter&gt;
      &lt;invoke src="dialog.vxml#Dummy" type="vxml3"/&gt;
      &lt;transition event="success" target="Welcome"/&gt;
    &lt;/state&gt;
  &lt;/state&gt;
&lt;/scxml&gt;


</pre>
</div>
</a></div><a id="N11649" name="N11649">
</a></div><a id="N11649" name="N11649">

</a><div class="div2"><a id="N11649" name="N11649">
</a><h3><a id="N11649" name="N11649"></a><a id="content_and_namespaces" name="content_and_namespaces">G.6 Inline Content and
Namespaces</a></h3><a id="content_and_namespaces" name="content_and_namespaces">

<p>Since SCXML documents are XML documents, normal XML namespace
rules apply to inline content specified with &lt;content&gt; and
&lt;data&gt;. In particular, if no namespace is specified, the
inline content will be placed in the SCXML namespace. Consider the
following example:</p>

<div class="exampleOuter">
<div class="exampleInner">
<pre>     
 &lt;send target="http://example.com/send/target" type="'http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor'"&gt;
   &lt;content&gt;
     &lt;a&gt;fffff&lt;/a&gt;
   &lt;/content&gt;
  &lt;/send&gt;
 
</pre>
</div>
</div>

<p>The recipient of the message will see the following:</p>

<div class="exampleOuter">
<div class="exampleInner">
<pre>     
 &lt;a xmlns="http://www.w3.org/2005/07/scxml"&gt;fffff&lt;/a&gt;
 
</pre>
</div>
</div>

<p>The following markup would cause the message to be delivered
without namespaces:</p>

<div class="exampleOuter">
<div class="exampleInner">
<pre>     
 &lt;send target="http://example.com/send/target" type="'http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor'"&gt;
   &lt;content&gt;
     &lt;a xmlns=""&gt;fffff&lt;/a&gt;
   &lt;/content&gt;
  &lt;/send&gt;
 
</pre>
</div>
</div>

<p>The recipient of the message will see the following:</p>

<div class="exampleOuter">
<div class="exampleInner">
<pre>     
 &lt;a&gt;fffff&lt;/a&gt;
 
</pre>
</div>
</div>

<p>The sender can also specify multiple namespaces:</p>

<div class="exampleOuter">
<div class="exampleInner">
<pre>     
&lt;send target="http://example.com/send/target" type="'http://www.w3.org/TR/scxml/#BasicHTTPEventProcessor'"&gt;
 &lt;content&gt;
   &lt;root xmlns="http://example.com/r" xmlns:a="http://example.com/a" xmlns:b="http://example.com/b" xmlns:c="http://example.com/c"&gt;
      &lt;a:alpha&gt;1&lt;/a:alpha&gt;
      &lt;b:beta&gt;2&lt;/b:beta&gt;
      &lt;c:gamma&gt;3&lt;/c:gamma&gt;
   &lt;/root&gt;
 &lt;/content&gt;
&lt;/send&gt;
 
</pre>
</div>
</div>

<p>In this case, the receiver would see:</p>

<div class="exampleOuter">
<div class="exampleInner">
<pre>  
  &lt;root xmlns="http://example.com/r"&gt;
      &lt;alpha xmlns="http://example.com/a"&gt;1&lt;/alpha&gt;
      &lt;beta xmlns="http://example.com/b&gt;2&lt;/beta&gt;
      &lt;gamma xmlns="http://example.com/c&gt;3&lt;/gamma&gt;
  &lt;/root&gt;
 
</pre>
</div>
</div>
</a></div><a id="content_and_namespaces" name="content_and_namespaces">

</a><div class="div2"><a id="content_and_namespaces" name="content_and_namespaces">
</a><h3><a id="content_and_namespaces" name="content_and_namespaces"></a><a id="custom_action" name="custom_action">G.7 Custom Action
Elements</a></h3><a id="custom_action" name="custom_action">

<p>Custom Action Elements can be defined in other
specifications/namespaces and are responsible for performing
actions on behalf of custom components. Logically Custom Action
Elements can be thought of as a collection of actions and handlers
to perform specific tasks. An example of this is a CCXML
&lt;accept&gt; element that is a Custom Action Element:</p>

<div class="exampleInner">
<pre>&lt;transition event="ccxml:connection.alerting"&gt;
  &lt;ccxml:accept connectionid="_event.data.connectionid"/&gt;
&lt;/transition&gt;
</pre>
</div>

<p>This could be written using a &lt;send&gt; element using the
following syntax:</p>

<div class="exampleInner">
<pre>&lt;datamodel&gt;
&lt;data name="connectionid"/&gt;
&lt;/datamodel&gt;
&lt;transition event="ccxml:connection.alerting"&gt;
  &lt;assign location="connectionid" expr="_event.data.connectionid"/&gt;
 &lt;send type="ccxml" event="ccxml:accept" namelist="connectionid"/&gt; 
&lt;/transition&gt;
</pre>
</div>

<p>A more complicated example might be a CCXML &lt;createcall&gt;
where you are both providing variables and getting values back that
using only the &lt;send&gt; syntax would be more complex as it
would need to be broken over several steps. For example:</p>

<div class="exampleInner">
<pre>&lt;onentry&gt;
  &lt;ccxml:createcall dest="'tel:+18315552020'" connectionid="myConnectionID"/&gt; 
&lt;/onentry&gt;
</pre>
</div>

<p>Would need to be modeled in two steps using &lt;send&gt; as you
would need to do something like the following:</p>

<div class="exampleInner">
<pre>&lt;datamodel&gt;
  &lt;data name="dest" expr="'tel:+18315552020'"/&gt;
  &lt;data name="connectionid"/&gt;
&lt;/datamodel&gt;
&lt;onentry&gt;
  &lt;send type="ccxml" event="ccxml:createcall" namelist="dest"/&gt;
&lt;/onentry&gt;
&lt;transition event="ccxml:createcall.success"&gt;
   &lt;assign location="connectionid" expr="_event.data.connectionid"/&gt;
&lt;/transition&gt;
</pre>
</div>

<p>The exact mappings between Custom Action Elements and
&lt;send&gt; actions are to be defined in the individual Custom
Action Element specifications.</p>
</a></div><a id="custom_action" name="custom_action">
</a></div><a id="custom_action" name="custom_action">

</a><div class="div1"><a id="custom_action" name="custom_action">
</a><h2><a id="custom_action" name="custom_action"></a><a id="mimetype" name="mimetype">H MIME Type</a></h2><a id="mimetype" name="mimetype">

<p>[This section is normative.]</p>

<p>This appendix registers a new MIME media type,
"<code>application/scxml+xml</code>".</p>

<p>The "<code>application/scxml+xml</code>" media type is being
submitted to the IESG for review, approval, and registration with
IANA.</p>

</a><div class="div2"><a id="mimetype" name="mimetype">
</a><h3><a id="mimetype" name="mimetype"></a><a id="media-type-registration" name="media-type-registration">H.1 Registration of MIME media
type application/scxml+xml</a></h3><a id="media-type-registration" name="media-type-registration">

</a><dl><a id="media-type-registration" name="media-type-registration">
<dt class="label">MIME media type name:</dt>

<dd><code>application</code></dd>

<dt class="label">MIME subtype name:</dt>

<dd><code>scxml+xml</code></dd>

<dt class="label">Required parameters:</dt>

<dd>None</dd>

<dt class="label">Optional parameters:</dt>

</a><dd><a id="media-type-registration" name="media-type-registration">
</a><dl><a id="media-type-registration" name="media-type-registration">
<dd><code>charset</code></dd>

</a><dd><a id="media-type-registration" name="media-type-registration">This parameter has identical semantics to the
<code>charset</code> parameter of the <code>application/xml</code>
media type as specified in </a><a href="http://www.w3.org/TR/scxml/#RFC3023">[RFC 3023]</a> or its
successor.</dd>
</dl>
</dd>

<dt class="label">Encoding considerations:</dt>

<dd>By virtue of SCXML content being XML, it has the same
considerations when sent as "application/scxml+xml"as does XML. See
<a href="http://www.w3.org/TR/scxml/#RFC3023">[RFC 3023]</a> (or its successor), section
3.2.</dd>

<dt class="label">Security considerations:</dt>

<dd>SCXML elements may include arbitrary URIs. Therefore, the
security issues of <a href="http://www.w3.org/TR/scxml/#RFC3986">[RFC 3986]</a> section 7
should be considered. In addition, because of the extensibility
features for SCXML, it is possible that
"<code>application/scxml+xml</code>" may describe content that has
security implications beyond those described here. However, if the
processor follows only the normative semantics of this
specification, this content will be ignored. Only in the case where
the processor recognizes and processes the additional content, or
where further processing of that content is dispatched to other
processors, would security issues potentially arise. And in that
case, they would fall outside the domain of this registration
document.</dd>

<dt class="label">Interoperability considerations:</dt>

<dd>This specification describes processing semantics that dictate
behavior that must be followed when dealing with, among other
things, unrecognized elements.Because SCXML is extensible,
conformant "<code>application/scxml+xml</code>" processors MAY
expect that content received is well-formed XML, but processors
SHOULD NOT assume that the content is valid SCXML or expect to
recognize all of the elements and attributes in the document.</dd>

<dt class="label">Published specification:</dt>

<dd>This media type registration is extracted from Appendix H of
the <a href="http://www.w3.org/TR/scxml/">State Chart XML (SCXML):
State Machine Notation for Control Abstraction</a>
specification.</dd>

<dt class="label">Additional information:</dt>

<dd>
<dl>
<dt class="label">Magic number(s):</dt>

<dd>There is no single initial octet sequence that is always
present in SCXML documents.</dd>

<dt class="label">File extension(s):</dt>

<dd>SCXML documents are most often identified with the extensions
"<code>.scxml</code>".</dd>

<dt class="label">Macintosh File Type Code(s):</dt>

<dd>TEXT</dd>
</dl>
</dd>

<dt class="label">Person and email address to contact for further
information:</dt>

<dd>Kazuyuki Ashimura, &lt;<a href="mailto:ashimura@w3.org">ashimura@w3.org</a>&gt;.</dd>

<dt class="label">Intended usage:</dt>

<dd>COMMON</dd>

<dt class="label">Restrictions on usage:</dt>

<dd>None</dd>

<dt class="label">Author:</dt>

<dd>The SCXML specification is a work product of the World Wide Web
Consortium's Voice Browser Working Group.</dd>

<dt class="label">Change controller:</dt>

<dd>The W3C has change control over these specifications.</dd>
</dl>
</div>

<div class="div2">
<h3><a id="media-type-fragid" name="media-type-fragid">H.2
Fragment Identifiers</a></h3><a id="media-type-fragid" name="media-type-fragid">

<p>For documents labeled as "<code>application/scxml+xml</code>",
the fragment identifier notation is exactly that for
"<code>application/xml</code>", as specified in RFC 3023.</p>
</a></div><a id="media-type-fragid" name="media-type-fragid">
</a></div><a id="media-type-fragid" name="media-type-fragid">

</a><div class="div1"><a id="media-type-fragid" name="media-type-fragid">
</a><h2><a id="media-type-fragid" name="media-type-fragid"></a><a id="references" name="references">I References</a></h2><a id="references" name="references">

</a><div class="div2"><a id="references" name="references">
</a><h3><a id="references" name="references"></a><a id="N1173E" name="N1173E">I.1 Normative References</a></h3><a id="N1173E" name="N1173E">

</a><dl><a id="N1173E" name="N1173E">
</a><dt class="label"><a id="N1173E" name="N1173E"></a><a id="ECMAScript262" name="ECMAScript262">ECMASCRIPT-262</a></dt><a id="ECMAScript262" name="ECMAScript262">

</a><dd><a id="ECMAScript262" name="ECMAScript262"></a><a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">
<cite>ECMAScript Language Specification. Standard ECMA-262, Edition
5.1</cite></a> ECMA. June 2011. (See
http://www.ecma-international.org/publications/standards/Ecma-262.htm.)</dd>

<dt class="label"><a id="ECMAScript327" name="ECMAScript327">ECMASCRIPT-327</a></dt><a id="ECMAScript327" name="ECMAScript327">

</a><dd><a id="ECMAScript327" name="ECMAScript327"></a><a href="http://www.ecma-international.org/publications/standards/Ecma-327.htm">
<cite>ECMAScript 3rd Edition Compact Profile. Standard
ECMA-327</cite></a> ECMA. June 2001. (See
http://www.ecma-international.org/publications/standards/Ecma-327.htm.)</dd>

<dt class="label"><a id="E4X" name="E4X">E4X</a></dt><a id="E4X" name="E4X">

</a><dd><a id="E4X" name="E4X"></a><a href="http://www.ecma-international.org/publications/standards/Ecma-357.htm">
<cite>ECMAScript for XML (E4X) Specification</cite></a> Standard
ECMA-357, 2nd Edition, December 2005. (See
http://www.ecma-international.org/publications/standards/Ecma-357.htm.)</dd>

<dt class="label"><a id="RFC2119" name="RFC2119">RFC 2119</a></dt><a id="RFC2119" name="RFC2119">

</a><dd><a id="RFC2119" name="RFC2119"></a><a href="http://www.ietf.org/rfc/rfc2119.txt"><cite>RFC 2119:
Key words for use in RFCs to Indicate Requirement Levels</cite></a>
Internet Engineering Task Force. March 1997. (See
http://www.ietf.org/rfc/rfc2119.txt.)</dd>

<dt class="label"><a id="RFC2396" name="RFC2396">RFC 2396</a></dt><a id="RFC2396" name="RFC2396">

</a><dd><a id="RFC2396" name="RFC2396"></a><a href="http://www.ietf.org/rfc/rfc2396.txt"><cite>RFC 2396:
Uniform Resource Identifiers</cite></a> Internet Engineering Task
Force. August 1998. (See http://www.ietf.org/rfc/rfc2396.txt.)</dd>

<dt class="label"><a id="HTTP" name="HTTP">RFC 2616</a></dt><a id="HTTP" name="HTTP">

</a><dd><a id="HTTP" name="HTTP"></a><a href="http://www.ietf.org/rfc/rfc2616.txt"><cite>RFC 2616:
Hypertext Transfer Protocol -- HTTP/1.1</cite></a> Internet
Engineering Task Force. June 1999. (See
http://www.ietf.org/rfc/rfc2616.txt.)</dd>

<dt class="label"><a id="JSON" name="JSON">RFC 4627</a></dt><a id="JSON" name="JSON">

</a><dd><a id="JSON" name="JSON"></a><a href="http://www.ietf.org/rfc/rfc4627.txt"><cite>The
application/json Media Type for JavaScript Object Notation
(JSON)</cite></a> Internet Engineering Task Force. July 2006. (See
http://www.ietf.org/rfc/rfc4627.txt.)</dd>

<dt class="label"><a id="RFC3023" name="RFC3023">RFC 3023</a></dt><a id="RFC3023" name="RFC3023">

</a><dd><a id="RFC3023" name="RFC3023"></a><a href="http://www.ietf.org/rfc/rfc3023.txt"><cite>RFC 3023:
XML Media Types.</cite></a> Internet Engineering Task Force.
January 2001. (See http://www.ietf.org/rfc/rfc3023.txt.)</dd>

<dt class="label"><a id="RFC3986" name="RFC3986">RFC 3986</a></dt><a id="RFC3986" name="RFC3986">

</a><dd><a id="RFC3986" name="RFC3986"></a><a href="http://www.ietf.org/rfc/rfc3986.txt"><cite>RFC 3986:
Uniform Resource Identifier (URI): Generic Syntax.</cite></a>
Internet Engineering Task Force. January 2005. (See
http://www.ietf.org/rfc/rfc3986.txt.)</dd>

<dt class="label"><a id="XML" name="XML">XML</a></dt><a id="XML" name="XML">

</a><dd><a id="XML" name="XML"></a><a href="http://www.w3.org/TR/xml/"><cite>Extensible Markup
Language (XML) 1.0 (Fifth Edition)</cite></a> World Wide Web
Consortium. W3C Recommendation, November 2008 (See
http://www.w3.org/TR/xml/.)</dd>

<dt class="label"><a id="XMLNames" name="XMLNames">XMLNames</a></dt><a id="XMLNames" name="XMLNames">

</a><dd><a id="XMLNames" name="XMLNames"></a><a href="http://www.w3.org/TR/2006/REC-xml-names-20060816/"><cite>Namespaces
in XML 1.0 (Second Edition)</cite></a> World Wide Web Consortium.
W3C Recommendation, August 2006 (See
http://www.w3.org/TR/2006/REC-xml-names-20060816/.)</dd>

<dt class="label"><a id="Schema" name="Schema">XML Schema</a></dt><a id="Schema" name="Schema">

</a><dd><a id="Schema" name="Schema"></a><a href="http://www.w3.org/TR/xmlschema-2/"><cite>XML Schema
Part 2: Datatypes Second Edition</cite></a> World Wide Web
Consortium. W3C Recommendation, October 2004. (See
http://www.w3.org/TR/xmlschema-2/.)</dd>
</dl>
</div>

<div class="div2">
<h3><a id="N117DA" name="N117DA">I.2 Informative References</a></h3><a id="N117DA" name="N117DA">

</a><dl><a id="N117DA" name="N117DA">
</a><dt class="label"><a id="N117DA" name="N117DA"></a><a id="ebXML" name="ebXML">ebXML</a></dt><a id="ebXML" name="ebXML">

</a><dd><a id="ebXML" name="ebXML"></a><a href="https://www.oasis-open.org/committees/documents.php?wg_abbrev=ebxml-bp">
<cite>ebXML Business Process Specification Schema v2.0</cite></a>
(See
https://www.oasis-open.org/committees/documents.php?wg_abbrev=ebxml-bp.)</dd>

<dt class="label"><a id="EL" name="EL">EL</a></dt><a id="EL" name="EL">

</a><dd><a id="EL" name="EL"></a><a href="http://commons.apache.org/el/"><cite>EL: The JSP 2.0
Expression Language Interpreter</cite></a> (See
http://commons.apache.org/el/.)</dd>

<dt class="label"><a id="Harel_Politi" name="Harel_Politi">Harel
and Politi</a></dt><a id="Harel_Politi" name="Harel_Politi">

</a><dd><a id="Harel_Politi" name="Harel_Politi"></a><a href="http://www.wisdom.weizmann.ac.il/~dharel/reactive_systems.html">
<cite>Modeling Reactive Systems with Statecharts: The STATEMATE
Approach</cite></a> By D. Harel and M. Politi. McGraw-Hill, 1998.
(See
http://www.wisdom.weizmann.ac.il/~dharel/reactive_systems.html.)</dd>

<dt class="label"><a id="CCXML" name="CCXML">CCXML 1.0</a></dt><a id="CCXML" name="CCXML">

</a><dd><a id="CCXML" name="CCXML"></a><a href="http://www.w3.org/TR/2011/REC-ccxml-20110705/"><cite>Voice
Browser Call Control: CCXML Version 1.0</cite></a> World Wide Web
Consortium. W3C Recommendation, July 2011. (See
http://www.w3.org/TR/2011/REC-ccxml-20110705/.)</dd>

<dt class="label"><a id="VoiceXML" name="VoiceXML">VoiceXML
2.0</a></dt><a id="VoiceXML" name="VoiceXML">

</a><dd><a id="VoiceXML" name="VoiceXML"></a><a href="http://www.w3.org/TR/voicexml20/"><cite>VoiceXML
2.0:</cite></a> World Wide Web Consortium. W3C Recommendation,
March 2004. (See http://www.w3.org/TR/voicexml20/.)</dd>

<dt class="label"><a id="UML" name="UML">UML 2.3</a></dt><a id="UML" name="UML">

</a><dd><a id="UML" name="UML"></a><a href="http://www.omg.org/spec/UML/2.3/"><cite>UML
Specification Version 2.3</cite></a> OMG, 2009. (See
http://www.omg.org/spec/UML/2.3/.)</dd>

<dt class="label"><a id="xinclude" name="xinclude">xinclude</a></dt><a id="xinclude" name="xinclude">

</a><dd><a id="xinclude" name="xinclude"></a><a href="http://www.w3.org/TR/xinclude/"><cite>XML Inclusions
(XInclude) Version 1.0 (Second Editiion)</cite></a> W3C
Recommendation, 2006. (See http://www.w3.org/TR/xinclude/.)</dd>

<dt class="label"><a id="XMI" name="XMI">UML XMI</a></dt><a id="XMI" name="XMI">

</a><dd><a id="XMI" name="XMI"></a><a href="http://www.omg.org/spec/XMI/"><cite>XML Metadata
Exchange version 2.4.1</cite></a> OMG. August 2011. (See
http://www.omg.org/spec/XMI/.)</dd>

<dt class="label"><a id="XTND" name="XTND">XTND</a></dt><a id="XTND" name="XTND">

</a><dd><a id="XTND" name="XTND"></a><a href="http://www.w3.org/TR/2000/NOTE-xtnd-20001121/"><cite>XML
Transition Network Definition</cite></a> World Wide Web Consortium.
W3C Note, November 2000. (See
http://www.w3.org/TR/2000/NOTE-xtnd-20001121/.)</dd>
</dl>
</div>
</div>
</div>



</div></body></html>